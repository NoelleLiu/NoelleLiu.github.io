<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Less</title>
    <link href="/2023/05/16/Less/"/>
    <url>/2023/05/16/Less/</url>
    
    <content type="html"><![CDATA[<h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><h4>CSS的弊端</h4><ul>    <li>CSS冗余度很高</li>    <li>不利于复用代码</li>    <li>CSS没有很好的计算能力</li></ul><h4>Less(Leaner Style Sheets)</h4><p>Less是一门<span class="red">CSS扩展语言</span>，也称为<span class="red">CSS</span>预处理器，在现有的CSS语法的基础上，加入<strong>程序式</strong>语言的特性。最大的特点就是引入了变量、函数等功能，用最少的代码做更多的事情。</p><h3>1. Less变量</h3><p>e.g. @color: pink; <br></p><p>​body {</p><p>​background-color: @color; }</p><h3>2. Less编译</h3><p><u>Easy LESS</u>插件可以使保存的less文件自动生成css文件</p><h3>3. Less嵌套</h3><p>在css选择器中的子代选择器be like: .header logo{}， 但是在less中，子元素的样式需要嵌套在父元素的样式中书写。e.g. .header{logo {}}</p><h3>4. Less实现伪类选择器</h3><p>在Less中，有<span class="red"><strong>&amp;</strong></span>符号，会被解析成<u>父元素本身</u>或者<u>父元素的伪类</u></p><p>e.g. 在css中，a:hover {}; 在Less中，a{&amp;hover{}}</p><h3>5. Less算数运算</h3><p><i class="fa-regular fa-face-smile-plus"></i>在Less中，任何数字、颜色或者变量都可以参与算数运算</p><p>[ 注：若两个不同单位的值进行算数运算， 运算结果取第一个值的单位。e.g. 10px + 5rem &#x3D; 15px;<br></p><p>若只有一个值有单位，则运算结果取该单位。e.g. 10px + 5 &#x3D; 15px]</p><head>    <style>    .red {        color: red;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Less</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端常见布局</title>
    <link href="/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/"/>
    <url>/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h4>1. 流式布局</h4><p>流式布局，也叫百分比布局，也叫非固定像素布局，是通过<strong>盒子的宽度百分比</strong>来进行伸缩，而不选用固定的像素作为大小的单位。</p><h4>2. flex布局<i class="fa-solid fa-star"></i></h4><p>原理：为<u>父盒子指定flex属性</u>后称为<span class="red">容器</span>，所有子元素会自动成为<span class="red">容器成员</span>，通过特定的规则进行排列</p><p>2.1 flex布局容器常见属性</p><ul>    <li>display: flex<br>               将父盒子指定flex属性</li>    <li>flex-direction: row(默认) / row-reverse / column / column-reverse<br>            设置<strong>主轴</strong>的方向</li>    <li>justify-content: flex-start(默认) / flex-end / center / space-around / space-between<br>            设置元素在主轴上的排列方式<br>            [<span class="red">注</span>：space-around是均分剩余空间；space-between是先两边贴边再平分]</li>    <li>flex-wrap: no-wrap(默认) / wrap<br>            是否换行</li>    <li>align-items: flex-start / flex-end/ center / stretch(默认)<br>            设置<strong>侧轴</strong>上元素排列方式</li></ul><p>2.2 flex布局容器成员常见属性</p><ul>         <li>flex: 数字(默认为0)<br>               指定子元素所占的份数</li>        <li>order:数字(默认为0)            定义子元素的排列顺序，数值越小越靠前</li>     </ul><h4>3. rem适配布局</h4><p>3.1 rem（root em）单位：是一个<span class="red">相对单位</span></p><p>​[<i class="fa-solid fa-book"></i>review:  em是指父元素字体大小]</p><p>​rem的基准是相对于<span class="red">html元素字体大小</span></p><p>3.2 <i class="fa-light fa-message-smile"></i>rem的优势： 父元素字体大小可能不一致，但html可以很好的控制页面元素大小。</p><p>3.3 rem布局常和<span class="pink">媒体查询</span>一起使用</p><p>​先通过媒体查询(media query)控制html文字大小， 再通过rem单位进行动态的变化，代码如下图。</p><p><img src="/img/remMediaquery.jpg" alt="Code of rem with media query"></p><head>    <style>        .red {            color: red;}        .pink {            color: pink;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline4-DeepConvLSTMimp</title>
    <link href="/2023/05/16/baseline4-DeepConvLSTMimp/"/>
    <url>/2023/05/16/baseline4-DeepConvLSTMimp/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTMimp"><a href="#DeepConvLSTMimp" class="headerlink" title="DeepConvLSTMimp"></a>DeepConvLSTMimp</h2><p>*模型出处：Improving Deep Learning for HAR with shallow LSTMs</p><h3>模型结构</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i> Opportunity</i></p></li><li><p><i>Wetlab</i></p></li><li><p><i>RealWorld (HAR)</i></p></li><li><p><i>SBHAR</i></p></li><li><p><i>HHAR.</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvLSTM</p><p>在多个数据集上对比了DeepConvLSTM和作者提出的单隐层的DeepConvLSTMimp网络，并且在单隐层的情况下，横向对比了隐藏单元的个数(128，256，512，1024）对结果的影响。</p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: 1e-4</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>网络结构上一咪咪的改动只要足够多的对比工作也行啦~</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p>*不放了…就在把DeepConvLSTM中间的lstm2删了<i class="fa-solid fa-face-grin-squint-tears"></i></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTMimp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline2-EEGNet</title>
    <link href="/2023/05/16/baseline2-EEGNet/"/>
    <url>/2023/05/16/baseline2-EEGNet/</url>
    
    <content type="html"><![CDATA[<h2 id="EEGNet"><a href="#EEGNet" class="headerlink" title="EEGNet"></a>EEGNet</h2><p>*模型出处：EEGNet: A Compact Convolutional Network for EEG-based Brain-Computer Interfaces</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="/img/EEGNet.png" alt="Model"></p><p><img src="/img/EEGNetspecific.png" alt="Details"></p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><img src="/img/EEGNetdataset.png" alt="Dataset"></p><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvNet, ShallowConvNet </p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: not mentioned</li>    <li>epochs: 500</li>    <li>dropout: 0.5forCS / 0.25forSI</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p>在被试独立和被试交叉的情况下，四种范式上均有提升。</p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>出发点: 想要提出一种适合各种BCI范式的通用的网络，并且希望这个通用网络十分紧凑（参数数量少）。</li>    <li>亮点1：将深度卷积和可分离卷积运用到脑电数据上<br>        (1)可分离卷积在这里是指将完整的卷积运算分解为深度卷积+逐点卷积        (2)逐点卷积的作用：学习如何将特征图做优化的结合</li>    <li>亮点2：对被试交叉和被试独立的数据划分情况都做了相应的讨论</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/EEGNetCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EEGNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline3-DeepConvLSTM</title>
    <link href="/2023/05/15/baseline3-DeepConvLSTM/"/>
    <url>/2023/05/15/baseline3-DeepConvLSTM/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTM"><a href="#DeepConvLSTM" class="headerlink" title="DeepConvLSTM"></a>DeepConvLSTM</h2><p>*模型出处：Deep Convolutional and LSTM Recurrent Neural Networks for Multimodal Wearable Activity Recognition </p><h3>模型结构</h3><p><img src="/img/DeepConvLSTM.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>OPPORTUNITY</i></p></li><li><p><i>Skoda</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：不带lstm的CNN（<i class="fa-light fa-thumbs-down"></i>这不就是纯纯消融实验吗？？</p><p>实验控制baseline-CNN和DeepConvLSTM前面的卷积模块和最后的分类模块完全相同，基线CNN的两个dense层是非循环且全连接的；DeepConvLSTM的两个dense层的cell是LSTM cell。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: 10e-3</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMres1.png" alt="ResultinDataset1"></p><p><img src="/img/DeepConvLSTMres2.png" alt="ResultinDataset2"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是考虑到HAR问题的时序性，添加LSTM模</li>    <li>文中提到在他们的实验中使用RMSProp优化器效果更好</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvLSTMCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline1-DeepConv</title>
    <link href="/2023/05/15/baseline1-DeepConv/"/>
    <url>/2023/05/15/baseline1-DeepConv/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConv"><a href="#DeepConv" class="headerlink" title="DeepConv"></a>DeepConv</h2><p>*模型出处：Deep learning with convolutional neural networks for EEG decoding and visualization </p><h3>模型结构</h3><p><img src="/img/DeepConv.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>BCI competition IV dataset 2a</i><span>（ 288 trials per subject）</span></p></li><li><p>自采数据集（880 trials per subject）</p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：FBCSP</p><p>设计了两层的shallowConvNet和五层的DeepConvNet甚至最高到31层的ResNet以及深浅结合的网络。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: not mentioned</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p><img src="/img/DeepConvRes.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是围绕着如何将在图像领域的深度卷积网络运用在脑电数据上。<br>        首先，作者提出了脑电和图像的区别：图像是二维静态的，而脑电数据是在<strong>三维的头皮上获取的时序数据        </strong><br>        接着，作者还提出了，脑电数据相比于图像数据数量太少，需要进行裁剪，也就是分段，作者用的2s一段。        </li>    <li>作者提出的DeepConv网络的Block1是专门为了提取脑电数据信息的：时间维度拼接空间维度</li>    <li>作者通过尝试对神经网络进行解释，得出结论：卷积网络学习了不同频段信息。<br>        <i class="fa-solid fa-hand-sparkles"></i>我可以试着把数据先进行小波包分解再送进网络进行学习</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvCode.png" alt="myCode"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精灵图</title>
    <link href="/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/"/>
    <url>/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h2><h3 id="精灵图的背景"><a href="#精灵图的背景" class="headerlink" title="精灵图的背景"></a>精灵图的背景</h3><p>一个网页中会需要很多小的背景图作为装饰，但是如果图像过多时，服务器频繁的接收和发送请求会使得服务器压力过大，降低加载速度。</p><p><i class="fa-sharp fa-light fa-truck-fast" style="color: #a4d5f4;"></i>为了<span class="red">有效减少服务器接收和发送请求的次数，提高网页的加载速度</span>， 出现了CSS精灵技术</p><h3 id="精灵图的核心原理"><a href="#精灵图的核心原理" class="headerlink" title="精灵图的核心原理"></a>精灵图的核心原理</h3><p>将一堆小的背景图像整合到一张大图 (精灵图sprites) 上，服务器只需要请求一次就可以了~</p><h3 id="精灵图的使用"><a href="#精灵图的使用" class="headerlink" title="精灵图的使用"></a>精灵图的使用</h3><p>移动背景图片的位置，调整<strong>background-position</strong>属性值</p><p>[注：属性值是调整x和y坐标的距离，但是网页的坐标是以左到右为x正方向，上到下为y正方向，所以一般我们都向上向左调整精灵图的位置，数值为<span class="red">负值</span>。]</p><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>sprites</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之三： 定位</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2>定位</h2><p>[Review: 浮动可以让多个块级盒子在一行没有缝隙的排列显示，常用于横向排列盒子。]</p><p>终于轮到定位啦！！</p><ol><li><p>定位的目的： 让盒子自由的在某个盒子内移动位置或者固定位置， 并且可以<span class="red">压住</span>其他盒子</p></li><li><p>定位模式： 也就是position属性可能的属性值： 静态定位static、相对定位relative、绝对定位absolute、固定定位fixed</p><p>2.1 静态定位static（position属性的默认值）：无定位，可以按照标准流来看待</p><p>2.2 相对定位relative：元素在移动位置的时候，相对<u>它本身原来的位置</u>来移动的。</p><p>[<i class="fa-solid fa-flag"></i>注意]原来位置还在，相对定位并<span class="red">没有脱离标准流</span>，后面的盒子仍然以标准流的方式看它。</p><p>2.3 绝对定位absolute：元素在移动的时候，是根据他的<u>祖先元素</u>来移动的</p><p>[<i class="fa-solid fa-flag"></i>注意] 绝对定位是<span class="red">脱标</span>的！</p><p>2.4 固定定位fixed：元素固定在浏览器<u>可视区</u>的某一位置。</p><p>[<i class="fa-solid fa-flag"></i>注意] 固定定位也是脱离标准流的，不占有原来的位置。</p></li><li><p><i class="fa-solid fa-stars"></i>一个非常经典的组合：<span class="red"><strong>子绝父相</strong></span>、子绝父绝</p><p>原因：子级绝对定位不会占有位置，可以放到父盒子里任一个位置，不影响其他兄弟。而父盒子相对定位并没有脱离标准流会限制子盒子。如果父盒子也不需要占位置的话，子绝父绝也是可以滴~</p></li><li><p>绝对定位或者固定定位水平居中：在标准流中，我们可以通过margin: 0 auto；来设置元素水平居中，但是脱离标准流的时候就要{left: 50%; margin-left: -（自身宽度的一半); }</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>position</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之二：浮动</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2>浮动</h2><p>这篇来复盘一下布局三大哥中的二哥： 浮动。</p><ol><li><p>传统页面布局的三种方式： 标准流、<span class="red">浮动</span>、定位。</p></li><li><p>浮动和标准流的差别：</p><ul>    <li>标准流：按照规定好的默认方式排列元素</li>    <li>浮动float：脱离标准流，按自己的规则排列</li></ul></li><li><p>浮动的特性：</p><ul>    <li>脱离标准流，以至于不再保留盒子原来的位置</li>    <li>任何元素都可以进行浮动，且浮动后会具有行内块元素相似的特性，建议如果一个元素浮动，其他的兄弟元素也一起浮动</li>    <li>浮动的元素常和标准流的父级搭配使用</li></ul></li><li><p><i class="fa-solid fa-car-on"></i>浮动可能会带来的问题： 如果父盒子在一些情况下不方便直接给高度，但是子盒子浮动是不占位置的，无法撑开盒子，父盒子的高度为0，会影响后面的标准流盒子。</p></li><li><p>清除浮动：clear: both 清除左右两侧浮动影响</p><p>清除浮动后，父级会根据子盒子自动调整高度，就可以解决上述问题了。</p></li><li><p>具体方法：</p><ol>    <li>额外标签法：在浮动的元素末尾添加一个空标签</li>    <li>父元素添加overflow: hidden属性</li>    <li>:after伪元素法：给父元素添加after伪元素并clear</li>    <li>双伪元素清除浮动：在3的基础上再添加一个:before</li></ol></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之一：盒子模型</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2>盒子模型</h2><p>最近准备找前端实习和工作啦，就在博客上总结一下布局的三大核心：盒子模型，浮动和定位。剩下两个也有单独的讲解~</p><ol><li><p>页面布局的<strong>本质</strong>：利用CSS设置好盒子样式，摆放到相应的位置。（听起来好像很简单，坑很多）</p></li><li><p>盒子模型的组成：把HTML布局元素看成一个矩形的盒子，封装周围的元素，包括：边框border、内边距padding、外边距margin和实际内容content</p><p>2.1 边框border注意:</p> <ul><p>​  <li>复合型写法  border: 1px solid black;</li></p><p>​  <li>细线边框属性：border-collapse: collapse;</li></p><p>​  <li>如果是<strong>border-box</strong>，边框会影响盒子的实际大小，需要减去对应的宽高</p>  </ul><p>2.2 内边距padding注意：</p><ul><p>​  <li>如果padding属性有一个值，代表上下左右的padding都一样；两个值代表上下，左右；三个值代表上，左右，下；四个值代表上，右，下，左</li></p><p>​  <li>如果是<strong>border-box</strong>，padding也会撑大盒子，同理，需要减去对应的宽高</p>  </ul><p>2.3 外边距margin注意：</p><ul><p>​  <li>前两条和padding一样，见2.2</li></p><p>​  <li><i class="fa-solid fa-seal-exclamation"></i><span class="red">外边距的合并</span>会有新的问题：</br></p><p>​(1). <i class="fa-regular fa-triangle-exclamation"></i><strong>相邻</strong>元素垂直外边距合并: 并非相加，而是取大的那个</br></p><p>​(2). <i class="fa-regular fa-star-exclamation"></i><strong>嵌套</strong>元素垂直外边距合并会引起塌陷问题：父元素会塌陷较大的外边距值</li></p>  </ul></li><li><p>圆角边框：border-radius</p><p>注意复合写法的时候顺序是top-left，top-right，bottom-right, bottom-left。</p></li><li><p>盒子阴影：box-shadow</p><p>box-shadow: h-shadow v-shadow blur spread color inset;</p><p>(注：盒子阴影并不占用空间，不会影响其他盒子的排列)</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>box-model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在md文档中引入icon</title>
    <link href="/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/"/>
    <url>/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/</url>
    
    <content type="html"><![CDATA[<h2 id="尝试如何在markdown文档中引入可爱的icon图标"><a href="#尝试如何在markdown文档中引入可爱的icon图标" class="headerlink" title="尝试如何在markdown文档中引入可爱的icon图标"></a>尝试如何在markdown文档中引入可爱的icon图标</h2><p>最近写自己的技术博客的时候，在一些地方很想插入一些可爱的图标，就想着用之前做项目的时候使用的Font Awesome图标库引入文档，由此插入其中的icon。下面是官方的地址：</p><p><i><a href="https://fontawesome.com/">https://fontawesome.com/</a></i></p><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><h5><i class="fa-solid fa-baby"></i>step1: 引入Font Awesome的js文件<img src="/img/Font-Awesome.png"/></h5><p>   （注：位置要放在head标签内）</li></p><h5><i class="fa-solid fa-person-rays"></i>step2: 在icon界面找到想要的图标，复制类名到自己的想加的地方</h5><p>   （注：拿i标签包裹一下）</li></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head><ul]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS层叠时的优先级问题</title>
    <link href="/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2>CSS层叠时的优先级问题</h2><p>今天在写样式的时候发现一个样式怎么也不显示，找了一圈发现是样式冲突了，css会优先执行优先级更高的样式。特意复习一下css中的优先级好啦~</p><h3>下面的选择器权重从小到大</h3><p>(ps: 也就是越往下越会优先执行）</p><ul>    <li>继承 或者通配符选择器*</li>    <li>元素选择器  e.g. p {}</li>    <li>类选择器，伪类选择器  e.g.  .para{}  .nav:hover{}</li>    <li>ID选择器  e.g.  #customid {}</li>    <li>行内样式 style=""</li>    <li>在属性值后面加!important</li></ul></ul><p><strong>在使用复合选择器的时候，要注意权重的叠加计算</strong></p>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css文字对齐</title>
    <link href="/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="css文字对齐包括水平对齐和垂直对齐"><a href="#css文字对齐包括水平对齐和垂直对齐" class="headerlink" title="css文字对齐包括水平对齐和垂直对齐"></a>css文字对齐包括水平对齐和垂直对齐</h2><ol><li><p>水平对齐  <strong>text-align</strong></p><p>text-align属性默认值是left，也就是靠左侧对齐文字，如果想水平方向居中显示，则需要对元素的样式设置text-align: center</p></li><li><p>垂直对齐  <strong>line-height &#x3D; height</strong></p><p>在css中没有相对应的属性可以设置文字垂直居中，但是一个小trick就是使这一行文字的line-height等于设置的盒子高度height。</p><p>解释：因为line-height行高除了内容本身的高度以外还有上间距和下间距，可以看下面的图配合食用~</p><p>配图说明：<img title="line-height组成" src="/img/lineheight.jpg"/></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2023/05/12/my-first-blog/"/>
    <url>/2023/05/12/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>##This is my first blog and try it here!!</p>]]></content>
    
    
    
    <tags>
      
      <tag>try</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
