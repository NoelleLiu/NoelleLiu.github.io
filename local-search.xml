<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端工程化与webpack</title>
    <link href="/2023/06/23/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/"/>
    <url>/2023/06/23/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/</url>
    
    <content type="html"><![CDATA[<h2>前端工程化与webpack</h2><h3>1. 前端工程化</h3><p>实际上的前端开发：</p><ul><li>模块化（js模块化，css模块化，资源模块化）</li><li>组件化（复用现有的UI结构、样式、行为）</li><li>规范化（编码规范、接口规范、文档规范、Git分支管理）</li><li>自动化（自动化构建、自动部署、自动化测试）</li></ul><h4>1.1 前端工程化是什么？</h4><p>前端工程化：在企业及的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化和标准化。</p><p><i class="fa-solid fa-arrow-down"></i></p><p>早期的前端工程化解决方案：gulp、grunt等</p><p><span class="red">目前主流的</span>前端工程化解决方案：<span class="red">webpack</span>、parcel</p><h3>2. webpack的基本使用</h3><h4>2.1 webpack是什么？</h4><p>webpack: 是前端工程化的具体解决方案。</p><p><strong>主要功能</strong>：提供了友好的前端模块化开发支持，以及<u>代码压缩混淆，处理浏览器端JavaScript的兼容性，性能优化</u>等强大的功能。</p><p><strong>好处</strong>：让技术人员将工作重心放在具体功能的实现上，提高了前端开发的效率和项目的可维护性</p><h4>2.2 webpack安装</h4><p>当我们在项目中想用ES6语法引入jQuery会报语法错误，有兼容性问题，想用webpack解决</p><ul><li><p>在项目中安装webpack： npm install webpack webpack-cli -D</p><p><strong>dependencies节点</strong>：开发+上线  -S   –save</p><p><strong>devDependencies节点</strong>:  仅开发阶段  -D    –save-dev</p></li></ul><h4>2.3 webpack配置</h4><ul><li><p>在项目根目录下创建<span class="red">webpack.config.js</span>的webpack配置文件，并初始化</p><p>module.exports &#x3D; {</p><p>​mode: ‘development’</p><p>}</p><hr><p>*mode的可选值</p><p><img src="/img/mode.jpg" alt="mode"></p><hr></li><li><p>在<span class="red">package.json</span>的<span class="red">scripts</span>节点下新增dev脚本</p><p>“scripts”: {</p><p>​“dev”: “webpack”</p><p>}</p><p>scripts节点下的脚本可以通过npm run执行， 比如这里定义dev脚本，就是npm run dev</p></li><li><p>在终端运行我们定义好的脚本命令：npm run dev，启动webpack对项目进行打包构建</p></li><li><p>最后将打包构建好的main文件导入，删掉有兼容性问题的文件</p></li></ul><h4>2.4 webpack默认约定</h4><p>在webpack4.x和5.x的版本中，有以下的<strong>默认约定</strong>：</p><ul><li>默认的打包入口文件为：<span class="red">src -&gt; index.js</span></li><li>默认的输出文件路径为：<span class="red">dist -&gt; main.js</span></li></ul><p>这个约定对名字很敏感，如果想要修改就需要通过webpack.config.js配置文件来修改</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>2.5 自定义打包的入口和出口</h4><p>在webpack.config.js中，通过<span class="red">entry</span>节点指定打包的<span class="red">入口</span>，通过<span class="red">output</span>节点指定打包的<span class="red">出口</span></p><p>entry: path.join(__dirname, ‘.&#x2F;src&#x2F;index.js’),</p><p>output: {</p><p>​path: path.join(__dirname, ‘.&#x2F;dist’),</p><p>​filename: ‘bundle.js’</p><p>}</p><p>那么，每次修改代码都需要重新运行npm run dev很麻烦</p><p><i class="fa-solid fa-arrow-down"></i></p><h3>3. webpack插件</h3><p>通过安装和配置第三方的插件，可以拓展webpack的能力，从而用起来更加的方便</p><h4>3.1 webpack-dev-server</h4><ul><li><p>安装：npm install <a href="mailto:&#x77;&#101;&#x62;&#x70;&#97;&#x63;&#107;&#45;&#100;&#101;&#x76;&#x2d;&#x73;&#x65;&#114;&#118;&#101;&#x72;&#x40;&#51;&#x2e;&#49;&#x31;&#46;&#x32;">&#x77;&#101;&#x62;&#x70;&#97;&#x63;&#107;&#45;&#100;&#101;&#x76;&#x2d;&#x73;&#x65;&#114;&#118;&#101;&#x72;&#x40;&#51;&#x2e;&#49;&#x31;&#46;&#x32;</a> -D</p></li><li><p>配置：将package.json -&gt; scripts中的dev命令修改</p><p>“dev”: “webpack serve”</p><p>再次运行npm run dev的命令</p><p>可以在localhost:8080查看自动打包效果</p></li></ul><p><i class="fa-solid fa-question"></i>问题：为什么页面并不会自动显示变化？</p><p><mark>答</mark>：webpack-dev-server并不能读取webpack.config.js中配置的output属性，<span class="red">默认</span>打包的文件名是<span class="red">bundle.js</span>,且不会出现在项目目录中。所以将index.html中引入js文件的路径直接换成’bundle.js’即可！</p><h4>3.2 html-webpack-plugin</h4><ul><li><p>安装：npm install <a href="mailto:&#x68;&#x74;&#109;&#x6c;&#45;&#119;&#x65;&#98;&#x70;&#97;&#99;&#x6b;&#x2d;&#112;&#108;&#117;&#103;&#x69;&#110;&#x40;&#53;&#x2e;&#51;&#x2e;&#x32;">&#x68;&#x74;&#109;&#x6c;&#45;&#119;&#x65;&#98;&#x70;&#97;&#99;&#x6b;&#x2d;&#112;&#108;&#117;&#103;&#x69;&#110;&#x40;&#53;&#x2e;&#51;&#x2e;&#x32;</a> -D</p></li><li><p>配置：在webpack.config.js中</p><p><img src="/img/html-webpack-plugin.jpg" alt="配置"></p></li></ul><h3>4. webpack中的loader</h3><p>引入：在实际开发中，webpack默认只能打包处理以.js后缀名结尾的模块。所以打包其他非js文件比如图片、css、字体等其他类型的资源文件均是基于<span class="red">Loader机制</span>来实现的。</p><h4>4.1 loader加载器的作用</h4><p><span class="red">协助webpack打包处理特定的文件模块</span>，如：</p><ul><li>css-loader：打包处理.css相关的文件</li><li>less-loader:   打包处理.less相关的文件</li><li>babel-loader:   打包处理webpack无法处理的高级js语法</li></ul><h4>4.2 loader的调用过程</h4><p><img src="/img/loader%E8%B0%83%E7%94%A8.png" alt="loader"></p><h4>4.3 打包处理css文件</h4><p>webpack允许用户为某些资源文件配置多个不同的loader，在处理 .css文件的时候，用到了style-loader和css-loader</p><ul><li><p>安装： npm i <a href="mailto:&#115;&#116;&#x79;&#x6c;&#101;&#x2d;&#108;&#111;&#97;&#100;&#x65;&#114;&#x40;&#x33;&#x2e;&#48;&#x2e;&#x30;">&#115;&#116;&#x79;&#x6c;&#101;&#x2d;&#108;&#111;&#97;&#100;&#x65;&#114;&#x40;&#x33;&#x2e;&#48;&#x2e;&#x30;</a> <a href="mailto:&#99;&#115;&#x73;&#x2d;&#x6c;&#111;&#x61;&#100;&#x65;&#114;&#x40;&#x35;&#46;&#50;&#x2e;&#x36;">&#99;&#115;&#x73;&#x2d;&#x6c;&#111;&#x61;&#100;&#x65;&#114;&#x40;&#x35;&#46;&#50;&#x2e;&#x36;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .css$&#x2F;, use: [‘style-loader’, ‘css-loader’]}&#x2F;&#x2F;注意顺序是固定的！</p><p>]</p><p>其中test是要匹配的文件类型，use是要对应调用的loader</p><p><span class="red">多个loader的调用顺序是：从后往前调用</span></p><p>过程：webpack先将.css后缀的文件交给use的最后一个loader(css-loader)处理完毕后，交给倒数第二个loader(style-loader)处理后，发现没有别的loader了就交给webpack,最终合并到main.js中。</p></li></ul><h4>4.3 打包处理less文件</h4><ul><li><p>安装： npm i <a href="mailto:&#x6c;&#101;&#x73;&#115;&#45;&#x6c;&#x6f;&#x61;&#x64;&#x65;&#114;&#x40;&#x31;&#x30;&#46;&#48;&#46;&#49;">&#x6c;&#101;&#x73;&#115;&#45;&#x6c;&#x6f;&#x61;&#x64;&#x65;&#114;&#x40;&#x31;&#x30;&#46;&#48;&#46;&#49;</a> <a href="mailto:&#x6c;&#101;&#x73;&#115;&#64;&#x34;&#46;&#x31;&#x2e;&#49;">&#x6c;&#101;&#x73;&#115;&#64;&#x34;&#46;&#x31;&#x2e;&#49;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .less$&#x2F;, use: [‘style-loader’, ‘css-loader’, ‘less-loader’]}</p><p>]</p></li></ul><h4>4.4 打包处理样式表中与url路径相关的文件</h4><ul><li><p>安装： npm i <a href="mailto:&#117;&#114;&#x6c;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#52;&#x2e;&#49;&#46;&#x31;">&#117;&#114;&#x6c;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#52;&#x2e;&#49;&#46;&#x31;</a> <a href="mailto:&#102;&#x69;&#x6c;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#64;&#54;&#46;&#50;&#46;&#48;">&#102;&#x69;&#x6c;&#x65;&#x2d;&#108;&#x6f;&#x61;&#x64;&#101;&#x72;&#64;&#54;&#46;&#50;&#46;&#48;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .jpg|png|gif$&#x2F;, use: ‘url-loader?limit&#x3D;22229’}</p><p>]</p><p>?后面是loader的参数，limit指定图片的大小，也就是说只有&lt;&#x3D;limit大小的图片才会被转为<a href="https://blog.csdn.net/sunyctf/article/details/125527656">base64格式</a>的图片。</p></li></ul><h4>4.5 打包处理js文件中的高级语法</h4><p>webpack只能打包处理一部分高级的js语法，对于webpack不能处理的，需要借助babel-loader进行打包处理。</p><ul><li><p>安装： npm i <a href="mailto:&#98;&#x61;&#x62;&#101;&#x6c;&#45;&#108;&#111;&#97;&#x64;&#101;&#114;&#x40;&#x38;&#46;&#50;&#46;&#x32;">&#98;&#x61;&#x62;&#101;&#x6c;&#45;&#108;&#111;&#97;&#x64;&#101;&#114;&#x40;&#x38;&#46;&#50;&#46;&#x32;</a> @babel&#x2F;<a href="mailto:&#99;&#111;&#114;&#x65;&#x40;&#x37;&#x2e;&#49;&#52;&#46;&#54;">&#99;&#111;&#114;&#x65;&#x40;&#x37;&#x2e;&#49;&#52;&#46;&#54;</a> @babel&#x2F;<a href="mailto:&#112;&#108;&#x75;&#x67;&#105;&#110;&#45;&#x70;&#114;&#x6f;&#112;&#111;&#115;&#x61;&#108;&#x2d;&#100;&#101;&#99;&#x6f;&#x72;&#x61;&#116;&#x6f;&#x72;&#x73;&#x40;&#55;&#46;&#49;&#52;&#46;&#53;">&#112;&#108;&#x75;&#x67;&#105;&#110;&#45;&#x70;&#114;&#x6f;&#112;&#111;&#115;&#x61;&#108;&#x2d;&#100;&#101;&#99;&#x6f;&#x72;&#x61;&#116;&#x6f;&#x72;&#x73;&#x40;&#55;&#46;&#49;&#52;&#46;&#53;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .js$&#x2F;, use: ‘babel-loader’, exclude: &#x2F;node_modules&#x2F;}&#x2F;&#x2F;node_modules目录下的第三方包不需要被打包</p><p>]</p></li><li><p>配置：在项目根目录下创建 babel.config.js 并配置</p><p>module.exports &#x3D; {</p><p> &#x2F;&#x2F;声明babel可用插件</p><p> plugins: [[‘@babel&#x2F;plugin-proposal-decorator’, {legacy: true}]]</p><p>}</p></li></ul><h3>5. 打包发布</h3><h4>5.1 为什么要用webpack进行打包发布？</h4><p>项目开发完成之后，需要使用webpack打包发布的原因有如下两条：</p><ul><li>开发环境下，打包生成的文件<span class="red">存放在内存中</span>，无法获取到最终打包生成的文件</li><li>开发环境下，打包生成的文件不会进行代码的压缩和性能的优化。</li></ul><h4>5.2 webpack打包发布的配置</h4><p>在package.json文件中的Scripts节点下，新建build命令：</p><p>“build”: “webpack –mode production”</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/06/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/06/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2>正则表达式</h2><h4>1. 正则表达式概述</h4><p>正则表达式 regular expression：是于匹配字符串中字符组合的模式，js中，正则表达式也是对象。</p><p>正则表达式通常被用来<span class="red">检索、替换</span>那些符合某个模式（规则）的文本。</p><h4>2. 创建正则表达式</h4><ul><li>通过RegExp构造函数创建： var regexp &#x3D; new RegExp(&#x2F;表达式&#x2F;)</li><li>通过字面量创建：var regexp &#x3D; &#x2F;表达式&#x2F;</li></ul><p>那么如何检测输入的字符串是否符合正则表达式的要求呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>3. 测试正则表达式</h4><p>regexObj.test(str):检测str文本是否符合我们写的正则表达式regexObj的规范，返回true或者false</p><h4>4. 正则表达式中的元字符</h4><p>一个正则表达式可以由<span class="red">简单字符</span>构成，如&#x2F;123&#x2F;，也可以由<span class="red">特殊字符</span>组成，且在正则表达式中有特殊的意义。</p><h5>4.1 边界符（位置符）</h5><p>边界符用来提示字符所处位置</p><ul><li>^ 表示匹配以<span class="red">首</span>的文本（以谁开始）</li><li>$ 表示匹配以<span class="red">尾</span>的文本（以谁结束）</li></ul><hr><p><img src="/img/regExp%E8%BE%B9%E7%95%8C%E7%AC%A6.png" alt="边界符"></p><hr><h5>4.2 字符类</h5><ul><li>[]：方括号内放所有可供选择的字符，只要匹配其中一个就行</li><li>[-]：-表示范围，比如a-z之间的任意一个字母可以写成 &#x2F;[a-z]&#x2F;, 常用字符组合：&#x2F;a-zA-Z0-9_-&#x2F;</li><li>[^] : 方括号内的^表示取反</li></ul><h5>4.3 量词符</h5><p><img src="/img/regExp%E9%87%8F%E8%AF%8D%E7%AC%A6.jpg" alt="量词符"></p><h5>4.4 预定义类</h5><p><img src="/img/regExp%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB.jpg" alt="预定义类"></p><h4>5. 正则表达式中的替换</h4><ul><li><p>stringObject.replace(regexp&#x2F;substr, replacement): 将替换的子字符串或者正则表达式替换为新的并且返回替换完毕的字符串。</p><p>经常使用正则表达式的形式替换为‘**’，避免敏感词，但是str.replace(&#x2F;激情&#x2F;，”  x “ )只能替换掉<strong>第一个</strong>出现的敏感词</p><p><i class="fa-solid fa-arrow-down"></i></p></li><li><p>正则表达式参数  &#x2F;表达式&#x2F;[switch]</p><p>switch有三个值：  <span class="red">g</span>全局匹配    <span class="red">i</span>忽略大小写   <span class="red">gi</span>全局匹配+忽略大小写</p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js函数进阶</title>
    <link href="/2023/06/22/js%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/06/22/js%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2>js函数进阶</h2><h3>1. 函数的定义和调用</h3><h4>1.1 函数的定义方式</h4><ul><li><p>自定义函数（命名函数）</p><p>function functionName(params) {codexxx}</p></li><li><p>函数表达式（匿名函数）</p><p>var fun &#x3D; function(params) {codexxx}</p></li><li><p>new Function()</p><p>var func &#x3D; new Function(‘param1’, ‘param2’,…,’function’)</p></li></ul><hr><h4>1.2 函数的调用方式</h4><p>总结三种函数定义方式及其调用in js：</p><p><img src="/img/advanced-def.png" alt="code"></p><hr><h3>2. this</h3><h4>2.1 函数内的this</h4><p>函数内的this指向：调用时才能确定，一般指向调用者</p><p><img src="/img/this1.jpg" alt="this"></p><h4>2.2 改变函数内的this指向</h4><ul><li>fn.call(context，arg1，arg2，…): 可以调用函数，又可以改变this指向，主要可以实现继承。</li><li>fn.apply(context，[arg1，arg2,…]): 也是可以调用函数，又可以改变this指向，主要区别是函数需要将参数作为数组传递</li><li>fn.bind(context，arg1，arg2，…): <span class="red">不会调用函数，返回改变this指向后的新函数</span></li></ul><hr><p><img src="/img/advanced-this.png" alt="this"></p><hr><h3>3. 严格模式 strict mode</h3><p>ES5的严格模式是采用具有限制性JavaScript变体的一种方式，相对正常的js语义做了一些更改，为未来新版本的js做铺垫。</p><p>严格模式的开启可以分为 <u>为整个脚本开启严格模式</u>和<u>为个别函数开启严格模式</u></p><p>在所有语句（为整个脚本）或者在函数体（为个别函数）之前放特定语句<span class="red">“use strict”;</span></p><h4>3.1 严格模式下的变化</h4><ul><li><strong>变量规定</strong>： 变量必须先声明再使用，不允许删除已经声明的变量</li><li><strong>this指向</strong>：正常的js中全局作用域函数的this指向window对象，严格模式下，全局作用域的函数this指向undefined</li><li><strong>函数变化</strong>: 函数不能有重名的参数</li></ul><h3>4. 高阶函数</h3><p>高阶函数：对其他函数进行操作的函数（接收函数作为参数 或者 将函数作为返回值）</p><h4>4.1 函数作为参数的情况</h4><ul><li>arr.map(callback(currentValue, index, array)): 生成一个新数组，不改变原始数组的值。其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</li><li>arr.reduce(callback(accumulator, currentValue, currentIndex,arr ),initialValue):对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。   -   经常用于数组求和</li><li>arr.sort(): 用原地算法对数组的元素进行排序，并返回数组</li></ul><p>reference： <a href="https://juejin.cn/post/6844903873983807502">【JS必知必会】高阶函数详解与实战 - 掘金 (juejin.cn)</a></p><h3><i class="fa-sharp fa-light fa-star-christmas"></i>5. 闭包</h3><h4>5.1 变量作用域</h4><p>变量根据作用域的不同分为：全局变量和局部变量。注意：</p><ul><li>函数外<strong>可以</strong>使用全局变量</li><li>函数内<strong>不可以</strong>使用局部变量</li><li>当函数执行完毕，本作用域内的局部变量会销毁</li></ul><p>那么如何从外部读取局部变量呢？ </p><h4>5.2 闭包的定义</h4><p><span class="red">闭包</span>：是指有权访问另一个函数作用域中的变量的<strong><u>函数</u></strong>。(本质是个函数)</p><h4>5.3 闭包的作用</h4><p><span class="red">延伸变量的作用范围</span></p><p>reference：<a href="https://juejin.cn/post/7097141521102667813">深入理解JS闭包 - 掘金 (juejin.cn)</a></p><h3><i class="fa-sharp fa-light fa-star-christmas"></i>6. 深拷贝和浅拷贝</h3><ul><li><p>浅拷贝shallow copy：只复制指向某对象的指针，而不复制对象本身，新旧对象共享一块内存。且浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用（地址）</p><p>es6新增Object.assign(目标，原)可以实现浅拷贝</p></li><li><p>深拷贝deep copy：复制并创建一个一模一样的对象，不共享内存，修改新对象不对影响旧对象。每一层的数据都会进行拷贝。</p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6新增特性</title>
    <link href="/2023/06/21/es6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/"/>
    <url>/2023/06/21/es6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2>es6新增特性</h2><h3>1. let关键字</h3><p><i class="fa-regular fa-block-question"></i>那么let声明和var声明变量有什么<span class="red">异同</span>呢？</p><ul><li><p><strong>全局作用域下</strong>: 两者在全局作用域下作用相似，但是，let声明的变量不会作为全局对象window的属性，而var声明的变量却可以</p><p>var numvar &#x3D; 10;</p><p>let numlet &#x3D; 100;</p><p>console.log(window.numvar);&#x2F;&#x2F;10</p><p>console.log(window.numlet);&#x2F;&#x2F;undefined</p></li><li><p><strong>块作用域下</strong>：let声明的变量只在所处的块级（{}之间）有效。</p></li><li><p><strong>变量提升</strong>： let声明的变量不存在变量提升，故必须先声明再使用</p></li><li><p><strong>变量重名</strong>:  var允许再同一作用域声明同名的变量，只不过就是会把值覆盖而已；let则不允许在同一作用域声明同名的变量。</p></li><li><p><strong>暂时性死区</strong>： let声明的变量存在暂时性死区</p><p>var num &#x3D; 10;</p><p>if(true) {</p><p>​console.log(num);&#x2F;&#x2F; 这里程序会把num和块级绑定，认为在打印let声明的num</p><p>​let num;</p><p>}</p></li></ul><h3>2. const关键字</h3><p>const关键字声明变量的特点如下：</p><ul><li>具有块级作用域</li><li>声明的同时必须赋值</li><li>常量赋值后是不能修改的</li></ul><hr><p><span class="red">sum</span>: let, var, const的区别</p><p><img src="/img/var-let-const.jpg" alt="let, var, const"></p><hr><h3>3. 解构赋值</h3><p>解构-赋值：按照一定的模式，从<span class="red">数组</span>或者<span class="red">对象</span>中提取值并赋值给另外的变量。</p><h4>3.1 数组解构</h4><p>允许按照<span class="red">一一对应</span>的关系从数组中提取值并赋值给变量</p><p>如果变量数量 &gt; 数组元素数量，则后面的变量则为undefined</p><p>如果变量数量 &lt; 数组元素数量,  则按照数组的前n个分别赋值</p><h4>3.2 对象解构</h4><ul><li><p>方法一： 按照属性名一一对应赋值</p><p>let {attr1, attr2} &#x3D; {</p><p>​attr1: xxx,</p><p>​attr2: xxx}</p><p>但是这个解构赋值的方法<u>变量名必须和对象里的属性名一致</u></p></li><li><p>方法二： 自定义变量名</p><p>let {attr1: name1, attr2: name2} &#x3D; {</p><p>​attr1: xxx,</p><p>​attr2: xxx}</p><p>冒号前做属性匹配，冒号后才是真正的变量名</p></li></ul><h3>4. 箭头函数</h3><p>通常需要将箭头函数赋值给某个变量，方便调用。</p><p>var fn &#x3D; （arg1, …) &#x3D;&gt; {xxxx}</p><p>箭头函数的特点：</p><ul><li>如果函数体只有一句代码，且代码的执行结果就是返回值，则可以直接省略大括号</li><li>如果形参只有一个，则可以省略小括号</li><li>箭头函数不绑定this， 箭头函数中的this是函数定义位置的上下文this</li></ul><h3>5. 剩余参数...args</h3><p>剩余参数允许将不定数量的参数表示为一个<span class="red">数组</span></p><h3>6. ES6内置对象扩展</h3><h4>6.1 Array扩展方法</h3><ul><li><p>扩展运算符…：将数组或者对象拆分成用逗号分隔的参数序列</p><p>let arr &#x3D; [1,2,3]</p><p>…arr  &#x2F;&#x2F; 1, 2, 3</p><p><span class="red">应用</span>：拓展运算符可以很好的帮助我们<span class="red">合并数组</span>，<span class="red">将伪数组或者可遍历对象转换成真正的数组</span></p></li><li><p>构造函数法Array.from(): 可以将伪数组或者可遍历对象转换成真正的数组</p></li><li><p>find()：用于找出第一个符合条件的数组成员，找不到返回undefined</p></li><li><p>findIndex(): 找出第一个符合条件的数组成员的位置，找不到返回-1</p></li><li><p>includes() : 判断数组是否包含给定的值，返回布尔值</p></li></ul><h4>6.2 String扩展方法</h3><ul><li><i class="fa-regular fa-star-exclamation"></i>模板字符串&#96;&#96;: 和普通的字符串比，<span class="red">可以解析变量，可以换行，可以调用函数！！！！</span>注意解析变量和调用函数需要用 ${}包裹</li><li>str.startsWith(subStr) 和 str.endsWith(subStr) 判断str字符串是否以subStr开头或者结尾，返回true或者false</li><li>str.repeat(): 将字符串重复n次，返回新的字符串</li></ul><h4>6.3 Set数据结构</h3><p>Set数据结构是es6中提出的，类似于数组，但是与数组不同的是，Set中的成员都是<span class="red"><strong>唯一的</strong></span>。</p><p>const s &#x3D; new Set([1,2,3,3]); &#x2F;&#x2F; s &#x3D; [1,2,3]</p><p><span class="red">应用</span>：</p><ul><li><p>搭配扩展运算符进行数组去重</p><p>var arr &#x3D; [1,3,3,3,3,5]</p><p>var set &#x3D; new Set(arr);  &#x2F;&#x2F;去重</p><p>var arrNew &#x3D; […set]; &#x2F;&#x2F;用扩展运算符包装成新的数组</p></li></ul><ol><li><p>set实例的方法</p><p>a. add(value): 添加某个值，返回set结构本身</p><p>b. delete(value)：删除某个值，返回布尔值，表示删除成功与否</p><p>c. has(value): 返回布尔值，判断是否有这个成员</p><p>d. clear():清除所有成员</p></li></ol><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es5新增方法</title>
    <link href="/2023/06/21/es5%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"/>
    <url>/2023/06/21/es5%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2>es5新增方法</h2><h3>1. 数组</h3><p>注意以下回调函数callback均只有currentVal是必须的参数</p><ul><li><p>forEach(): 遍历数组</p><p>array.forEach(callbackFn(currentVal, index,arr) )</p></li><li><p>filter()：筛选数组并返回新数组</p><p>array.filter(callbackFn(currentVal, index,arr))</p></li><li><p>some(): 查找数组中是否有满足条件的元素，返回布尔值</p><p>array.some(callbackFn(currentVal, index,arr))</p></li></ul><h3>2. 字符串</h3><ul><li><p>trim(): 删除字符串两端的空白字符，返回新的字符串</p><p><i class="fa-sharp fa-light fa-truck-fast"></i>可以用来防止输入空格</p></li></ul><h3>3. 对象方法</h3><ul><li><p>Object.keys(obj): 获取obj对象自身的所有属性</p></li><li><p>Object.defineProperty(obj, prop, descriptor): 定义对象中新属性或者修改原有属性</p><p><img src="/img/defineProperty.png" alt="code"></p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js面向对象</title>
    <link href="/2023/06/15/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/15/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>JavaScript面向对象</h2><h4>1.面向对象编程 </h4><p>两大编程思想：</p><ul><li><p>面向<span class="red">过程</span>编程(POP) - Process-oriented Programming</p><p>这种编程思想需要分析出解决问题所需的步骤，然后利用函数将每一步实现，在使用时依次调用。</p></li><li><p>面向<span class="red">对象</span>编程(OOP) - Object-oriented Programming</p><p>这种编程思想需要把事务分解成一个个对象，然后由对象之间分工与合作。</p><p>每一个对象都是功能中心且分工明确，OOP具有<span style="color: #22a2c3">灵活、代码可复用、容易维护和开发</span>的优点。</p></li></ul><h4>2.ES6中的类和对象 - ES6新增了类的概念 </h4><p>当用面向对象的思想描述现实事物的时候，事物可以分为具体事务和抽象事物。</p><p>面向对象的思维特点：</p><ul><li>抽取抽象对象的公共属性和方法封装成一个<span style="color: #22a2c3">类</span></li><li>对类进行实例化，得到一个具体的<span style="color: #22a2c3">对象</span></li></ul><h4>3.创建类和实例的方法</h4><p>class Name {}；&#x2F;&#x2F;创建类</p><p>var obj &#x3D;  <span class="red">new</span> Name();  &#x2F;&#x2F;创建实例</p><h4>4.类constructor构造函数</h4><p>constructor()构造函数(方法)是一种用于创建和初始化创建的对象的特殊方法，并没有返回值。在new命令生成实例对象的时候自动调用该方法，如果没有显示的定义，类的内部会自动创一个constructor(),用于传递参数，返回实例对象。</p><p>class Person {</p><p>   constructor(name, age) {</p><p>​      this.name &#x3D; name;</p><p>​  this.age &#x3D; age;}</p><p>}</p><p>当创建刘昕瑶实例 var lxy &#x3D; Person(‘刘昕瑶’，25)的时候，会自动调用并且给刘昕瑶实例添加name和age属性。</p><p><i class="fa-regular fa-face-thinking"></i>【思考】：所以类中的共有<span class="red">属性</span>可以添加到constructor构造函数中，那么<span class="red">方法</span>呢？</p><h4>5.类添加方法</h4><p>在类中，所有的方法不需要function关键字也不能加逗号分割</p><p>e.g.  还拿4中的Person类举例</p><p>class Person {</p><p>   constructor(name, age) {</p><p>​      this.name &#x3D; name;</p><p>​  this.age &#x3D; age;}</p><p>​say() {</p><p>​  console.log( ‘hi’ + this.name )}</p><p>}</p><h4>6.类的继承</h4><p><span class="red"><strong>继承</strong></span>：子类可以继承父类的一些属性和方法，通过<span class="red"><strong>extends</strong></span>关键字</p><p>class Father {}</p><p>class Son <span class="red">entends</span> Father {&#x2F;&#x2F;子类继承父类</p><p>}</p><p>【问题：如果父类里某个方法是sum(){this.x+this.y},子类在继承的时候也想使用sum方法，<strong>如何调用父类的构造函数呢？</strong>】</p><h5>6.1 super关键字</h5><p>super关键字用于访问和调用对象父类上的函数，且<span class="red">可以调用父类的构造函数</span>，也可以调用普通函数。</p><p>class Father {</p><p>​constructor(x,y) {</p><p>​  this.x &#x3D; x;</p><p>​  this.y &#x3D; y;}</p><p>​sum() {</p><p>​  console.log(this.x + this.y)}</p><p>}</p><p>class Son extends Father{</p><p>​constructor(x,y) {</p><p>​super(x,y);&#x2F;&#x2F;调用父类的构造函数</p><p>​}</p><p>}</p><p>var son &#x3D; new Son(1,2)</p><p>son.sum()</p><h4>7. 构造函数</h4><p>引入：在es6之前，js中并没有引入类的概念，所以在es6之前对象都是用<span class="red">构造函数</span>来定义对象和他们的特征</p><p>回忆：创建对象的三种方式：</p><ul><li><p>字面量： var obj1 &#x3D; {}</p></li><li><p>new关键字：var obj2 &#x3D; new Object()</p></li><li><p>自定义<u>构造函数</u>： function Star(uname, age) {</p><p>​this.name &#x3D; uname;</p><p>​this.age &#x3D; age;</p><p>​this.sing &#x3D; function() {</p><p>​console.log(‘llalalalala’)}}</p></li></ul><h5>7.1 构造函数</h5><p>构造函数是一种特殊的函数，没有返回值。主要用于初始化对象，他总与new一起使用。</p><p>我们可以把对象中一些公共的属性和方法抽象出来，封装到这个函数中。</p><h5>7.2 new关键字执行时操作</h5><p>new在执行时会：</p><ol><li>在内存中创建一个新的空对象</li><li>让this指向这个新的对象</li><li>执行构造函数里的代码，给这个对象添加属性和方法</li><li>返回这个新的对象（故不需要return）</li></ol><h5>7.3 成员</h5><p>在构造函数中的属性和方法我们称为成员，成员可以在构造函数本身上添加，也可可以在构造函数内部this上添加。</p><p>function Star(uname, age) {</p><p>​this.name &#x3D; uname;</p><p>​this.age &#x3D; age;}</p><p>Star.sex &#x3D; ‘女’;</p><ul><li><p>在构造函数本身上添加的成员称为<strong><span class="red">静态成员</span></strong>，只能由构造函数本身来访问</p><p>console.log(Star.sex)</p></li><li><p>在构造函数内部创建的成员称为<strong><span class="red">实例成员</span></strong>，只能由实例化的对象来访问</p><p>var lxy &#x3D; Star(‘Lxy’, 25);</p><p>console.log(lxy.name)</p></li></ul><p>【问题：浪费内存】</p><h4>8. 构造函数原型 prototype</h4><p>在2中构造函数存在一个问题，两个不同的对象中相同的function会占用两份内存空间，造成内存的浪费，如何将不同对象使用同一个函数？</p><h5>8.1 构造函数原型 prototype</h5><p><span class="red">原型</span>：构造函数通过原型分配的函数是所有对象共享的。js规定， 每一个构造函数都有一个prototype属性，指向另一个对象。这个对象所有的属性和方法都会被构造函数所拥有。</p><p>故，我们可以把不变的方法直接定义在prototype对象上，这样所有的对象实例可以共享这些方法。</p><p>【一般，<span class="red">公共属性</span>定义在<strong>构造函数</strong>里，<span class="red">公共方法</span>定义在<strong>原型对象</strong>中】</p><p>还是以上面的Star构造函数为例：</p><p>Star.<span class="red">prototype.sing</span> &#x3D; function() {</p><p>​console.log(‘lalalala’)}</p><p>var ldh &#x3D; Star(‘刘德华’， 18)；</p><p>var zxy &#x3D; Star(‘张学友’， 19)；</p><p>console.log(ldh.sing &#x3D;&#x3D;&#x3D; zxy.sing);&#x2F;&#x2F;true</p><h5>8.2 原型对象 __proto__</h5><p>对象都会有一个属性 __ proto __，指向构造函数的prototype原型对象。</p><p>之所以对象可以使用构造函数中的prototype原型对象的属性和方法，就是因为对象中__ proto __原型的存在。</p><p><img src="/img/proto.jpg" alt="prototype和__ proto __ 的关系"></p><p> 对象原型存在的意义就是为对象的查找机制提供一个方向，在实际开发中不可以使用这个属性，只用来在内部指向prototype原型对象。</p><h4>9. constructor构造函数</h4><p>对象原型__ proto __ 和构造函数原型对象prototype里都有一个属性：constructor构造函数，指回构造函数本身。</p><p>constructor主要用于记录该对象引用于哪个构造函数，并让原型对象指向原来的构造函数。</p><p>一般情况下，对象的方法都在构造函数的原型对象中设置。</p><p>但是如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象的constructor就不再指向当前的构造函数了。</p><p>此时，可以在修改后的原型对象中，添加一个constructor指向原来的构造函数。</p><p><img src="/img/constructor.jpg" alt="constructor"></p><hr><p>总结：<strong>构造函数</strong>Star、<strong>实例</strong>ldh、<strong>原型对象</strong>Star.prototype之间的关系</p><p><img src="/img/protoobj.jpg" alt="关系图"></p><h4>10. 原型链</h4><p>当访问一个对象的某个属性时，会现在这个对象本身属性上找，如果没找到就会通过__ proto __ 隐形属性找到它的构造函数的原型对象，如果还没有，就继续在构造函数的prototype(也是对象，也有__ proto __ ) 中的__ proto __里去找。这样一层层向上查找就会形成一个链式结构，称为<span class="red">原型链</span>。</p><p><img src="/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg" alt="原型链"></p><p>javascript的成员查找机制：<span class="red">按照原型链</span>，一直找到null</p><p>所以说__ proto __ 对象原型的意义就是在于为对象成员查找机制提供一个方向。</p><p>reference：<a href="https://juejin.cn/post/6984678359275929637">一文搞懂JS原型与原型链（超详细，建议收藏） - 掘金 (juejin.cn)</a></p><h4>11. 原型对象中的this指向问题</h4><ul><li>构造函数中的this指向实例对象。</li><li>原型对象里面放的是方法，方法里的this指向的是方法的调用者，也就是实例对象。</li></ul><h4>12. es6之前的继承</h4><p>es6之前并没有extends继承，但是我们可以通过构造函数+原型对象这种<span class="red">组合继承</span>的方式模拟实现继承</p><h5>12.1 call()：调用，修改函数运行时的this指向</h5><p><img src="/img/call.png" alt="call"></p><h5>12.2 借助构造函数继承父类<span class="red">属性</span></h5><p><span class="red">核心原理</span>：通过call()将父类的this指向子类的this从而实现继承。</p><p><img src="/img/%E7%BB%A7%E6%89%BF.jpg" alt="继承"></p><h5>12.3 借助原型对象继承父类<span class="red">方法</span></h5><p><span class="red">核心原理</span>：将子类的共享方法提取出来，让子类的prototype原型对象 &#x3D; new 父类(),将子类的constructor重新指向子类的构造函数。</p><p>reference：[(70条消息) 借用原型对象继承父类型方法_susu1198的博客-CSDN博客](</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECharts项目-可视化展板随想</title>
    <link href="/2023/06/08/ECharts%E9%A1%B9%E7%9B%AE-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E6%9D%BF%E9%9A%8F%E6%83%B3/"/>
    <url>/2023/06/08/ECharts%E9%A1%B9%E7%9B%AE-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E6%9D%BF%E9%9A%8F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h2>ECharts项目-可视化展板</h2><h4>1. 用到的技术栈</h4><ul><li>基于flexible.js + rem智能大屏适配</li><li>flex布局</li><li>less - 使用easy less插件直接将less转换为css引入</li><li>基于Echarts数据可视化展示</li><li>Echarts柱状图、饼状图</li><li>Echarts地图</li></ul><h4>2. 适配方案 - flexible.js + rem</h4><h5>2.1 flexible.js</h5><p>flexible.js是专门为了解决不同设备间显示适配方案的，根据可视区大小，默认除以10，也就是可视区的1&#x2F;10就是1rem的大小，设置为font-size，使得每个使用rem单位的元素都可以自动适应屏幕的大小。</p><p>因为我们的项目希望只在pc端进行显示，按照默认十份进行划分1rem有点大了，修改flexible.js改成24等分。</p><h5>2.2 px to rem插件</h5><p>为了省掉换算，使用插件px to rem，但是要将设置里的font-size改成我们的1920&#x2F;24&#x3D;80</p><h4>3. 布局</h4><h5>3.1 header部分</h5><p>里面用一个h1标题居中显示，一个时间模块靠右侧定位。</p><h5>3.2 主体部分</h5><p>给主体大盒子设置display：flex，提供flex布局，其中三个小盒子分别占比3：5：3。</p><p>准备一个公共的面板样式panel，设置公共的样式，其中上下两个角的样式按照伪元素before、after的border进行设计；下面两个角选择在panel里加个定位的盒子再继续使用这个新底部盒子的伪元素的border加两个角。每个panel里分为一个h2标题做图表的标题，一个chart图表部分。</p><p>中间的地球bg图片想要定位在水平垂直居中的位置：</p><p>position: absolute;</p><p>left: 50%;</p><p>top: 50%;</p><p>transform: translate(-50%, -50%);</p><p>在地球bg图片上覆盖一个可以做<u>不停旋转</u>动画的图片，利用index压住bg图片。</p><h4>4. 交互</h4><h5>4.1 header部分</h5><p>header中的时间模块的innerHTML显示为当前的时间代码：</p><p>var t &#x3D; null;</p><p>   t &#x3D; setTimeout(time, 1000);&#x2F;&#x2F;定时器：每1000ms执行time函数</p><p>   function time() {</p><p>​    clearTimeout(t);</p><p>​    dt &#x3D; new Date();</p><p>​    var y &#x3D; dt.getFullYear();</p><p>​    var m &#x3D; dt.getMonth() + 1;</p><p>​    var d &#x3D; dt.getDate();</p><p>​    var h &#x3D; dt.getHours();</p><p>​    var min &#x3D; dt.getMinutes();</p><p>​    var s &#x3D; dt.getSeconds();</p><p>​    document.querySelector(“.showTime”).innerHTML &#x3D; “当前时间：” + y + “年” + m + “月” + d + “日-“ + h + “时” + min + “分” + s + “秒”;</p><p>​    t &#x3D; setTimeout(time, 1000);</p><p>   }</p><h5>4.2 主体部分</h5><p>因为在主体部分我们已经准备好了很多图表的容器，但是在ECharts的使用过程中需要获取并且给每一个图表做不一样的配置，为了避免这样带来的变量污染，减少命名冲突，采取<span class="red">立即执行函数</span>的写法，这样里面的变量均为<span class="red">局部变量</span>。</p><h4>5. 字体样式</h4><p>在中间column的数字展示模块，引用图标字体electonicFont美化数字展示方式。</p><p>首先，要在css或者less最上面声明字体@font-face！然后就可以在li中使用了，将font-family属性值设置为‘electonicFont’。</p><h4>6. ECharts使用步骤总结</h4><ul><li><p>下载并引用echarts.js</p></li><li><p>为需要用Echarts的图表准备一个定义宽高的DOM容器</p></li><li><p>通过echarts.init方法初始化一个echarts实例</p></li><li><p>通过setOption方法指定配置项和相关数据使其生效</p><p>其中<u>配置项和数据</u>是使用的重难点。</p></li></ul><h4>7. ECharts配置</h4><ul><li><p>tooltip: 提示框</p></li><li><p>legend：图例。若series中有name值，则legend的data可以省略。</p></li><li><p>grid：网格</p><p>【注意：DOM容器时整个图表的大小，而grid是只有最中间的大小】</p><p><img src="/img/echartsGrid.png" alt="DOM v.s. grid"></p></li><li><p>series：系列图表，决定显示哪种类型的图表。这是<strong>数组</strong>的形式，里面包含了n个对象，每一个对象对应一条线。</p></li><li><p>color: 设置线条的颜色，注意也是数组的形式和series对应。</p></li></ul><h4>8. ECharts随着屏幕的自适应</h4><p>  window.addEventListener(“resize”, function() {<br>    myChart.resize();<br>  });</p><hr><p>最后做出来的效果belike！！！</p><p><img src="/img/EchartsProjFinal.png" alt="final version"></p><hr><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>projects</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery项目-todolist随想</title>
    <link href="/2023/06/06/jQuery%E9%A1%B9%E7%9B%AE-todolist%E9%9A%8F%E6%83%B3/"/>
    <url>/2023/06/06/jQuery%E9%A1%B9%E7%9B%AE-todolist%E9%9A%8F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h2>JQuery项目-todolist</h2><h4>1. 布局</h4><p>body里主要分三个部分：header头部，footer底部和中间部分我用section包裹。</p><h5>1.1 header结构</h5><p>我希望可以将ToDoList和后面的输入框<strong><u>绑定</u></strong>， 所以选择使用label包围ToDoList， 这样就可以点击文字的时候同时选中输入框。</p><p>对于输入框input，需要注意id要和label的for的值一样才能绑定；对于想要默认展示的文字，需要使用placeholder属性；将autocomplete设置为”off”避免自动记录之前的历史；required&#x3D; “required”设置不能提交空表单。</p><h5>1.2 footer结构</h5><p>文字就可以，但是注意版权符号需要转义使用&amp;copy;</p><h5>1.3 主体结构</h5><p>再分成两部分：正在进行和已经完成。</p><p>这里选择也用section包围，因为这样的话就可以达到和header内容的版心对齐效果。</p><p>其中每部分的结构都是一样的，h2标题和数量在一行，下一行是list。</p><hr><p>最后，刚写完html的初版网页belike：</p><p><img src="/img/jq-1.png" alt="v1"></p><hr><h4>2. 样式</h4><h5>2.1 整体样式</h5><p>去除body默认的padding和margin，将背景颜色改为#CDCDCD</p><p>去除ol和ul默认的list-style和padding</p><h5>2.2 header样式</h5><p>固定高度，要不然由内容撑起来显得太窄了；将版心固定宽度然后居中对齐。</p><p>label的文字ToDoList垂直居中，需要设置line-height的大小和height一样大，并且左浮动。</p><p>input输入框使用border-radius设为圆角, 里面默认的字离左边框太近了，使用text-indent让文字往后缩进；当选定input输入框时，将outline-width设为0去掉；向右浮动。</p><h5>2.3 footer样式</h5><p>文字水平居中使用text-align：center；</p><h5>2.4 主体样式</h5><p>因为我的html结构里，把count写在h2里面了，所以给h2一个相对定位，count一个绝对定位来摆放他们的位置；我的count在结构里是用span包裹的，因为span是行内元素，想要改变大小，还需要将display设置为inline-block；</p><h5>2.5 响应式布局</h5><p>为了页面可以随着屏幕尺寸做自适应的拉伸，将版心section设定的固定的宽度注销掉，在媒体查询里定义。</p><hr><p>加上了css的v2版网页belike：</p><p><img src="/img/jq-2.png" alt="v2"></p><hr><h4>3. 交互</h4><p>因为我们希望可以达到刷新或者关掉页面也不会丢失数据的效果，需要用到本地存储localStorage</p><h5>3.1 todo1: 按下回车将完整的数据存储到本地存储里</h5><p>首先先给输入框绑定一个keydown的事件。在处理函数中要先通过事件对象e.keyCode判断按键是否为回车键，若是再判断是否为空，若空则alert提示。</p><p>若非空则先读取本地存储原来的数据，再将新数据合并再更新存储到本地存储。最后渲染到页面上再将输入框的值置空。</p><p>其中，读取数据的操作比较频繁就封装个函数，由于本地存储的数据都是<u>字符串格式</u>，需要<span class="red">JSON.parse()</span>转换为<u>javascipt对象</u>。同理，将数据存储到成本地存储也封装成函数，需要将javascipt对象data使用JSON.stringify(data)转换为本地存储的字符串格式。</p><p>将本地存储的所有数据渲染到页面上的功能也封装成函数。调用读取数据的方法，对data进行遍历，遍历的时候通过判断值的done属性值来判断是添加到哪个list。添加的方法选择使用prepend在内部的前面添加，添加的内容就是li标签。</p><h5>3.2 todo2: 删除操作</h5><p>并集选择ol和ul两个list中的a，如果点击就将data进行splice然后再存再渲染。</p><h5>3.3 todo3: 选项操作</h5><p>并集选择ol和ul两个list中的input，如果点击就将对应的数据的done属性进行修改，然后再存再渲染。</p><p>这里需要注意的是要通过$(this)的siblings找到a再找到id属性值。</p><hr><p>加上了js的v3版网页belike：</p><p><img src="/img/jq-3.png" alt="v3"></p><hr><h4>4. 再休整一下样式</h4><h5>4.1动态添加的li</h5><p>给两个list不同颜色左边框，圆角一点，左右padding把内容挤到中间一点；</p><p>给li加相对定位，这样给里面包含的input和a绝对定位就可以固定位置了；</p><hr><p>最后的final version!!!</p><p><img src="/img/jq-4.png" alt="v4"></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>projects</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery四-事件</title>
    <link href="/2023/06/06/JQuery%E5%9B%9B-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2023/06/06/JQuery%E5%9B%9B-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2>JQuery事件</h2><h4>1. 事件注册</h4><p>element.事件(function() {xxx})</p><p>e.g.  $(‘div’).click(function() {xxx})</p><h4>2. 事件处理on()绑定事件</h4><p>事件处理on()方法在匹配元素上绑定一个或多个事件的事件处理函数</p><p>element.on(events, [selector], fn)</p><p><img src="/img/jq-on.png" alt="on方法"></p><hr><p>[on()的优势]：</p><ul><li>可以绑定多个事件，多个处理事件的处理程序；如果处理事件的处理程序相同，可以在events使用并集的写法</li><li>可以<span class="red">事件委派</span>操作，把原来加给子元素身上的事件绑定在父元素身上。</li><li>可以给动态创建的元素绑定事件。</li></ul><h4>3. 事件处理off()解绑事件</h4><p>$(“p”).off() &#x2F;&#x2F;解绑p元素所有的事件处理程序</p><p>$(“p”).off(“click”)  &#x2F;&#x2F;解绑p元素的点击事件</p><p>$(“p”).off(“click”, “li”)&#x2F;&#x2F;解绑事件委托</p><h4>4. jQuery事件对象</h4><p>element.on(envents, [selectors], function(<span class="red">event</span>) {xxx})</p><p>阻止默认行为： event.preventDefault()</p><p>阻止冒泡：event.stopPropagation()</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery三-动画</title>
    <link href="/2023/06/06/JQuery%E4%B8%89-%E5%8A%A8%E7%94%BB/"/>
    <url>/2023/06/06/JQuery%E4%B8%89-%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h2>JQuery动画效果</h2><p>JQuery中封装了很多动画效果，如显示隐藏、滑动、淡入淡出、自定义动画等。</p><h4>1. 显示隐藏</h4><p>一般用的时候都很少带参数，直接显示或者隐藏即可。</p><ul><li><p>show([speed, [easing], [fn]])</p></li><li><p>hide([speed, [easing], [fn]])</p></li><li><p>toggle([speed, [easing], [fn]])</p></li></ul><h4>2. 滑动效果</h4><ul><li>下滑slideDown([speed, [easing], [fn]])</li><li>上滑slideUp([speed, [easing], [fn]])</li><li>滑动切换slideToggle([speed, [easing], [fn]])</li></ul><h4>3. 事件切换</h4><p>hover([over,]out)</p><p>over: 鼠标移动到元素上触发的函数</p><p>out：鼠标移出元素要触发的函数</p><p>但是多次触发会造成动画或者效果排队执行，引入<span class="red">停止排队stop</span></p><p>stop(): 停止动画或者效果</p><h4>4. 淡入淡出效果</h4><ul><li>fadeIn([speed, [easing], [fn]])</li><li>fadeOut([speed, [easing], [fn]])</li><li>fadeToggle([speed, [easing], [fn]])</li><li>fadeTo([[speed],opacity, [easing], [fn]])修改透明度</li></ul><h4>5. 自定义动画animate</h4><p>animate(params, [speed], [easing], [fn])</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery二-常用API</title>
    <link href="/2023/06/06/JQuery%E4%BA%8C-%E5%B8%B8%E7%94%A8API/"/>
    <url>/2023/06/06/JQuery%E4%BA%8C-%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h2>jQuery常用API</h2><h4>1. jQuery选择器</h4><ul><li><p>ID选择器   $(“id”)</p></li><li><p>全选选择器   $(“*”)</p></li><li><p>类选择器    $(“.class”)</p></li><li><p>标签选择器   $(“div”)</p></li><li><p>并集选择器    $(“div,p,li”)</p></li><li><p>交集选择器    $(“li.current”)</p></li><li><p>子代选择器  $(“ul&gt;li”)</p></li><li><p>后代选择器   $(“ul li”)</p></li></ul><h4><i class="fa-sharp fa-solid fa-marker"></i><span class="red">2.隐式迭代</span></h4><p>遍历内部DOM元素（伪数组形式存储）的过程称为<span class="red">隐式迭代</span></p><h4>3. jQuery筛选方法（函数）</h4><ul><li>parent()    最近的父级</li><li>children(selector)   </li><li>find(selector)   后代选择器</li><li>siblings()   查找兄弟节点</li><li>eq(n)   下标为n的</li></ul><h4>4. 排他思想</h4><p>想要多选一的效果，思想：当前元素设置样式，其他兄弟元素清除样式。</p><p>e.g.    $(this).css(‘color’, ‘red’);</p><p>​  $(this).siblings().css(‘color’, ‘’);</p><h4>5. 链式编程</h4><p><i class="fa-sharp fa-solid fa-thumbs-up"></i>尊滴优雅啊！！！</p><p>e.g.     $(this).css(‘color’,’red’).siblings().css(‘color’, ‘’);</p><h4>6. jQuery样式操作</h4><p>当需要操作的<span class="red">样式少</span>的情况下，可以使用<span>css方法</span></p><p>当需要操作的样式多的情况下，可以操作类修改多个样式</p><h5>6.1 操作css方法</h5><ul><li>$(this).css(‘color’);   参数只写属性名，则返回属性值</li><li>$(this).css(‘color’, ‘red’);   设置属性</li><li>$(this).css({‘color’: ‘red’, ‘font-size’: ‘20px’})； 参数为对象形式可以设置多组样式</li></ul><h5>6.2 设置类样式方式</h5><ul><li>添加类： $(‘div’).addClass(‘current’)</li><li>移除类:   $(‘div’).removeClass(‘current’)</li><li>切换类： $(‘div’).toggleClass(‘current’)</li></ul><p>[注： 类操作与原生js里的className的区别]原生js的className会覆盖原来的类名，jQuery的类操作不影响原来的类名。</p><h4>7. jQuery属性操作</h4><ul><li><p>设置或获取元素<span class="red">固有属性值</span>：</p><p>获取：element.prop(‘属性’)   #prop &#x3D; property</p><p>设置：element.prop(‘属性’，’属性值’)</p></li><li><p>设置或获取元素<span class="red">自定义属性值</span>：</p><p>获取：element.attr(‘属性’)   #attr &#x3D; attribute</p><p>设置：element.attr(‘属性’，’属性值’)</p></li></ul><h4>8. jQuery内容文本值</h4><ul><li>普通元素内容html()   &#x2F;&#x2F;但是还有标签</li><li>普通元素文本内容text()</li><li>表单的值val()</li></ul><h4>9. jQuery元素操作</h4><h5>9.1 遍历元素</h5><p>jQuery隐式迭代是对同一类的元素做相同的操作，但是若想做不同操作则需要进行遍历</p><ul><li><p>$(‘div’).each(function (index, domEle) {xxx;})</p></li><li><p>$.each(object, function(index, element) {xxx;})</p></li></ul><h5>9.2 创建元素</h5><p>$(‘<li></li>‘)动态创建一个li</p><h5>9.3 添加元素</h5><ul><li>element.append(‘content’) 类似原生appendChild</li><li>element.prepend(‘content’)把内容放入匹配元素内部的最前面</li><li>element.after(‘content’) 把内容放入目标元素后面</li><li>element.before(‘content’)把内容放入目标元素前面</li></ul><h5>9.4 删除元素</h5><p>element.remove()</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery一</title>
    <link href="/2023/06/06/JQuery%E4%B8%80/"/>
    <url>/2023/06/06/JQuery%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2>JQuery入门</h2><p>JQuery是一个JavaScript库，封装了javascript常用的功能代码，为了<span class="red">更快速方便的操作DOM</span>。</p><h4>1. jQuery基本使用</h4><p><img src="/img/jQueryUse.jpg" alt="基本使用"></p><p><i class="fa-sharp fa-solid fa-hippo"></i>原生js如果想把script标签写到div的上面，需要通过窗口加载事件load或者DOMContentLoaded，那么JQuery呢？</p><h4>2. JQuery入口函数</h4><p><span class="red">就相当于原生js的DOMContentLoaded</span>，等DOM结构渲染完毕，不需要等所有外部资源加载完成就可以执行function。</p><p>$(function() {});</p><h4>3. JQuery顶级对象$</h4><p>注意：</p><ul><li>$是jQuery的别称，可以互为替代，但是为了方便还是用$</li><li>$是jQuery的顶级对象，相当于原生js的window</li><li>用$包装元素成jQuery对象，就可以调用jQuery方法。</li></ul><h4>4. JQuery对象和DOM对象的区别</h4><p>JQuery对象是用jQuery方法获取来的对象</p><p>DOM对象是用原生JS获取来的对象</p><p>但是jQuery对象的<span class="red">本质</span>是：利用$对DOM元素进行包装，以<span class="red">伪数组</span>形式存储。</p><p><img src="/img/jqvsjs.png" alt="jQuery对象和DOM对象的区别"></p><h4>5. DOM对象和JQuery对象的相互转换</h4><p>因为jQuery只封装了原生js中的最常用的那部分属性和方法，所以如果想要使用剩下没被封装的，还需要进行转换。</p><ol><li><p>DOM对象 -&gt; JQuery对象： <span class="red">$(DOM对象)</span></p></li><li><p>JQuery对象 -&gt; DOM对象：用<span class="red">伪数组</span>方式调用</p><p>$(‘div’)[index]</p></li></ol><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地存储</title>
    <link href="/2023/06/06/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <url>/2023/06/06/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h2>本地存储</h2><p>HTML5规范提出了需要本地存储大量数据的相关解决方案。</p><h4>1. window.sessionStorage</h4><p>[<span class="red">特点</span>]：</p><ul><li>生命周期为关闭浏览器窗口</li><li>在同一个窗口（页面）下数据可以共享</li><li>以键值对的形式存储</li></ul><p>[语法]：</p><ul><li>存储：sessionStorage.setItem(key, value)</li><li>获取：sessionStorage.getItem(key)</li><li>删除:   sessionStorage.removeItem(key)</li><li>删除全部数据: sessionStorage.clear()</li></ul><h4>2. window.localStorage</h4><p>[<span class="red">特点</span>]：</p><ul><li>生命周期永久有效，除非手动删除，不然关掉页面也会存在</li><li>可以多窗口（页面）共享数据，只要在同一浏览器中</li><li>也是以键值对的形式存储使用</li></ul><p>[语法]：</p><ul><li>存储：localStorage.setItem(key, value)</li><li>获取：localStorage.getItem(key)</li><li>删除：localStorage.removeItem(key)</li><li>删除全部数据: localStorage.clear()</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端网页特效</title>
    <link href="/2023/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/"/>
    <url>/2023/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2>触屏事件touch</h2><p>touch对象代表一个触摸点，触屏事件可相应用户对屏幕或者触控板的操作。</p><h4>1. 常见的touch事件</h4><ul><li>touchstart - 手指触摸到一个DOM元素时触发</li><li>touchmove - 手指在一个DOM元素上滑动时触发</li><li>touchend - 手指从一个DOM元素上移开时触发</li></ul><h4>2. 触摸事件对象</h4><p>TouchEvent是一类描述手指在触摸平面状态变化的事件。常见的触摸事件对象列表</p><ul><li>touches： 正在触摸屏幕的所有手指的列表</li><li>targetTouches：正在触摸当前DOM元素上的手指列表</li><li>changedTouches：手指状态发生改变的列表（从有到无&#x2F; 由无到有）</li></ul><h4>3. 移动端拖动元素</h4><p>思想：</p><p>step1： 触摸元素touchstart，计算手指的初始坐标，同时获得盒子原来的位置。</p><p>step2： 移动手指touchmove，计算手指的滑动距离，移动盒子。</p><p>step3： 离开手指touchend。</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>确定元素位置总结</title>
    <link href="/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4>offsetX</h4><p>偏移量offsetX - 相对offsetParent偏移了多少？</p><p>注意offsetParent是指带有定位的父级节点</p><p>offsetWidth和offsetHeight指包含border，padding，content的宽高。</p><h4>scrollX</h4><p>滚动量scrollX - 文档相对于当前浏览器视口滚动了多少？</p><h4>clientX</h4><p>这个属性描述自身位置。</p><p>clientTop就是border-top的值，clientWidth不包含border</p><p>Reference: <a href="https://blog.csdn.net/lefex/article/details/104682178">(68条消息) 彻底搞懂 offsetX、scrollX、clientX 的区别_lefex的博客-CSDN博客</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC端网页特效</title>
    <link href="/2023/06/05/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/"/>
    <url>/2023/06/05/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2>元素偏移量offset系列</h2><h4>1. offset偏移量概述</h4><p>使用offset系列相关属性可以<span class="red">动态的</span>得到该元素的位置（偏移）、大小等。</p><h4>2. offset系列常用属性</h4><ul><li>element.offsetParent: 返回作为该元素带有定位的父级元素</li><li>element.offsetTop: 返回元素相对带有定位的父元素上方的偏移</li><li>element.offsetLeft: 同上，但是左边框的偏移</li><li>element.offsetWidth: 返回自身包括padding，边框，内容区的宽度，且不带单位</li></ul><h4>3. offset v.s. style</h4><p><img src="/img/offsetvsstyle.jpg" alt="offset v.s. style"></p><hr><h2>元素可视区client系列</h2><h4>1. client概述</h4><p>client本身是客户端的意思，使用client系列相关属性可以获取<u>元素可视区</u>的相关信息, 动态的得到该元素边框大小，元素大小等。</p><h4>2. client系列属性</h4><ul><li>element.clientTop: 返回元素上边框的大小</li><li>element.clientLeft: 返回元素左边框的大小</li><li>element.clientWidth: 返回元素自身包括padding，内容区的宽度，但是不包含边框（这是和offset最大的区别)</li></ul><hr><h2>元素滚动scroll系列</h2><h4>1. scroll系列属性</h4><ul><li>element.scrollTop: 返回被卷上去的距离</li><li>element.scrollLeft: 返回被卷去的左侧距离</li><li>element.scrollWidth: 返回自身实际宽度，不包含边框，返回数值不带单位</li></ul><h4>2. onscroll事件</h4><p>当浏览器的高或者宽度不足以显示整个页面的时候，会自动出现滚动条。滚动条在滚动时会触发onscroll事件。</p><hr><p>【这里总结一下以上三种的异同！！】</p><p>[sum](<a href="https://noelleliu.github.io/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/">确定元素位置总结 - 德芭贝贝同学今天code了吗 (noelleliu.github.io)</a>)</p><hr><h2>动画函数封装</h2><p>通过setInterval（）不断移动盒子的位置就可以达到动画的效果。</p><h2><span class="red">节流阀</span></h2><p>目的：为了防止轮播图按钮连续点击造成播放太快</p><p>本质：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p><span class="red">核心实现思路</span>: 利用回调函数， 添加一个变量来控制，锁住和解锁函数。</p><p>伪代码：</p><p>​var flag&#x3D;true;&#x2F;&#x2F;默认水龙头开着</p><p>​if(flag) {</p><p>​flag &#x3D; false;</p><p>​        do something} &#x2F;&#x2F;为了确保无法连续触发， 关闭水龙头</p><p>​    callback，flag&#x3D;true；&#x2F;&#x2F;利用回调函数执行动画完毕后，打开水龙头</p><p>代码参考：</p><p><img src="/img/%E8%8A%82%E6%B5%81%E9%98%80%E4%BB%A3%E7%A0%81.png" alt="code"></p><p>Reference: <a href="https://blog.csdn.net/qq_36958206/article/details/109049938">(68条消息) JS的节流阀_前端节流阀_鹿小风的博客-CSDN博客</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM对象</title>
    <link href="/2023/06/05/BOM%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/05/BOM%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>Location对象</h2><h4>1. location对象的定义</h4><p>window对象给我们提供了一个location属性，用于<span class="red">获取或设置窗体的URL</span>，并且可以用于解析URL。因为这个属性返回的是一个对象，也称这个属性为location对象。</p><h4>2. URL: Uniform Resource Locator 统一资源定位符</h4><p>互联网上每个文件都有一个唯一的URL， 包含文件的位置以及浏览器应该如何处理等信息。</p><p><u>URL一般语法</u>： protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment</p><h4>3. location对象的属性</h4><p><img src="/img/location.jpg" alt="location对象的属性"></p><hr><h2>Navigator对象</h2><p>navigator对象包含有关浏览器的信息，它有很多属性，最常用的是<span class="red">userAgent</span>, 该属性可以返回由客户机发送服务器的user-agent头部的值，用来判断用户在哪个终端打开页面。</p><hr><h2>History对象</h2><p>windows对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p><h4>history对象方法</h4><ul><li>back(): 后退</li><li>forward(): 前进</li><li>go(argument): 参数为正则前进argument个页面，负则后退。</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js执行队列</title>
    <link href="/2023/06/05/js%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/06/05/js%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2>JS执行队列</h2><h4>1. JS是单线程</h4><p>JavaScript语言的一大特点就是<span class="red">单线程</span>，也就是同一个时间只能做一件事。这也就意味着所有任务需要排队，这就导致如果js执行的时间过长，会造成页面渲染不连贯，导致<span class="red">页面渲染加载阻塞</span>的感觉。</p><hr><p><i class="fa-solid fa-arrows-down-to-line" style="margin: 0 auto;"></i></p><hr><p>为了解决这个问题，利用多核cpu的计算能力，<span class="red">HTML5</span>允许JavaScript脚本创建多个线程，所以JS中出现了<span class="red">同步</span>和<span class="red">异步</span>。</p><h4>2. 同步</h4><p>前一个任务结束后再执行下一个任务，程序的执行顺序与任务的排队顺序一致。</p><h4>3. 异步</h4><p>在做一件事的同时还可以去处理其他事情。</p><h4>4. JS执行机制</h4><p>JS为了防止任务有排队等待时间过长的问题，把所有的任务分为两类。</p><ul><li><p>同步任务：都在主线程上执行，形成一个<span class="red">执行栈</span>。</p></li><li><p>异步任务：JS的异步是通过回调函数实现的，添加到<span class="red">任务队列（消息队列）</span>中。</p></li></ul><p>[<strong>JS执行机制</strong>]：先执行执行栈中的同步任务，异步任务（回调函数）放到任务队列中，一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，进行执行栈开始执行。</p><h4>5. 事件循环Event Loop</h4><p>由于主线程不断的重复获取任务，执行任务，再获取和执行任务，这种机制被称为<span class="red">事件循环</span></p><p><img src="/img/EventLoop.jpg" alt="Event Loop"> </p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-BOM</title>
    <link href="/2023/06/05/js-BOM/"/>
    <url>/2023/06/05/js-BOM/</url>
    
    <content type="html"><![CDATA[<h2>BOM</h2><h4>1. BOM的定义</h4><p>BOM ：Browser Object Model 浏览器对象模型</p><p>提供了独立于内容而与浏览器窗口进行交互的对象。BOM则由一系列相关的对象构成，并且每个对象提供了很多方法和属性。</p><p><verticalLine></verticalLine></p><p><img src="/img/DOMvsBOM.jpg" alt="DOM v.s. BOM"></p><h4>2. BOM的构成</h4><p>BOM： document，location, navigation, screen, history</p><p>[所以！！BOM包含了DOM]</p><h4>3. window对象的常见事件</h4><p>3.1 <strong>窗口加载事件</strong>：文档内容完全加载就会触发该事件，调用处理函数</p><p>window.onload &#x3D; function() {}&#x2F;&#x2F;传统方式注册</p><p>window.addEventListener(‘load’, function(){})&#x2F;&#x2F;方法监听方式注册</p><p>[好处]：有了window.onload就可以把js代码写到页面元素的上方，但是本质上还是等内容全部加载完毕再执行处理函数。</p><p>[ie9以上才支持的]：document.addEventListener(‘DOMContentLoaded’, function(){})，仅当DOM加载完成，就会触发执行函数。如果图片过多，onload触发需要较长的事件，DOMContentLoaded事件会比较合适。</p><p>3.2 <strong>调整窗口大小事件</strong>：常利用本事件完成响应式布局</p><p>window.onresize &#x3D; function() {}</p><p>window.addEventListener(‘resize’, function() {})</p><p>3.3 <strong>定时器</strong>：</p><ul><li><p>window.setTimeout(调用函数， [延迟毫秒数])：这是一个callback回调函数</p><p>var timer1 &#x3D; setTimeout(fn, 2000);</p><p>var timer2 &#x3D; setTimeout(fn, 5000);</p><hr><p>清除定时器的方式：window.clearTimeout(timeoutID)</p><p>e.g. 清除上面的timer1定时器</p><p>clearTimeout(timer1);</p></li><li><p>window.setInterval(回调函数，[间隔毫秒数]): 每隔一段时间就会反复调用</p><hr><p>清除定时器的方式：window.clearInterval(intervalID)</p></li></ul><p>3.4 <strong>this指向</strong>:</p><p>this的指向在函数定义的时候是确定不了的，只有在函数执行的时候才能确定this到底指向谁。一般this最终的指向的是调用它的对象。</p><ul><li>全局作用域下：this指向全局对象window</li><li>方法调用中：this指向调用的对象</li><li>构造函数中：this指向构造函数的实例</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-DOM事件流</title>
    <link href="/2023/06/05/js-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <url>/2023/06/05/js-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2>DOM事件流</h2><h4>1. 事件流</h4><p>描述从页面中接收事件的顺序。</p><h4>2. DOM事件流</h4><p>事件发生时会在节点元素之间按照特定的顺序传播。此传播过程即为DOM事件流。</p><h4> 3. DOM事件流三阶段</h4><p><span class="red">捕获阶段</span>：从windows对象依次向下传播，到达目标节点。捕获阶段不会相应任何事件。</p><p><span class="red">当前目标阶段</span>：目标节点触发事件。</p><p><span class="red">冒泡阶段</span>：从当前节点依次向上传播，直到windows对象。</p><p><a href="/img/EventFlow.jpg">DOM事件流三阶段</a></p><h4><span class="red">4. 注意<span></h4><p>a. JS代码中只能执行捕获或者是冒泡其中的一个阶段</p><p>b. onclick只能得到冒泡阶段</p><p>c. addEventListener(type, listener[,useCapture])如果第三个参数不写默认false就是在冒泡阶段调用事件处理程序；若设置为true，则是在事件捕获阶段调用事件处理程序。</p><p>d. 但是在开发中，关注事件冒泡会更多。</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件对象</title>
    <link href="/2023/06/05/js%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/05/js%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>事件对象</h2><h4>1. 事件对象的定义与理解</h4><p>事件对象的官方定义：event事件对象代表事件的状态，比如按键的状态，鼠标的位置等等。</p><p><span class="red">理解</span>：当DOM树中某一个元素事件被触发的时候，会同时自动产生一个用来描述事件的所有相关信息的对象，这就是event（事件对象）。</p><h4>2. 事件对象的使用语法</h4><p>2.1 可以直接通过event来获取</p><p>2.2 可以通过函数传参数的方式获取： eventTarget.onclick &#x3D; function(<span class="red">e</span>) {…}</p><h4>3. 事件对象常见的属性和方法</h4>[事件对象常见的方法和属性](/img/event.jpg)<h4>4. 阻止事件冒泡</h4><p>利用事件对象中的stopPropagation（）方法！！</p><p>var son &#x3D; document.querySelector(‘.son’);</p><p>son.addEventListener(‘click’, function(e) {</p><p>​alert(‘son’);</p><p>​<span class="red">e.stopPropagation();</span>&#x2F;&#x2F;阻止事件冒泡，这样就不会弹出下面的father！！！</p><p>})</p><p>var father &#x3D; document.querySelector(‘.father’);</p><p>father.addEventListener(‘click’, function() {</p><p>​alert(‘father’)})</p><h4>5. 事件委托（委派、代理）</h4><p>问题引出：如果想给ul的每个小li都注册事件，访问DOM次数过多会演唱整个页面的交互就绪时间。</p><p><strong>事件委托原理：</strong>不是给每个子节点单独设置事件监听器，而是设置在父节点上，利用冒泡影响每个子节点。</p><p>var ul &#x3D; document.querySelector(‘ul’); &#x2F;&#x2F;只需要获取一次</p><p>ul.addEventListener(‘click’, function(e) {</p><p>​alert(‘hhhhh’)})</p><h4>6. 常见的鼠标事件以及事件对象</h4><p><a href="/img/mouseEvent.jpg">常见的鼠标事件</a></p><p><a href="/img/%E9%BC%A0%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%BA%8B%E4%BB%B6.jpg">常见的鼠标事件对象</a></p><h4>7. 常见的键盘事件以及事件对象</h4><p><a href="/img/keyEvent.jpg">常见的键盘事件</a></p><p><a href="/img/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.jpg">常见的键盘事件对象</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件高级</title>
    <link href="/2023/06/05/js%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/06/05/js%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2>js事件高级</h2><h4>1. 注册事件（绑定事件）</h4><p>【传统的注册方式】：</p><p>​        var btn &#x3D; document.getElementById(‘btn’);&#x2F;&#x2F;获取事件源</p><p>​btn.onclick &#x3D; function() {alert(‘hhhhh’)}&#x2F;&#x2F;事件类型+事件处理程序</p><p><span class="red">特点</span>：注册事件的唯一性（同一个元素同一个事件只能设置一个处理函数，最后注册的会覆盖前面注册的处理函数</p><p>【<span class="red">方法监听注册方式</span>】：W3C标准推荐</p><p>​eventTarget.addEventListener(type, listener[, useCapture])</p><p><span class="red">特点</span>：同一个元素同一个事件只能注册多个监听器，按照注册顺序依次执行。</p><h4>2. 删除事件（解绑事件）</h4><p>注意：解绑事件需要写在function里的最后，这样才能保证先执行一次处理程序再解绑。</p><p>【传统的注册方式的解绑】：</p><p>​ var btn &#x3D; document.getElementById(‘btn’);</p><p>​ btn.onclick &#x3D; function() {</p><p>​alert(‘hhhhh’)；</p><p>​btn.onclick &#x3D; null;}</p><p>【<span class="red">方法监听注册方式的绑定与解绑</span>】：</p><p>​btn.addEventListener(‘click’, fn);</p><p>​function fn() {</p><p>​alert(‘hhhhh’);</p><p>​btn.removeEventListener(‘click’, fn)};</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js节点操作</title>
    <link href="/2023/05/23/js%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/05/23/js%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2>js节点操作</h2><p>利用DOM树可以把节点划分为不同的层级关系。</p><ol><li><p>父级节点</p><p>node.parentNode  这个属性返回node节点最近的一个父节点</p></li><li><p>子节点</p><p>node.childNode 返回指定节点的<span class="red">所有</span>子节点的集合</p><p>!注意：包括文本节点甚至空格等都会被一起返回， 若只想获得子元素节点就别用了</p></li></ol><p>​2.1  <i class="fa-sharp fa-light fa-sparkles"></i><span class="red">更推荐的方法</span></p><p>​<span class="red">node.children</span>只读属性，只返回所有子元素节点。</p><p>​2.2 返回某个特定的子节点</p><p>​node.firstChild（Child是包含所有节点，文字等）</p><p>​node.lastChild</p><p>​node.firstElementChild（真正的子节点）</p><p>​node.lastElementChild</p><ol start="3"><li><p>兄弟节点</p><p>node.nextSibling</p><p>node.previousSibling</p><p>node.nextElementSibling</p><p>node.previousElementSibling</p></li><li><p>节点的<span class="red">创建</span></p></li></ol><p>​document.createElement(‘tagName’)根据需求动态创建元素节点，但是创建了还不会显示，还需要<span class="red">添加</span></p><ol start="5"><li><p>节点的添加</p><p>node.appendChild(child)将一个节点添加到指定父节点的子节点列表末尾。<span class="blue">类似css中的after伪元素</span></p><p>node.insertChild(child)将一个节点添加到指定父节点的子节点前面。<span class="blue">类似css中的before伪元素</span></p></li><li><p>节点的删除</p><p>node.removeChild()返回删除节点</p></li><li><p>节点的赋值</p><p>node.cloneNode()返回节点的副本 - 若无参数就是浅拷贝，不克隆里面的子节点；若参数为true，则是深度拷贝，会复制节点本身以及里面所有的节点。</p></li></ol><head>    <style>        .red {            color: red;}        .blue {            color: blue;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件基础</title>
    <link href="/2023/05/23/js%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/23/js%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2>js事件基础</h2><h4>1. 事件概述</h4><p>​js使我们有能力创造动态页面，其中，<span class="red">事件</span>是可以被js侦测到的行为。</p><h4>2. 事件三要素</h4><ul><li>事件源：谁被触发  e.g.按钮</li><li>事件类型： 怎么触发  e.g.点击触发</li><li>事件处理程序：通过函数赋值的方式  e.g.弹出对话框</li></ul><h4>3. 执行事件的步骤</h4><ol><li>获取事件源</li><li>注册（绑定事件）</li><li>添加事件处理程序（函数赋值）</li></ol><h4>4. 常见的鼠标事件</h4><p><img src="/img/mouseevent.jpg" alt="常见的鼠标事件"></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-DOM</title>
    <link href="/2023/05/17/js-DOM/"/>
    <url>/2023/05/17/js-DOM/</url>
    
    <content type="html"><![CDATA[<h2>DOM</h2><h4>1. DOM的定义</h4><p>DOM：document object model文档对象模型，是W3C组织推荐的处理可扩展标记语言的标准编程接口，通过这些接口可以改变网页的内容、结构和样式。</p><h4>2. DOM树</h4><p><img src="/img/DOMTree.jpg" alt="DOM树结构"></p><ul><li>文档：一个页面就是一个文档，DOM中用document表示</li><li>元素：页面中所有的标签都是元素，DOM中用element表示</li><li>节点：页面中所有的内容都是节点，DOM中用node表示</li></ul><p>DOM把以上所有看作为<span class="red">对象</span>，所以叫做文档对象模型</p><h4>3. DOM是如何获取元素的？</h4><ul><li><p>根据id获取：<strong>document.getElementById(‘id’)</strong></p><p>若匹配到则返回<span class="pink">Element对象</span>，没找到返回null</p></li><li><p>根据标签名获取：<strong>document.getElementByTagName(‘标签名’)</strong></p><p>获取来的（不管是多个还是一个还是没有）都以<span class="pink">伪数组</span>的形式进行存储。</p></li><li><p>通过类型获取:<strong>document.getElementByClassName(‘类名’)</strong></p></li><li><p>通过<span class="red">选择器</span>选择（单）：<strong>document.querySelector(‘选择器’)</strong></p></li></ul><p>​会根据指定选择器返回<span class="red">第一个</span>元素对象</p><ul><li><p>通过<span class="red">选择器</span>选择（复数）：<strong>document.querySelectorAll(‘选择器’)</strong></p></li><li><p>两个特殊的元素(body, html)的获取方式</p><p>document.body, document.documentElement</p></li></ul><head>    <style>        .red {            color: red;}        .pink {            color: pink;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js简单数据类型和复杂数据类型</title>
    <link href="/2023/05/17/js%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/05/17/js%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2>JS简单数据类型和复杂数据类型</h2><h4>简单数据类型 - </h4><p>简单数据类型，又称<span class="red">值类型</span>，因为在存储时变量中存储的是值本身。</p><p>存在<span class="pink">栈</span>中</p><p>e.g. string, number, boolean, undefined, null等</p><h4>复杂数据类型</h4><p>复杂数据类型，又称<span class="red">引用类型</span>，因为在存储时变量中存储的是<strong>地址</strong></p><p>存在<span class="pink">堆</span>中</p><p>e.g. Object, Array,Date等</p><head>    <style>        .red {            color: red;}        .pink {            color: pink;        }        </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js对象</title>
    <link href="/2023/05/17/js%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/17/js%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>js中的对象数据结构</h2><ul><li><p>为什么需要对象？</p><p>保存一个值，我可以选择用变量来存<br></p><p>保存多个值，我可以选择用数组来存<br></p><p>那么如果我想存储一个人的完整信息，那么我就需要<span class="red">对象</span>啦~</p></li><li><p>对象的组成：属性 + 方法</p></li><li><p>如何创建一个对象呢？</p><ol><li>利用<span class="red">字面量</span>来进行创建 : 键值对<br></li></ol><p>   e.g. var star &#x3D; {</p><p>   ​name: xxx, <br></p><p>   ​age: 18,<br></p><p>   ​sayHi: function() {<br></p><p>   ​alert(‘Hi’)</p><p>   }}</p><p>   调用方式：star.name，star.sayHi()</p><ol start="2"><li><p>利用<span class="red">new Object</span>来创建：<br></p><p>var lxy &#x3D; new Object();<br></p><p>lxy.name &#x3D; ‘Noelle’;<br></p><p>lxy.sayHi &#x3D; function() {<br></p><p>​alert(‘Hi’)</p></li><li><p>利用<span class="red">构造函数</span>来创建：<br></p><p>[<u>好处</u>:  上述使用字面量和原生的Object构造函数一次只能创建一个对象。但是利用自定义构造函数封装公共的属性和方法，可以一次创建多个不同的对象！！！<i class="fa-solid fa-award"></i>]<br></p><p>function Person(name, age) {&#x2F;&#x2F;抽象公共部分，泛指一个类class<br></p><p>​this.name &#x3D; name;<br></p><p>​this.age &#x3D; age;<br></p><p>​this.sayHi &#x3D; function() {<br></p><p>​alert(‘Hi’)}</p><p>}</p><p>var lxy &#x3D; <span class="red">new </span> Person(‘Noelle’, 18);&#x2F;&#x2F;<span class="red">对象实例化</span></p></li><li><p><i class="fa-solid fa-trumpet"></i><span class="red"><strong>new关键字执行时做了什么？</strong></span></p><ul><li>首先，在内存中创建一个新的空对象；</li><li>其次，让<span class="red">this</span>指向这个新的空对象；</li><li>接着，执行构造函数里的代码，给新的空对象添加属性和方法；</li><li>最后，返回这个新对象（<i class="fa-solid fa-exclamation"></i>new就做了，不需要一般函数return了！）</li></ul></li><li><p>如何遍历一个对象里的所有属性？</p><p>for (var att in obj) {</p><p>xxx}</p></li><li><p>常用的的JavaScript中的内置对象和内置构造函数：Math, Date, Array, String<br></p><p>其中Math<strong>是内置对象，并不是构造函数</strong>，因为它不需要new进行调用，可以直接使用，不要被大写迷惑咯~</p><hr></hr><p>6.1 Math(内置对象)</p><ul><li>Math.floor()  向下取整</li><li>Math.ceil()向上取整</li><li>Math.round()四舍五入取整</li><li>Math.abs()绝对值</li></ul><hr></hr><p>6.2 Date（内置构造函数）</p><ul><li><p>new Date()  如果括号里有参数比如’2023&#x2F;5&#x2F;17’就返回括号里的时间；若没有参数就反正当前时间</p></li><li><p>日期格式化可用的方法：</p><p>a. getFullYear()</p><p>b. getMonth()  记得＋1！！！！！！！</p><p>c. getDate()</p><p>d. getDay()</p><p>e. getHours()</p><p>f. getMinutes()</p><p>g. getSeconds()</p></li></ul><hr></hr><p>6.3 Array (内置构造函数)</p><p>indexOf可以查找一个给定元素的第一个索引</p><hr></hr><p>6.4 String(内置构造函数)</p><p>注意!!!!字符串所有的方法都不会修改字符串本身，操作完成返回一个新的字符串而已，所以<strong>避免大量的字符串拼接</strong></p><ul><li>charAt()返回指定位置的字符</li><li>substr(start, length) 返回从start开始，长度为length的子字符串f</li><li>slice(start, end)返回[start,end)的子字符串</li><li><i class="fa-solid fa-exclamation"></i>split()将字符串切分为<strong>数组</strong>并返回</li></ul></li></ol></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js预解析</title>
    <link href="/2023/05/17/js%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/05/17/js%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2>Js预解析</h2><h4>1. 预解析的背景</h4><p>JavaScript代码是由浏览器中的javaScript解析器来执行的，但是分为两步：预解析 + 代码执行。</p><h4>2. 预解析做了什么？</h4><p>预解析阶段，js引擎会把js文件里所有的<span class="red">var变量声明</span>和<span class="red">function函数声明</span><u>提升到当前作用域的最前面</u>。</p><h4>3. 例子</h4><p>console.log(num);</p><p>var num &#x3D; 10;</p><hr></hr><p>上述代码的输出结果是undefined！！为什么不报错嘞！！就是预解析啦，相当于以下代码</p><hr></hr><p>var num; &#x2F;&#x2F; 变量提升！</p><p>console.log(num); &#x2F;&#x2F;打印一个声明但未赋值的变量就是undefined啦~</p><p>num &#x3D; 10；</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js初识</title>
    <link href="/2023/05/17/js%E5%88%9D%E8%AF%86/"/>
    <url>/2023/05/17/js%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2>JS基础</h2><ul><li><p>计算机语言：机器语言，汇编语言，高级语言</p><p>机器语言和汇编语言都是直接对硬件操作，但汇编语言采用英文缩写的标识符</p></li><li><p>编程语言：汇编语言 + 高级语言</p><p>编程语言 ( e.g. JavaScript) v.s. 标记语言( e.g. HTML):</p><ul><li>标记语言：不向计算机发出指令，是用来被读取的</li><li>编程语言：具有很强的逻辑和行为能力，是主动的。</li></ul></li><li><p>JavaScript是什么？</p><p>JavaScript是一种运行在客户端的脚本语言（<i class="fa-solid fa-pen-to-square"></i>脚本语言不需要编译，由js引擎逐行解释并执行）</p></li><li><p>浏览器如何执行我的js代码？</p><p>浏览器引擎 &#x3D; 渲染引擎( e.g. Chrome’s blink&#x2F;webkit) + js引擎( e.g. Chrome’s v8)</p></li><li><p>JavaScript的组成部分：ECMAScript + DOM + BOM</p><p><img src="/img/js.png" alt="js组成"></p><ul><li>ECMAScript: 由ECMA国际规定JS编程语法和基础核心，是所有浏览器厂商共同遵守的一套<span class="red">js语法准则</span>。</li><li>DOM: Document Object Model, 文档对象模型：通过DOM提供的接口对页面上的元素进行操作。</li><li>BOM: Browser Object Model, 浏览器对象模型：通过BOM提供的接口可以操作浏览器窗口。</li></ul></li></ul><p>​</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架1-Bootstrap</title>
    <link href="/2023/05/16/%E6%A1%86%E6%9E%B61-Bootstrap/"/>
    <url>/2023/05/16/%E6%A1%86%E6%9E%B61-Bootstrap/</url>
    
    <content type="html"><![CDATA[<h2>Bootstrap-v4使用随想</h2><p>中文文档网址：<a href="https://v4.bootcss.com/docs/getting-started/introduction/">https://v4.bootcss.com/docs/getting-started/introduction/</a></p><p>Bootstrap是由推特（Twitter）开源的一款HTML、CSS和JS框架，<strong>它主要用来开发响应式布局、移动设备优先的WEB项目</strong>。</p><ul><li><strong>step1：在所有的css样式之前引入bootstrap的css文件</strong></li></ul><ul><li><strong>step2:  在页面底部引入bootstrap的script标签</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Less</title>
    <link href="/2023/05/16/Less/"/>
    <url>/2023/05/16/Less/</url>
    
    <content type="html"><![CDATA[<h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><h4>CSS的弊端</h4><ul>    <li>CSS冗余度很高</li>    <li>不利于复用代码</li>    <li>CSS没有很好的计算能力</li></ul><h4>Less(Leaner Style Sheets)</h4><p>Less是一门<span class="red">CSS扩展语言</span>，也称为<span class="red">CSS</span>预处理器，在现有的CSS语法的基础上，加入<strong>程序式</strong>语言的特性。最大的特点就是引入了变量、函数等功能，用最少的代码做更多的事情。</p><h3>1. Less变量</h3><p>e.g. @color: pink; <br></p><p>​body {</p><p>​background-color: @color; }</p><h3>2. Less编译</h3><p><u>Easy LESS</u>插件可以使保存的less文件自动生成css文件</p><h3>3. Less嵌套</h3><p>在css选择器中的子代选择器be like: .header logo{}， 但是在less中，子元素的样式需要嵌套在父元素的样式中书写。e.g. .header{logo {}}</p><h3>4. Less实现伪类选择器</h3><p>在Less中，有<span class="red"><strong>&amp;</strong></span>符号，会被解析成<u>父元素本身</u>或者<u>父元素的伪类</u></p><p>e.g. 在css中，a:hover {}; 在Less中，a{&amp;hover{}}</p><h3>5. Less算数运算</h3><p><i class="fa-regular fa-face-smile-plus"></i>在Less中，任何数字、颜色或者变量都可以参与算数运算</p><p>[ 注：若两个不同单位的值进行算数运算， 运算结果取第一个值的单位。e.g. 10px + 5rem &#x3D; 15px;<br></p><p>若只有一个值有单位，则运算结果取该单位。e.g. 10px + 5 &#x3D; 15px]</p><head>    <style>    .red {        color: red;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Less</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端常见布局</title>
    <link href="/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/"/>
    <url>/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h4>1. 流式布局</h4><p>流式布局，也叫百分比布局，也叫非固定像素布局，是通过<strong>盒子的宽度百分比</strong>来进行伸缩，而不选用固定的像素作为大小的单位。</p><h4>2. flex布局<i class="fa-solid fa-star"></i></h4><p>原理：为<u>父盒子指定flex属性</u>后称为<span class="red">容器</span>，所有子元素会自动成为<span class="red">容器成员</span>，通过特定的规则进行排列</p><p>2.1 flex布局容器常见属性</p><ul>    <li>display: flex<br>               将父盒子指定flex属性</li>    <li>flex-direction: row(默认) / row-reverse / column / column-reverse<br>            设置<strong>主轴</strong>的方向</li>    <li>justify-content: flex-start(默认) / flex-end / center / space-around / space-between<br>            设置元素在主轴上的排列方式<br>            [<span class="red">注</span>：space-around是均分剩余空间；space-between是先两边贴边再平分]</li>    <li>flex-wrap: no-wrap(默认) / wrap<br>            是否换行</li>    <li>align-items: flex-start / flex-end/ center / stretch(默认)<br>            设置<strong>侧轴</strong>上元素排列方式</li></ul><p>2.2 flex布局容器成员常见属性</p><ul>         <li>flex: 数字(默认为0)<br>               指定子元素所占的份数</li>        <li>order:数字(默认为0)            定义子元素的排列顺序，数值越小越靠前</li>     </ul><h4>3. rem适配布局</h4><p>3.1 rem（root em）单位：是一个<span class="red">相对单位</span></p><p>​[<i class="fa-solid fa-book"></i>review:  em是指父元素字体大小]</p><p>​rem的基准是相对于<span class="red">html元素字体大小</span></p><p>3.2 <i class="fa-light fa-message-smile"></i>rem的优势： 父元素字体大小可能不一致，但html可以很好的控制页面元素大小。</p><p>3.3 rem布局常和<span class="pink">媒体查询</span>一起使用</p><p>​先通过媒体查询(media query)控制html文字大小， 再通过rem单位进行动态的变化，代码如下图。</p><p><img src="/img/remMediaquery.jpg" alt="Code of rem with media query"></p><head>    <style>        .red {            color: red;}        .pink {            color: pink;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline4-DeepConvLSTMimp</title>
    <link href="/2023/05/16/baseline4-DeepConvLSTMimp/"/>
    <url>/2023/05/16/baseline4-DeepConvLSTMimp/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTMimp"><a href="#DeepConvLSTMimp" class="headerlink" title="DeepConvLSTMimp"></a>DeepConvLSTMimp</h2><p>*模型出处：Improving Deep Learning for HAR with shallow LSTMs 2021</p><h3>模型结构</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i> Opportunity</i></p></li><li><p><i>Wetlab</i></p></li><li><p><i>RealWorld (HAR)</i></p></li><li><p><i>SBHAR</i></p></li><li><p><i>HHAR.</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvLSTM</p><p>在多个数据集上对比了DeepConvLSTM和作者提出的单隐层的DeepConvLSTMimp网络，并且在单隐层的情况下，横向对比了隐藏单元的个数(128，256，512，1024）对结果的影响。</p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: 1e-4</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>网络结构上一咪咪的改动只要足够多的对比工作也行啦~</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p>*不放了…就在把DeepConvLSTM中间的lstm2删了<i class="fa-solid fa-face-grin-squint-tears"></i></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTMimp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline2-EEGNet</title>
    <link href="/2023/05/16/baseline2-EEGNet/"/>
    <url>/2023/05/16/baseline2-EEGNet/</url>
    
    <content type="html"><![CDATA[<h2 id="EEGNet"><a href="#EEGNet" class="headerlink" title="EEGNet"></a>EEGNet</h2><p>*模型出处：EEGNet: A Compact Convolutional Network for EEG-based Brain-Computer Interfaces 2018</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="/img/EEGNet.png" alt="Model"></p><p><img src="/img/EEGNetspecific.png" alt="Details"></p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><img src="/img/EEGNetdataset.png" alt="Dataset"></p><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvNet, ShallowConvNet </p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: not mentioned</li>    <li>epochs: 500</li>    <li>dropout: 0.5forCS / 0.25forSI</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p>在被试独立和被试交叉的情况下，四种范式上均有提升。</p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>出发点: 想要提出一种适合各种BCI范式的通用的网络，并且希望这个通用网络十分紧凑（参数数量少）。</li>    <li>亮点1：将深度卷积和可分离卷积运用到脑电数据上<br>        (1)可分离卷积在这里是指将完整的卷积运算分解为深度卷积+逐点卷积        (2)逐点卷积的作用：学习如何将特征图做优化的结合</li>    <li>亮点2：对被试交叉和被试独立的数据划分情况都做了相应的讨论</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/EEGNetCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EEGNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline3-DeepConvLSTM</title>
    <link href="/2023/05/15/baseline3-DeepConvLSTM/"/>
    <url>/2023/05/15/baseline3-DeepConvLSTM/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTM"><a href="#DeepConvLSTM" class="headerlink" title="DeepConvLSTM"></a>DeepConvLSTM</h2><p>*模型出处：Deep Convolutional and LSTM Recurrent Neural Networks for Multimodal Wearable Activity Recognition 2016</p><h3>模型结构</h3><p><img src="/img/DeepConvLSTM.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>OPPORTUNITY</i></p></li><li><p><i>Skoda</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：不带lstm的CNN（<i class="fa-light fa-thumbs-down"></i>这不就是纯纯消融实验吗？？</p><p>实验控制baseline-CNN和DeepConvLSTM前面的卷积模块和最后的分类模块完全相同，基线CNN的两个dense层是非循环且全连接的；DeepConvLSTM的两个dense层的cell是LSTM cell。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: 10e-3</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMres1.png" alt="ResultinDataset1"></p><p><img src="/img/DeepConvLSTMres2.png" alt="ResultinDataset2"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是考虑到HAR问题的时序性，添加LSTM模</li>    <li>文中提到在他们的实验中使用RMSProp优化器效果更好</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvLSTMCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline1-DeepConv</title>
    <link href="/2023/05/15/baseline1-DeepConv/"/>
    <url>/2023/05/15/baseline1-DeepConv/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConv"><a href="#DeepConv" class="headerlink" title="DeepConv"></a>DeepConv</h2><p>*模型出处：Deep learning with convolutional neural networks for EEG decoding and visualization 2017</p><h3>模型结构</h3><p><img src="/img/DeepConv.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>BCI competition IV dataset 2a</i><span>（ 288 trials per subject）</span></p></li><li><p>自采数据集（880 trials per subject）</p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：FBCSP</p><p>设计了两层的shallowConvNet和五层的DeepConvNet甚至最高到31层的ResNet以及深浅结合的网络。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: not mentioned</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p><img src="/img/DeepConvRes.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是围绕着如何将在图像领域的深度卷积网络运用在脑电数据上。<br>        首先，作者提出了脑电和图像的区别：图像是二维静态的，而脑电数据是在<strong>三维的头皮上获取的时序数据        </strong><br>        接着，作者还提出了，脑电数据相比于图像数据数量太少，需要进行裁剪，也就是分段，作者用的2s一段。        </li>    <li>作者提出的DeepConv网络的Block1是专门为了提取脑电数据信息的：时间维度拼接空间维度</li>    <li>作者通过尝试对神经网络进行解释，得出结论：卷积网络学习了不同频段信息。<br>        <i class="fa-solid fa-hand-sparkles"></i>我可以试着把数据先进行小波包分解再送进网络进行学习</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvCode.png" alt="myCode"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精灵图</title>
    <link href="/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/"/>
    <url>/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h2><h3 id="精灵图的背景"><a href="#精灵图的背景" class="headerlink" title="精灵图的背景"></a>精灵图的背景</h3><p>一个网页中会需要很多小的背景图作为装饰，但是如果图像过多时，服务器频繁的接收和发送请求会使得服务器压力过大，降低加载速度。</p><p><i class="fa-sharp fa-light fa-truck-fast" style="color: #a4d5f4;"></i>为了<span class="red">有效减少服务器接收和发送请求的次数，提高网页的加载速度</span>， 出现了CSS精灵技术</p><h3 id="精灵图的核心原理"><a href="#精灵图的核心原理" class="headerlink" title="精灵图的核心原理"></a>精灵图的核心原理</h3><p>将一堆小的背景图像整合到一张大图 (精灵图sprites) 上，服务器只需要请求一次就可以了~</p><h3 id="精灵图的使用"><a href="#精灵图的使用" class="headerlink" title="精灵图的使用"></a>精灵图的使用</h3><p>移动背景图片的位置，调整<strong>background-position</strong>属性值</p><p>[注：属性值是调整x和y坐标的距离，但是网页的坐标是以左到右为x正方向，上到下为y正方向，所以一般我们都向上向左调整精灵图的位置，数值为<span class="red">负值</span>。]</p><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>sprites</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之三： 定位</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2>定位</h2><p>[Review: 浮动可以让多个块级盒子在一行没有缝隙的排列显示，常用于横向排列盒子。]</p><p>终于轮到定位啦！！</p><ol><li><p>定位的目的： 让盒子自由的在某个盒子内移动位置或者固定位置， 并且可以<span class="red">压住</span>其他盒子</p></li><li><p>定位模式： 也就是position属性可能的属性值： 静态定位static、相对定位relative、绝对定位absolute、固定定位fixed</p><p>2.1 静态定位static（position属性的默认值）：无定位，可以按照标准流来看待</p><p>2.2 相对定位relative：元素在移动位置的时候，相对<u>它本身原来的位置</u>来移动的。</p><p>[<i class="fa-solid fa-flag"></i>注意]原来位置还在，相对定位并<span class="red">没有脱离标准流</span>，后面的盒子仍然以标准流的方式看它。</p><p>2.3 绝对定位absolute：元素在移动的时候，是根据他的<u>祖先元素</u>来移动的</p><p>[<i class="fa-solid fa-flag"></i>注意] 绝对定位是<span class="red">脱标</span>的！</p><p>2.4 固定定位fixed：元素固定在浏览器<u>可视区</u>的某一位置。</p><p>[<i class="fa-solid fa-flag"></i>注意] 固定定位也是脱离标准流的，不占有原来的位置。</p></li><li><p><i class="fa-solid fa-stars"></i>一个非常经典的组合：<span class="red"><strong>子绝父相</strong></span>、子绝父绝</p><p>原因：子级绝对定位不会占有位置，可以放到父盒子里任一个位置，不影响其他兄弟。而父盒子相对定位并没有脱离标准流会限制子盒子。如果父盒子也不需要占位置的话，子绝父绝也是可以滴~</p></li><li><p>绝对定位或者固定定位水平居中：在标准流中，我们可以通过margin: 0 auto；来设置元素水平居中，但是脱离标准流的时候就要{left: 50%; margin-left: -（自身宽度的一半); }</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>position</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之二：浮动</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2>浮动</h2><p>这篇来复盘一下布局三大哥中的二哥： 浮动。</p><ol><li><p>传统页面布局的三种方式： 标准流、<span class="red">浮动</span>、定位。</p></li><li><p>浮动和标准流的差别：</p><ul>    <li>标准流：按照规定好的默认方式排列元素</li>    <li>浮动float：脱离标准流，按自己的规则排列</li></ul></li><li><p>浮动的特性：</p><ul>    <li>脱离标准流，以至于不再保留盒子原来的位置</li>    <li>任何元素都可以进行浮动，且浮动后会具有行内块元素相似的特性，建议如果一个元素浮动，其他的兄弟元素也一起浮动</li>    <li>浮动的元素常和标准流的父级搭配使用</li></ul></li><li><p><i class="fa-solid fa-car-on"></i>浮动可能会带来的问题： 如果父盒子在一些情况下不方便直接给高度，但是子盒子浮动是不占位置的，无法撑开盒子，父盒子的高度为0，会影响后面的标准流盒子。</p></li><li><p>清除浮动：clear: both 清除左右两侧浮动影响</p><p>清除浮动后，父级会根据子盒子自动调整高度，就可以解决上述问题了。</p></li><li><p>具体方法：</p><ol>    <li>额外标签法：在浮动的元素末尾添加一个空标签</li>    <li>父元素添加overflow: hidden属性</li>    <li>:after伪元素法：给父元素添加after伪元素并clear</li>    <li>双伪元素清除浮动：在3的基础上再添加一个:before</li></ol></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之一：盒子模型</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2>盒子模型</h2><p>最近准备找前端实习和工作啦，就在博客上总结一下布局的三大核心：盒子模型，浮动和定位。剩下两个也有单独的讲解~</p><ol><li><p>页面布局的<strong>本质</strong>：利用CSS设置好盒子样式，摆放到相应的位置。（听起来好像很简单，坑很多）</p></li><li><p>盒子模型的组成：把HTML布局元素看成一个矩形的盒子，封装周围的元素，包括：边框border、内边距padding、外边距margin和实际内容content</p><p>2.1 边框border注意:</p> <ul><p>​  <li>复合型写法  border: 1px solid black;</li></p><p>​  <li>细线边框属性：border-collapse: collapse;</li></p><p>​  <li>如果是<strong>border-box</strong>，边框会影响盒子的实际大小，需要减去对应的宽高</p>  </ul><p>2.2 内边距padding注意：</p><ul><p>​  <li>如果padding属性有一个值，代表上下左右的padding都一样；两个值代表上下，左右；三个值代表上，左右，下；四个值代表上，右，下，左</li></p><p>​  <li>如果是<strong>border-box</strong>，padding也会撑大盒子，同理，需要减去对应的宽高</p>  </ul><p>2.3 外边距margin注意：</p><ul><p>​  <li>前两条和padding一样，见2.2</li></p><p>​  <li><i class="fa-solid fa-seal-exclamation"></i><span class="red">外边距的合并</span>会有新的问题：</br></p><p>​(1). <i class="fa-regular fa-triangle-exclamation"></i><strong>相邻</strong>元素垂直外边距合并: 并非相加，而是取大的那个</br></p><p>​(2). <i class="fa-regular fa-star-exclamation"></i><strong>嵌套</strong>元素垂直外边距合并会引起塌陷问题：父元素会塌陷较大的外边距值</li></p>  </ul></li><li><p>圆角边框：border-radius</p><p>注意复合写法的时候顺序是top-left，top-right，bottom-right, bottom-left。</p></li><li><p>盒子阴影：box-shadow</p><p>box-shadow: h-shadow v-shadow blur spread color inset;</p><p>(注：盒子阴影并不占用空间，不会影响其他盒子的排列)</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>box-model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在md文档中引入icon</title>
    <link href="/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/"/>
    <url>/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/</url>
    
    <content type="html"><![CDATA[<h2 id="尝试如何在markdown文档中引入可爱的icon图标"><a href="#尝试如何在markdown文档中引入可爱的icon图标" class="headerlink" title="尝试如何在markdown文档中引入可爱的icon图标"></a>尝试如何在markdown文档中引入可爱的icon图标</h2><p>最近写自己的技术博客的时候，在一些地方很想插入一些可爱的图标，就想着用之前做项目的时候使用的Font Awesome图标库引入文档，由此插入其中的icon。下面是官方的地址：</p><p><i><a href="https://fontawesome.com/">https://fontawesome.com/</a></i></p><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><h5><i class="fa-solid fa-baby"></i>step1: 引入Font Awesome的js文件<img src="/img/Font-Awesome.png"/></h5><p>   （注：位置要放在head标签内）</li></p><h5><i class="fa-solid fa-person-rays"></i>step2: 在icon界面找到想要的图标，复制类名到自己的想加的地方</h5><p>   （注：拿i标签包裹一下）</li></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head><ul]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS层叠时的优先级问题</title>
    <link href="/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2>CSS层叠时的优先级问题</h2><p>今天在写样式的时候发现一个样式怎么也不显示，找了一圈发现是样式冲突了，css会优先执行优先级更高的样式。特意复习一下css中的优先级好啦~</p><h3>下面的选择器权重从小到大</h3><p>(ps: 也就是越往下越会优先执行）</p><ul>    <li>继承 或者通配符选择器*</li>    <li>元素选择器  e.g. p {}</li>    <li>类选择器，伪类选择器  e.g.  .para{}  .nav:hover{}</li>    <li>ID选择器  e.g.  #customid {}</li>    <li>行内样式 style=""</li>    <li>在属性值后面加!important</li></ul></ul><p><strong>在使用复合选择器的时候，要注意权重的叠加计算</strong></p>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css文字对齐</title>
    <link href="/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="css文字对齐包括水平对齐和垂直对齐"><a href="#css文字对齐包括水平对齐和垂直对齐" class="headerlink" title="css文字对齐包括水平对齐和垂直对齐"></a>css文字对齐包括水平对齐和垂直对齐</h2><ol><li><p>水平对齐  <strong>text-align</strong></p><p>text-align属性默认值是left，也就是靠左侧对齐文字，如果想水平方向居中显示，则需要对元素的样式设置text-align: center</p></li><li><p>垂直对齐  <strong>line-height &#x3D; height</strong></p><p>在css中没有相对应的属性可以设置文字垂直居中，但是一个小trick就是使这一行文字的line-height等于设置的盒子高度height。</p><p>解释：因为line-height行高除了内容本身的高度以外还有上间距和下间距，可以看下面的图配合食用~</p><p>配图说明：<img title="line-height组成" src="/img/lineheight.jpg"/></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2023/05/12/my-first-blog/"/>
    <url>/2023/05/12/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>##This is my first blog and try it here!!</p>]]></content>
    
    
    
    <tags>
      
      <tag>try</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
