<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机网络Chap5-传输层</title>
    <link href="/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap5-%E4%BC%A0%E8%BE%93%E5%B1%82/"/>
    <url>/2023/08/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap5-%E4%BC%A0%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2>1. 运输层协议概述</h2><h3>1.1 网络层提供的两种服务</h3><p><strong>传输层</strong>向上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。</p><p><mark>只有位于网络边缘部分的主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下面三层的功能</mark>。</p><p><img src="/img/%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1.png" alt="进程之间的通信"></p><p>我们知道IP协议可以把源主机A发送出的分组，按照首部中的目的地址交付给主机B，那么为什么还需要传输层呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><p><span class="red">对于IP层来说，通信的两端是两台<strong>主机</strong></span>。</p><p>虽然IP协议能把分组送到目的主机，但分组还停留在主机的网络层，没有交付到主机中的应用进程。</p><p>但是真正进行通信的实体是<strong>主机中的应用进程</strong>，应该是一台主机中的应用进程和另一台主机中的应用进程在交换数据。</p><p><span class="red">对于传输层来说，通信的两端是<strong>应用进程AP</strong></span>（Application procedure）。且经常是一台主机中的多个应用进程和另一台主机中的多个应用进程进行通信。</p><p><i class="fa-solid fa-arrow-down"></i></p><p><strong>运输层的功能</strong>：<mark>复用和分用</mark>。（可以想象一个公司的收发室的功能）</p><ul><li>复用：发送方不同的应用进程都可以用同一个运输层协议传送数据</li><li>分用：当接收方的运输层在剥去报文首部后能将数据正确交付目的应用进程</li></ul><p>所以<strong>运输层提供应用进程间的逻辑通信</strong>。它向高层用户屏蔽了下面网络核心的细节，使应用进程看见的就好像在两个传输层实体中间有条端到端的逻辑通信信道。</p><p>但是这条逻辑通信信道对上层的表现却因传输层使用的不同的协议而有很大差异。</p><p><i class="fa-solid fa-arrow-down"></i></p><h3>1.2 运输层的两个主要协议</h3><p>根据应用程序的不同需求，运输层有两种不同的运输协议：</p><ul><li><mark>面向连接的TCP协议</mark>：传输控制协议TCP（Transmission Control Protocol），尽管下面的网络是不可靠的，但这种逻辑通信信道就相当于一条<strong>全双工的可靠信道</strong></li><li><mark>无连接的UDP协议</mark>：用户数据报协议UDP（ User Datagram Protocol），这种逻辑通信信道仍然是一条<strong>不可靠信道</strong></li></ul><p>在OSI中，两个对等的运输实体在通信时传送的数据单位叫<strong>运输协议数据单元TPDU</strong>，但是在TCP&#x2F;IP体系中，根据所使用的协议的不同，分别称为<strong>TCP报文段</strong>或<strong>UDP报文&#x2F;用户数据报</strong></p><p>UDP和TCP的比较：</p><p><img src="/img/UDPTCP.png" alt="UDPorTCP"></p><p><u>TCP面向连接</u>：在传送数据之前必须先建立连接，等数据传送结束后释放连接。</p><p><u>UDP无连接</u>：传送数据前不需要建立连接，目的主机收到UDP报文后也不需要给出确认。</p><hr><p>使用UDP和TCP的典型应用和应用层协议</p><p><img src="/img/%E5%85%B8%E5%9E%8B%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%BA%94%E7%94%A8.png" alt="使用UDP和TCP的典型应用和应用层协议"></p><h3>1.3 运输层的端口</h3><p>在单个计算机中的进程是用进程标识符来标志的，但是在互联网上使用的计算机的操作系统种类很多且都有不同格式的进程标识符。</p><p><i class="fa-solid fa-arrow-down"></i></p><p><strong>为了使不同操作系统的计算机的应用进程都能够互相通信</strong>，就有了在运输层使用<mark>协议端口号（端口）</mark>来标志本计算机应用层中的各进程。</p><p>端口号<strong>仅在本地有意义</strong>，不同计算机的相同端口号都是没有联系的。（16位 ）</p><p><mark>所以，两个计算机中的进程互相通信，不仅需要知道对方的IP地址（找到目的主机），还需要知道端口号（找到目的进程）</mark>。</p><p>因为互联上的计算机通信是客户-服务器方式。</p><p>所以运输层的端口号分为以下两类：</p><ul><li>服务器端使用的端口号：<ul><li>熟知端口号（全球通用端口号）：0-1023</li><li>登记端口号：1024 - 49151</li></ul></li><li>客户端使用的端口号：短暂端口号， 49152 - 65535</li></ul><h2>2. 用户数据报协议UDP</h2><h3>2.1 UDP概述</h3><p><span class="red">用户数据报协议UDP只在IP的数据报服务上增加了很少的一点功能</span>：</p><ul><li><mark>复用和分用</mark></li><li><mark>差错检测</mark></li></ul><hr><p><strong>UDP的主要特点</strong>：</p><ul><li>无连接</li><li>UDP使用尽最大努力交付</li><li>面向报文：对应用层交下来的报文既不合并也不拆分。一次交付一个完整的报文。也就是说应用层交给UDP多长的报文，UDP就照样发送，一次发送一个报文</li><li>没有拥塞控制</li><li>UDP支持一对一、一对多、多对一和多对多的交互通信</li><li>首部开销小：只有8字节（TCP20字节）</li></ul><h3>2.2 UDP的首部格式</h3><p><span class="red">用户数据报UDP有两个字段</span>：数据字段和首部字段。</p><p><img src="/img/UDP%E9%A6%96%E9%83%A8.png" alt="UDP"></p><p>其中，首部字段又有4个字段组成：</p><ul><li>源端口：需要回信时选用，不需要可全0</li><li>目的端口</li><li>长度：整个UDP用户数据报的长度，最小位8（只有首部）</li><li>校验和：检验UDP用户数据报在传输中有没有错</li></ul><h2>3. 传输控制协议TCP概述</h2><h3>3.1 TCP最主要的特点</h3><ul><li><p>TCP是面向连接的运输层协议</p></li><li><p>每一条TCP连接只能有两个端点，也就是每一条TCP连接只能是点对点的</p></li><li><p>TCP提供可靠交付</p></li><li><p>TCP提供全双工通信</p></li><li><p>面向字节流：虽然应用程序和TCP交互式一次一个数据块，但TCP把应用程序交下来的数据看成仅仅式一连串无结构的字节流。</p><p><img src="/img/TCP%E9%9D%A2%E5%90%91%E5%AD%97%E8%8A%82%E6%B5%81.png" alt="TCP面向字节流"></p></li></ul><p>可以看出<mark>TCP和UDP在发送报文时所采用的方式完全不同</mark>。</p><p><span class="red">TCP并不关心应用进程一次把多长的报文发送到TCP缓存中，而是根据对方给出的窗口值和当前网络的拥塞程度，来决定一个报文段应该包含多少个字节（而UDP发送的报文的长度则是由应用进程给出的）</span>。如果应用进程给TCP缓存的数据块太长，TCP就可把它换分为短一点的数据块再传送；如果应用程序一次只发来一个字节，那么TCP也可以等待积累足够多的字节再构成报文段发送。</p><h3>3.2 TCP的连接</h3><p>上面说到每一条TCP连接有两个端点，那么连接的端点式什么呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><p><mark>TCP连接的端点是：<span class="red">套接字</span>（插口）</mark>。</p><p><span class="red">套接字就是端口号拼接到IP地址</span>。socket &#x3D; （IP地址：端口号）  e.g.  192.169.1.20:2028</p><h2>4. 可靠传输的工作原理</h2><p>TCP发送的报文段是交给下面的IP层传送的，但是IP层只能提供尽最大努力服务，也就是TCP下面的网络所提供的是不可靠的传输。</p><p>因此，TCP必须采用<u>适当的措施</u>才能使得两个运输层之间的通信变得可靠。</p><h3>4.1 停止等待协议</h3><p><strong>停止等待</strong>：<span class="red">每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组</span>。</p><ol><li><p>无差错的情况下：</p><p><img src="/img/%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E6%97%A0%E5%B7%AE%E9%94%99.png" alt="示意图"></p><p>A发送分组M1，发送后就暂停等待B的确认。B收到了M1就向A发送确认，A收到了M1的确认后就再发送M2。</p></li><li><p>出现差错：</p><p><u>在接收方B这里会出现两种情况的差错</u>：</p><ul><li>B接收M1时检测出了差错：丢弃M1，其他什么都不做</li><li>M1在传输过程中丢失了：B什么都不知道也什么都不做</li></ul><p>这两种情况下B都不会发送任何信息，那么为了实现可靠传输，就设计了<span class="red">超时重传</span>。</p><p><strong>超时重传</strong>：A在每发送一个分组时设置一个超时计时器，超过了这个时间没有收到确认就需要重传前面发过的分组M1</p><p><u>在发送方A这里会出现两种情况的差错</u>：</p><ul><li><p>B发送的对M1的确认丢失了：这时A在超时重传的时间内并没有收到确认，并不知道是自己的分组出错？丢失？还是B的确认丢失？这时就要重传M1。</p><p>此时，对于B来讲，应该丢弃这个重复的分组M1并且向A发送确认</p></li><li><p>传输过程中没有差错，但B对M1的确认超时了：A会收到重复的确认，直接丢弃</p></li></ul></li></ol><p>发送方A最终总是可以收到对所有发出的分组的确认。使用上述的确认和重传机制，我们就可以在不可靠传输的网络上实现可靠的通信。</p><p>像上述这种的<strong>可靠传输协议</strong>通常称为<strong>自动重传请求ARQ</strong>（Automatic Repeat reQuest），自动的意思是：重传这种行为是自动进行的，而不需要请求发送方重传某个出错的分组。</p><p><span class="red">停止等待协议的优点是简单，缺点是信道利用率太低了</span></p><p>那么为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用<strong>流水线传输</strong>。</p><p><img src="/img/%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%BC%A0%E8%BE%93.png" alt="流水线传输"></p><p><mark>当使用流水线传输时，就要用到连续ARQ协议和滑动窗口协议了</mark>。其中滑动窗口协议很复杂且是TCP协议的精髓。</p><h3>4.2 连续ARQ协议</h3><p><img src="/img/%E8%BF%9E%E7%BB%ADARQ.png" alt="连续ARQ协议"></p><p><strong>发送窗口</strong>：位于发送窗口内的分组都可以连续的发送出去，不需要对方的确认。这样信道利用率就提高了。</p><p>连续ARQ协议规定发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置；接收方一般采用<strong>累积确认</strong>的方式，也就是说在收到几个分组后对按序到达的最后一个分组发送确认来表示前面的分组都正确收到。如果中间的分组丢失了，接收方只能对前几个分组发出确认，发送方只能将后面n个再次重传，这就是<strong>回退N</strong>方法。</p><hr><p><img src="/img/%E8%BF%9E%E7%BB%ADARQ%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%81%9C%E6%AD%A2%E7%AD%89%E5%BE%85%E5%8D%8F%E8%AE%AE.png" alt="连续ARQ协议和停止等待协议"></p><h2>5. TCP报文段的首部格式</h2><p>TCP报文段分为首部和数据两部分，而<mark>TCP的全部功能都体现在它首部中各字段的作用</mark>。</p><p>所以只有掌握TCP首部各字段的作用才能掌握TCP的工作原理。</p><p><span class="red">TCP报文段首部的前20个字节是固定的</span>。后面4n个字节是根据需要而添加的选项，所以TCP首部最小长度是20字节。</p><p><img src="/img/TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8.png" alt="TCP报文段首部"></p><ul><li><strong>源端口和目的端口</strong>：各占2字节，和UDP分用相似，TCP的分用功能也是通过端口实现的。</li><li><strong>序号</strong>：4字节，TCP连接中传送的数据流中每一个字节都是编号的。序号是指本报文段所发送的数据的<strong>第一个字节的序号</strong>。</li><li><strong>确认号</strong>：4字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li><strong>数据偏移</strong>：4位，是指TCP报文段中的数据的起始位置距离TCP报文段的起始位置有多远，也就是<strong>首部长度</strong>。</li><li><strong>保留</strong>：6位</li><li><strong>六个控制位</strong>：<ul><li>紧急URG：URG&#x3D;1时表示紧急指针字段有效</li><li>确认ACK：ACK&#x3D;1时确认号字段有效</li><li>推送PSH：当TCP收到PSH&#x3D;1的报文段，就尽快的交付应用进程。</li><li>复位RST：RST&#x3D;1时表示TCP连接中出现严重差错必须释放连接再重新连接</li><li>同步SYN：SYN&#x3D;1表示这是一个连接请求或连接接收</li><li>终止FIN：FIN&#x3D;1表示发送端数据发送完毕，要求释放运输连接</li></ul></li><li><strong>窗口</strong>：2字节，指的是<strong>接收窗口</strong>，用来让对方设置其发送窗口的依据。窗口字段明确指出了现在允许对方发送的数据量，且动态变化</li><li><strong>检验和</strong>：2字节，检验的范围包括首部和数据部分。和UDP一样，要在报文段前加上12字节的伪首部（仅为了计算校验和）</li><li><strong>紧急指针</strong>：16位，指出紧急数据有多少字节</li><li><strong>选项</strong>：长度可变</li></ul><h2>6. TCP可靠传输的实现</h2><h3>6.1 以字节为单位的滑动窗口</h3><p>TCP的滑动窗口是以字节为单位的。</p><p><strong>发送窗口表示</strong>：</p><h3>6.2 超时重传时间的选择</h3><h3>6.3 选择确认SACK</h3><h2>7. TCP的流量控制</h2><h2>8. TCP的拥塞控制</h2><h2>9. TCP的运输连接管理</h2>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Chap4-网络层</title>
    <link href="/2023/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap4-%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2023/07/25/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap4-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2>1. 网络层的几个重要概念</h2><h3>1.1 网络层提供的两种服务</h3><p>【背景】：在计算机网络领域，网络层应该向传输层提供怎样的服务（面向连接还是无连接）曾引起长期的争论，其中争论的焦点的实质就是：<mark>在计算机通信中，可靠交付应当交给谁来负责？是网络还是端系统？</mark></p><ul><li><p>虚电路服务：（想让网络负责可靠传输观点）认为计算机网络应该模仿电信网络，使用面向连接的通信方式。在通信之前先建立<strong>虚电路</strong>以保证双方通信所需的一切网络资源；再使用可靠传输的网络协议就可以可靠传输</p><p><img src="/img/%E8%99%9A%E7%94%B5%E8%B7%AF.png" alt="虚电路服务"></p><p>但是，虚电路是指一条逻辑上的连接，分组只是都按照这条逻辑连接按照存储转发的方式传送，而不是真正的建立一条物理连接。</p></li><li><p><mark>数据报服务</mark>.：（想让端系统来负责可靠传输的观点）认为<mark>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务</mark>。网络在发送分组时不需要先建立连接，每一个分组独立发送且网络层不提供服务质量的承诺，这就让网络的造价大大降低，运行方式灵活能够适应多种应用。</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%9C%8D%E5%8A%A1.png" alt="数据报服务"></p></li></ul><h2><i class="fa-solid fa-star"></i>2. 网际协议IP</h2><p><mark>网际协议IP（Internet Protocol）是TCP&#x2F;IP体系中最主要的协议之一，也是互联网标准协议之一</mark>。</p><p>与协议IP配套使用的还有三个协议：</p><ul><li><strong>地址解析协议ARP</strong>：Address Resolution Protocol</li><li><strong>网际控制报文协议ICMP</strong>：Internet Control Message Protocol</li><li><strong>网际组管理协议IGMP</strong>：Internet Group Management Protocol</li></ul><p>这三个协议和网际协议IP的关系如图：</p><p><img src="/img/IP%E5%8D%8F%E8%AE%AE%E4%B8%8E%E9%85%8D%E5%A5%97%E5%8D%8F%E8%AE%AE.png" alt="网络层IP协议与配套协议"></p><p>ARP在最下面表示IP协议经常用它；ICMP和IGMP在上面表示他们要使用IP协议。</p><h3>2.1 网络互联的设备</h3><p><strong>中间设备</strong>：又称中间系统或者中继系统。</p><ul><li><p><strong>物理层</strong>的<strong>中继系统</strong>：转发器</p></li><li><p><strong>数据链路层</strong>的<strong>中继系统</strong>：网桥或桥接器</p></li><li><p><strong>网络层</strong>的<strong>中继系统</strong>：路由器</p></li><li><p><strong>网络层以上</strong>的<strong>中继系统</strong>：网关</p></li></ul><h3>2.2 网络互联的问题</h3><p>互联在一起的网络要进行通信会遇到很多问题：</p><p>1.不同的寻址方案</p><p>2.不同的最大分组长度</p><p>3.不同的网络接入机制</p><p>4.不同的超时控制</p><p>5.不同的差错恢复方法</p><p>6.不同的状态报告方法</p><p>7.不同的路由选择技术</p><p>8.不同的用户接入控制</p><p>9.不同的服务（面向连接服务和无连接服务）</p><p>10.不同的管理与控制方式等</p><p>所以，<strong>没有一种单一的网络可以适应所有用户的需求</strong>。</p><h3>2.3 互连网络和虚拟互连网络</h3><p><img src="/img/%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C%E5%92%8C%E8%99%9A%E6%8B%9F%E4%BA%92%E8%BF%9E%E7%BD%91%E7%BB%9C.png" alt="互连网络和虚拟互连网络"></p><p>由于参加互连的计算机网络（a）都使用<strong>相同的网际协议IP</strong>，因此可以把互连以后的计算机网络看成（b）所示的<strong>虚拟互连网络</strong>。</p><p>虚拟互连网络也就是逻辑互连，<strong>互连起来的各种物理网络的<span class="red">异构性本来是客观存在的</span></strong>,但是<mark>利用协议IP就可以使这些性能各异的网络在网络层上看起来好像是一个统一的网络</mark>。</p><p>使用协议IP的虚拟互连网络可以简称为<strong>IP网</strong>。</p><p>在IP网上的主机进行通信的时候就好像在一个单个网络上通信一样，它们看不到互连的各个网络的具体异构细节（2.2提到的）。</p><p><mark>如果在这种覆盖全球的IP网的上层使用TCP协议，就是现在的互联网</mark>。</p><h3>2.4 IP地址</h3><p>在TCP&#x2F;IP体系中，IP地址使一个最基本的概念，一个连接在互联网上的设备如果没有IP地址就无法和网上的其他设备进行通信。</p><h4>2.4.1 IP地址及其表示方法</h4><p>整个互联网就是一个<strong>单一的、抽象的</strong>网络，<strong>IP地址</strong>就是给连接到互联网上的每一台主机（或路由器）的每一个<strong>接口</strong>，分配一个全球范围内唯一的32位的标识符，就可以方便我们在互联网上寻址。</p><p>IP地址现在由<strong>互联网名字和数字分配机构ICANN</strong>（Internet Corporation for Assigned Names and Numbers）进行分配。</p><p>IP地址举例如图：</p><p><img src="/img/IP%E5%9C%B0%E5%9D%80.png" alt="IP地址"></p><p>对于<strong>主机（或者路由器）</strong>，IP地址使<strong>32位的二进制代码</strong></p><p><strong>为了提高可读性</strong>，我们常常把32位的IP地址<strong>每隔8位插入一个空格</strong></p><p><strong>为了便于人们书写和记忆</strong>，常用等效的十进制数字表示并且在每段数字中间加上一个小数点，这就是<mark><strong>点分十进制法</strong></mark></p><hr><p>上述的IP地址不但标志了这个主机（或路由器）还标志了此接口所连接的网络。所以<mark><strong>32位的IP地址采用两级结构</strong></mark>，由两个字段组成：</p><p><img src="/img/IP%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7%E5%AD%97%E6%AE%B5.jpg" alt="IP地址中的网络号和主机号字段"></p><ul><li>第一个字段是<strong>网络号</strong>：标志主机或者路由器所连接到的网络，n位</li><li>第二个字段是<strong>主机号</strong>：标志主机或路由器，剩下的（32-n）位</li></ul><p>那么很关键的问题是：<span class="red">当我们看到一个IP地址时我们怎么知道网络号的位数n是多少</span>？</p><h4>2.4.2 分类的IP地址</h4><p><span class="red">在互联网发展早期采用的是分类的IP地址，也就是上述问题中n是固定的几个数之一</span>。32位的IP地址空间总有2^32(约43亿)个地址。</p><p><img src="/img/%E5%88%86%E7%B1%BB%E7%9A%84IP%E5%9C%B0%E5%9D%80.png" alt="分类的IP地址"></p><ul><li><strong>A类地址（n &#x3D; 8）</strong>：A类地址空间有2^31个地址（除了第一位是0固定），占整个IP地址空间的50%。<ul><li>A类地址范围：1.0.0.1 -  126.255.255.254</li><li>A类地址中的私有地址：10.0.0.0到10.255.255.255，不在互联上使用，在局域网中的地址</li><li>A类地址中的保留地址：127.0.0.0 - 127.255.255.255，做循环测试用的</li></ul></li><li><strong>B类地址（n &#x3D; 16）</strong>：B类地址空间有2^30个地址（除了前两位是10固定），占整个IP地址空间的25%<ul><li>B类地址范围：128.0.0.1 - 191.255.255.254</li><li>B类地址中的私有地址：172.16.0.0 - 172.31.255.255</li><li>B类地址中的保留地址：169.254.0.0  - 169.254.255.255</li></ul></li><li><strong>C类地址（n &#x3D; 24）</strong>：C类地址空间有2^29个地址（除了前三位是110固定），占整个IP地址空间的12.5%<ul><li>C类地址范围：192.0.0.1 - 223.255.255.254</li><li>C类地址中的私有地址：192.168.0.0 - 192.168.255.255</li></ul></li><li><strong>D类地址（多播地址）</strong>：C类地址空间有2^28个地址（除了前四位是1110固定），占整个IP地址空间的6.25%</li><li><strong>E类地址（保留地址）</strong>：D类地址空间有2^28个地址（除了前四位是1111固定），占整个IP地址空间的6.25%</li></ul><hr><p><mark>常用的三种类别的IP地址</mark></p><p><img src="/img/IP%E5%9C%B0%E5%9D%80%E7%9A%84%E6%8C%87%E6%B4%BE%E8%8C%83%E5%9B%B4.png" alt="IP地址的指派范围"></p><h4>2.4.3 子网划分和子网掩码</h4><p>使用2.4.2中的分类的IP地址的空间利用率有时很低，且两级的IP地址不够灵活，故在1985年IP地址中又增加了一个“<span class="red">子网号字段</span>“，**使得两级的IP地址变成为三级的IP地址。这种做法叫<mark>划分子网</mark>。</p><p><img src="/img/%E4%B8%89%E7%BA%A7IP%E5%9C%B0%E5%9D%80.png" alt="三级IP地址"></p><p>子网号是从主机号中借用若干位，从而主机号就会相应减少若干位。</p><p><strong>问题</strong>：从一个IP数据报的首部<span class="red">无法</span>判断源主机或目的主机所连接的网络是否进行了子网划分。</p><p><i class="fa-solid fa-arrow-down"></i></p><p>引出一个概念：<mark>子网掩码</mark>，使用子网掩码就可以找出IP地址中的网络和子网部分。</p><p><mark>子网掩码的规则</mark>：</p><ul><li>子网掩码的长度为32位</li><li>子网掩码左边部分的一连串1：对应网络号和子网号</li><li>子网掩码右边部分的一连串0：对应主机号</li></ul><p><strong>子网掩码的作用</strong>: 二进制地址和二进制子网掩码做<strong>与运算</strong>,就可以得到网络地址。</p><p><img src="/img/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E7%BB%83%E4%B9%A0%E9%A2%98.png" alt="子网掩码练习题"></p><hr><p>我们知道在不划分子网的两级IP地址下，从IP地址得出网络地址是个很简单的事情。</p><p>但是在划分子网的情况下，IP地址不能唯一的得出网络地址，其取决于网络采用的子网掩码，但是<strong>数据报的首部并没有提供子网掩码的信息</strong>，所以分组转发的算法也做了相应的调整。</p><p><img src="/img/%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E4%B8%8B%E8%B7%AF%E7%94%B1%E5%99%A8%E8%BD%AC%E5%8F%91%E5%88%86%E7%BB%84%E7%AE%97%E6%B3%95.png" alt="划分子网下路由器转发分组算法"></p><h4>2.4.3 无分类编址CIDR</h4><p>虽然划分子网的方法在一定程度上减少了些地址资源的浪费，但是对于IP地址枯竭的问题，还是不够。</p><p>下面是普遍采用的无分类编址，虽然也无法解决IP地址枯竭的问题，但是可以推迟这一天的到来。</p><p><strong>无分类域间路由选择CIDR</strong>：Classless Inter-Domain Routing，取消了分类地址和划分子网的概念，可以更有效的分配IPv4的地址空间。</p><p>CIDR使用各种长度的<strong>网络前缀</strong>来代替分类地址中的网络号和子网号，所以IP地址又变回两级编址：网络前缀 + 主机号</p><p>CIDR使用斜线记法&#x2F;CIDR记法，后面跟的数字代表网络前缀的位数（相当于三级编址中子网掩码中1的个数）</p><p>使用CIDR时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。应当从匹配结果中选择具有最长网络前缀的路由：<strong>最长前缀匹配</strong>。</p><p>网络前缀越长，其地址块就越小，因而路由就越具体。最长前缀匹配又称为<strong>最长匹配</strong>或<strong>最佳匹配</strong>。</p><h4>2.4.4 IP地址的特点</h4><ul><li><span class="red">IP地址是一种分等级的地址结构</span>。这样的好处是：<ul><li>IP地址管理机构在分配IP地址时只分配网络号即可，方便IP地址的管理</li><li>路由器仅根据目的主机所连接的网络号来转发分组，而不用考虑主机号，这样就可以大幅减少路由表中的项目数，减小路由表所占的存储空间</li></ul></li><li><span class="red">实际上IP地址是标志一个主机（或路由器）和一条链路的接口</span><ul><li>当一个主机同时连接两个网络上时就必须又两个相应的IP地址</li><li>由于路由器至少应当连接到两个网络及以上（这样才能把IP数据报从一个网络转发到另一个网络），故路由器至少应当有两个IP地址</li></ul></li><li><span class="red">用转发器或网桥连接起来的若干局域网仍为一个网络，这些局域网都具有同样的网络号</span></li></ul><h4>2.4.5 IP地址与MAC硬件地址</h4><p>首先明确，<mark>IP地址和MAC地址是不同的地址！</mark></p><p><img src="/img/IP%E5%9C%B0%E5%9D%80%E4%B8%8E%E7%A1%AC%E4%BB%B6%E5%9C%B0%E5%9D%80.png" alt="IP地址与硬件地址"></p><ul><li><span class="red">从层次的角度看</span>：<ul><li>硬件地址（物理地址）是数据链路层和物理层使用的地址</li><li>IP地址是网络层和以上各层使用的地址，是一种逻辑地址</li></ul></li><li><span class="red">从添加的位置来看</span>：<ul><li>IP地址是放在IP数据报的首部</li><li>硬件地址则放在MAC数据帧的首部</li></ul></li><li><span class="red">从在通信过程中的作用来看</span>：<ul><li>IP地址决定数据包的起点和终点</li><li>MAC地址决定数据帧的下一跳是哪个设备接收</li></ul></li></ul><p>【梳理一下通信的过程】：</p><p>在发送数据时，数据从高层到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给数据链路层，就会被封装成MAC帧。MAC帧在传送时使用的源地址和目的地址都是MAC地址，且这两个MAC地址都写在MAC帧的首部中。</p><p>连接在通信链路上的设备收到MAC帧时，根据MAC帧的首部中的MAC地址决定丢弃或收下。只有在剥去MAC帧首部和尾部把MAC层数据上交给网络层后，网络层才能在IP数据报的首部中找到源IP地址和目的IP地址。</p><h3>2.5 地址解析协议ARP</h3><p>从上述2.4.5中我们知道了在通信时，会涉及到两个地址：网络层地址 - IP地址和数据链路层地址 - MAC地址。</p><p><span class="red">问题</span>：在实际应用中，无论网络层使用的什么协议，在实际网络的链路上传输数据帧时，最终还是必须使用硬件地址，那么<mark>已知一个机器（主机或者路由器）的IP地址，如何找到其相应的MAC地址？</mark></p><p><i class="fa-solid fa-arrow-down"></i></p><p><mark>地址解析协议ARP就是来解决这个问题滴~~~</mark></p><p><img src="/img/ARP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BD%9C%E7%94%A8.png" alt="ARP协议的作用"></p><h4>2.5.1 ARP协议的要点</h4><ul><li><p>每一个主机都设有一个<span class="red"><strong>ARP高速缓存</strong></span>, 里面有所在的局域网上各个主机和路由器的IP地址到硬件地址的映射表。</p></li><li><p>且ARP对保存在高速缓存中的每一个映射地址项目都设置<strong>生存时间</strong>，凡超过生存时间的项目就从高速缓存中删除。</p></li><li><p>当主机A想向<mark>本局域网上</mark>的主机B发送IP数据报时，就现在其ARP告诉缓存中查看有无B的IP地址</p></li><li><p>若有：就查出其对应的MAC地址，将该硬件地址写入MAC帧中，通过局域网将该MAC帧发往此硬件地址</p></li><li><p>若无：ARP就在本局域网上<mark>广播发送一个ARP请求分组</mark>。收到<mark>ARP响应分组</mark>后，将得到的IP地址到硬件地址的映射写入ARP高速缓存</p></li><li><p><span class="red">ARP用于解决<strong>同一个局域网</strong>上的主机或路由器的IP地址和硬件地址的映射问题</span></p><p>那么如果目的主机和源主机<u>不在一个局域网上</u>呢？</p></li></ul><p>  需要通过ARP找到一个位于本局域网上的某个路由器的硬件地址，然后将分组发送给这个路由器，再由路由器将分组转发给下一个网络，以此类推直到找到目的主机。</p><p>  由于全世界存在着各种各样的网络，他们使用不同的MAC地址，要使这些异构网络能够相互通信就必须进行非常复杂的MAC地址转换，由用户或者主机来完成是不可能的。</p><p>  但IP编址使得连接到互联网的主机只需要各自拥有一个IP地址，就使得通信像是连接在同一个网络上那样简单方便。<strong>即使需要多次调用ARP来找到MAC地址，但这个过程都是计算机软件自动进行的，对用户是看不到的</strong>。</p><h3>2.6 IP数据报的格式</h3><p><img src="/img/IP%E6%95%B0%E6%8D%AE%E6%8A%A5.png" alt="IP数据报"></p><p><span class="red">一个IP数据报由两部分组成</span>：</p><ul><li><p><span class="red">首部</span>：首部的前一部分长度固定为20字节（一行表示32位&#x3D;4字节，五行一共20字节），是所有IP数据报必须有的。后面是一些可选字段，长度可变。</p><ul><li><p>版本：4位，指IP协议的版本。通信双方使用的IP协议版本必须一致。这里讨论的版本是4（IPv4）</p></li><li><p>首部长度：4位，来指明首部有多长（固定+可变部分），最小是5个单位（5 * 4字节）&#x3D;20字节，这就全是固定部分；最大是15个单位（15*4字节）&#x3D;60字节，因为2进制的4位最大只能表示15啦~~</p></li><li><p>区分服务：8位，用来说明数据报是不是很紧急很优先</p></li><li><p>总长度：16位，这里是首部+数据的总长度，所以最大是2^16-1&#x3D;65535字节。</p><p><strong>总长度必须不超过最大传送单元MTU</strong></p></li><li><p>标识：16位，是一个计数器，用来产生IP数据报的标识。如果数据报长度超过MTU需要分片，那么标识字段就被复制到所有的数据报片的标识字段中，使得最后能被正确的重装为原来的数据报。</p></li><li><p>标志：3位，只有前两位有意义。最低位位MF（more fragment）：MF&#x3D;1表示后面还有分片；MF&#x3D;0表示最后一片；中间位是DF（don’t fragment): DF&#x3D;0时才能分片。</p></li><li><p>片偏移：13位，指出较长的分组在分片后，某片在原分组中的相对位置，且以<strong>8个字节为偏移单位</strong>。</p><p><img src="/img/%E5%81%8F%E7%A7%BB%E4%B8%BE%E4%BE%8B.png" alt="偏移举例"></p></li><li><p>生存时间：8位，TTL（Time To Live), 表示数据报在网络中<strong>可通过的路由器数的最大值</strong>。</p><p>本来单位是秒，但随着路由器处理数据报的时间逐渐缩短到小于1s，单位就改为“跳数”</p></li><li><p>协议：8位，指出此数据报携带的数据使用哪种协议，方便使目的主机的IP层直到应该将数据部分上交给哪个协议进行处理</p></li><li><p>首部校验和：16位，只检验数据报的首部，不包括数据部分</p></li><li><p>源地址：32位，发送IP数据报的主机的IP地址</p></li><li><p>目的地址：32位，接收IP数据报的主机的IP地址</p></li></ul></li><li><p><span class="red">数据</span></p></li></ul><h2>3. IP层转发分组的过程</h2><ul><li><p>基于终点的转发：分组在互联网上传送和转发是基于分组首部的<strong>目的地址</strong>的，所以分组每到一个路由器，路由器就会根据分组中的目的地址（终点）查找转发表。</p><p><u>问题</u>:  分组的首部也没有地方指明下一跳路由器的IP地址呀，那分组怎么找到下一跳路由器呢？</p><p><u>ans</u>:  当路由器接收到一个待转发的分组，在从转发表得出下一跳路由器的IP地址后，不是把这个地址写入分组的首部，而是<strong>送交数据链路层的网络接口软件</strong>，它来负责使用ARP将路由器的IP地址转换成MAC地址，并将MAC地址放在链路层的MAC帧的首部，最后利用MAC地址传送给下一跳的路由器的链路层~~</p></li><li><p>特定主机路由：虽然互联网所有的分组转发都是基于目的主机所在的网络，但是也允许有特例，为特定的目的主机指定一个路由。</p></li><li><p>默认路由：路由器还可采用默认路由以减少路由表所占用的空间和搜索路由表所用的时间，</p></li></ul><h2>4. 网际控制报文协议ICMP</h2><p>为了更有效的转发IP数据报和提高交付成功的机会，在网际层使用忘记控制报协议ICMP。</p><p>ICMP允许主机或者路由器报告差错情况和提供有关异常情况的报告。</p><p>且<mark>ICMP报文装在IP数据报的数据部分</mark>。</p><h3>4.1 ICMP报文的格式</h3><p><img src="/img/ICMP%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F.png" alt="ICMP报文格式"></p><p>ICMP报文的前四个字节是统一的格式：类型、代码、检验和。</p><p>接着4字节与ICMP的类型有关</p><h3>4.2 ICMP报文的种类</h3><ul><li><p>ICMP差错报告报文:</p><ul><li>终点不可到达 - 3</li><li>时间超过 - 11</li><li>参数问题 - 12</li><li>改变路由（重定向） - 5</li></ul><hr><p><img src="/img/ICMP%E5%B7%AE%E9%94%99%E6%8A%A5%E5%91%8A%E6%8A%A5%E6%96%87.png" alt="ICMP差错报告报文"></p></li><li><p>ICMP询问报文: </p><ul><li>回送请求或回送回答 - 8或0</li><li>时间戳请求或时间戳回答 - 13或14</li></ul></li></ul><h3>4.3 ICMP报文的应用</h3><p><mark>PING: 用来测试两个主机之间的连通性</mark>。</p><p>PING使用了ICMP回送请求与回送回答报文。且直接使用网络层ICMP，没有通过运输层的TCP或UDP。</p><h2>5. 互联网的路由选择协议</h2><p>这是用来解决<strong>转发表中的路由是怎样得出的</strong>。</p><h3>5.1 有关路由选择协议的几个基本概念</h3><h4>5.1.1 分层次的路由选择协议</h4><p>互联网采用的是<strong>分层次的路由选择协议</strong>，原因：</p><ul><li>互联网规模巨大，若想让所有路由器知道所有的网络如何到达，路由表将巨大</li><li>许多单位不愿意外界了解自己单位网络的布局细节和采用的路由选择协议，但还想连接互联网</li></ul><p><i class="fa-solid fa-arrow-down"></i></p><p>所以，使用分层次的路由选择方法，可以将整个互联网或分为许多<mark>自治系统AS</mark>（autonomous system）。</p><p><strong>自治系统</strong>：在单一的技术管理下的一组路由器，这些路由器使用一种<strong>AS内部</strong>的路由选择协议和共同的度量以确定分组在该AS内的路由，同时还使用一种<strong>AS之间</strong>的路由选择协议来确定分组在AS之间的路由。<span class="red">一个AS对其他的AS表现出的是一个单一的和一致的路由选择策略</span>。</p><p><i class="fa-solid fa-arrow-down"></i></p><p>这样，互联网就把路由选择协议划分为两大类：</p><ul><li><mark>内部网关协议IGP</mark>：Interior Gateway Protocol，在一个自治系统内部使用的路由选择协议。<span class="red">目前使用的最多的是RIP（小规模网络）和OSPF协议（大规模网络）</span>。这种在自治系统内部的路由选择叫做<strong>域内路由选择</strong></li><li><mark>外部网关协议EGP</mark>：External Gateway Protocol，在不同的自治系统之间的路由选择协议。<span class="red">目前使用的最多的BGP-4</span>。这种在自治系统之间的路由选择叫做<strong>域间路由选择</strong></li></ul><p><img src="/img/%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE.png" alt="路由选择协议"></p><h3>5.2 内部网关协议 - RIP</h3><h4>5.2.1 RIP协议的工作原理</h4><p><mark>路由信息协议RIP</mark>(Routing Information Protocol)是内部网关协议IGP中<span class="red">最先</span>得到广泛使用的协议。</p><p>RIP是一种<strong>分布式的、基于<mark>距离向量</mark>的</strong>路由选择协议。</p><p>RIP协议要求网络中的每一个路由器都要维护从自己到其他每一个网络的距离记录。所以最大的特点就是简单。</p><ul><li><p>基于距离向量的：<strong>距离</strong>是<strong>跳数</strong>，也就是经过路由器的个数，且指最短距离（最小跳数）。RIP允许一条路径最多只能包含<span class="red">15</span>个路由器。</p></li><li><p>分布式的：（分布式的特点就是各个路由器可以通过相互间的信息交互来完成路由信息的获取和更新）。所以我们会在意一下三个问题：</p><ul><li><p><u>和哪些路由器交换信息？</u></p><p>RIP规定<strong>仅和相邻路由器交换信息</strong>。</p></li><li><p><u>交换什么信息?</u></p><p>RIP规定路由器交换的信息是<strong>当前路由器所知道的全部信息，也就是自己现在的路由表</strong>，翻译一下就是”我到这个自治系统中所有网络的（最短）距离，以及到每个网络应该经过的下一跳路由器。</p></li><li><p><u>在什么时候交换信息?</u></p><p>RIP规定<strong>按固定的时间间隔交换路由信息</strong>，比如30s</p></li></ul></li></ul><h4>5.2.2 RIP使用的距离向量算法</h4><p><img src="/img/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95.png" alt="距离向量算法"></p><hr><p><img src="/img/%E8%B7%9D%E7%A6%BB%E5%90%91%E9%87%8F%E7%AE%97%E6%B3%95eg.png" alt="距离向量算法举例"></p><h4>5.2.3 RIP协议的特点</h4><ul><li>优点：实现简单，开销小</li><li>缺点：<ul><li>RIP限制网络规模，最大距离为15</li><li>随着网络规模的扩大，开销增加，因为交换的路由信息是完整的路由表</li><li>坏消息传播得慢，使得更新过程的收敛时间过长</li></ul></li></ul><h3>5.3 内部网关协议 - OSPF</h3><p>为了克服上述RIP的缺点，<mark>开放最短路径优先OSPF</mark>（Open Shortest Path First)营运而生。</p><h4>5.3.1 OSPF协议的基本特点</h4><p>OSPF也是分布式的，我们也关心三个最基本的问题：</p><ul><li><p><u>和哪些路由器交换信息？</u></p><p>OSPF规定<strong>向本自治系统中所有路由器发送信息</strong>，这就是<strong>洪泛法</strong></p></li><li><p><u>交换什么信息?</u></p><p>OSPF协议规定乐发送与本路由器相邻的所有路由器的<strong>链路状态</strong>，这只是<strong>路由器的部分信息</strong>。</p><p>链路状态：说明本路由器和那些路由器相邻，以及该链路的度量。</p></li><li><p><u>在什么时候交换信息?</u></p><p>OSPF规定<strong>当链路状态变化时交换路由信息</strong>或者隔一段时间（如30分钟）</p></li></ul><h4>5.3.2 OSPF的区域area</h4><p>为了使OSPF能够用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，叫做区域</p><h3>5.4 外部网关协议 - BGP</h3><p>在外部网关协议BGP中，现在使用的是第四个版本BGP-4。如果没有BGP，那么每一个自治系统AS都是一个孤岛，BGP使得他们可以连接成一个完整的互联网。</p><p>BGP力求能选择出一条能够到达目的网络前缀且比较好的路由，而不是计算出最佳路由。</p><p><mark>BGP采用了路径向量路由选择协议</mark>，<span class="red">与<strong>距离向量协议（如RIP）</strong>和<strong>链路状态协议（如OSPF）</strong>有很大的区别</span>。</p><h4>5.4.1 BGP路由</h4><p>在一个自治系统中，有两种不同功能的路由器：</p><ul><li>边界路由器（边界网关）</li><li>内部路由器</li></ul><p><mark>一个AS至少有一个边界路由器和相邻AS的边界路由器直接相连</mark>。正式有了边界路由器，AS之间才能利用BGP协议交换可达性路由信息。</p><p>那么两个边界路由器是如何进行路由信息的交换的呢？</p><p>首先，要先建立<strong>TCP连接</strong>，在此基础上上交换BGP报文以建立BGP会话，利用BGP会话交换路由信息</p><h2>6.虚拟专用网VPN</h2><p>由于IP地址的紧缺，一个机构能申请到的IP地址数往往远远小于本机构所拥有的主机数，且考虑到互联网并不安全，一个机构内也并不需要把所有的主机接入到外部的互联网。</p><p><i class="fa-solid fa-arrow-down"></i></p><p>假定在一个机构内部的计算机通信也是采用TCP&#x2F;IP协议，那么从原则上来讲，对于仅在机构内部使用的计算机就可以<strong>由本机构自行分配IP地址</strong>。</p><h3>6.1 本地地址与全球地址</h3><ul><li><strong>本地地址</strong>：仅在机构内部使用的IP地址，可以由本机构自行分配而不需要向互联网的管理机构申请</li><li><strong>全球地址</strong>：全球唯一的IP地址，必须向互联网的管理机构申请</li></ul><p><mark>问题</mark>：如果任意选择Ip地址作为机构内部使用的本地地址，那么很有可能和互联网中的某个IP重合。这就出现了<span class="red">地址的二义性问题</span>。</p><p><i class="fa-solid fa-arrow-down"></i></p><p>为了解决上述问题，RFC专门指明了一些<strong>专用地址</strong>，<span class="red">专用地址只能用作本地地址而不能用作全球地址，在互联网中的所有路由器，对目的地址是专有地址的数据报一律不进行转发</span>。</p><p><img src="/img/%E4%B8%93%E7%94%A8IP%E5%9C%B0%E5%9D%80%E5%9D%97.png" alt="专用IP地址块"></p><h3>6.2 专用网与虚拟专用网</h3><ul><li><p><strong>专用网</strong>： 采用专用IP地址进行互连的网络叫做专用互联网（或本地互联网），简称专用网。</p><p>全世界可能很多专用互连网络的具有相同的IP地址，但是并不会引起任何问题，故专用IP地址也称为可重用地址。</p></li></ul><p>如果一个很大的机构的很多部门分布范围很广泛，且这些部门经常需要交换信息，则可以：</p><ul><li><strong>虚拟专用网VPN</strong>：Virtual Private Network， 利用公用的互联网作为本机构各专用之间的通信载体，这样的专用网又称为虚拟专用网。<ul><li>“专用网”：因为这种网络是为本机构的主机在本机构内部的通信</li><li>“虚拟”：并没有使用真正的通信专线（租金太高啦），但是在效果上和真正的专用网一样。</li></ul></li></ul><h3>6.3 使用IP隧道技术实现虚拟专用网VPN</h3><p>背景：某个机构在两个相隔很远的场所建立了专用网A和B，现在需要通过公用的互联网构成一个VPN。</p><ul><li>如果专用网不同网点之间的通信必须经过公用的互联网，但是又有保密的要求，那么<strong>所有通过互联网传送的数据必须加密</strong></li><li>一个机构要构建自己的VPN，就必须为它的每一个场所购买专门的硬件和软件，并进行配置，使每一个场所的VPN系统都知道其他场所的地址。</li></ul><hr><p><img src="/img/IP%E9%9A%A7%E9%81%93%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0VPN.png" alt="IP隧道技术实现VPN"></p><p>首先，每一个场所至少要有一个路由器具有合法的全球IP地址（R1，R2），<mark>他们与互联网的接口地址是合法的全球IP地址，在专用网内部网络的接口地址就是专用网的本地地址</mark>。</p><p>其次，在每一个场所A或者B内部的通信都是不经过互联网的。</p><p>现在场所A的主机X要和另一个场所B的主机Y进行通信，则需要经过路由器R1和R2。</p><ul><li>主机X向主机Y发送的IP数据报的<strong>源地址</strong>是10.1.0.1，<strong>目的地址</strong>是10.2.0.3(<mark>本地地址</mark>)</li><li>数据报先作为<u>机构内部数据报</u>从X发送到与互联网连接的路由器R1</li><li>R1收到内部数据报后发现需要经过互联网才能到达，<span class="red">就把整个的内部数据报进行<mark>加密</mark></span>，再重新加上数据报的首部，封装成在互联网发送的外部数据报，此时，<strong>源地址</strong>是125.1.2.3，<strong>目的地址</strong>是194.4.5.6（<mark>全球地址</mark>）</li><li>R2收到数据报后将数据部分取出进行解密，恢复出原来的内部数据报（目的地址10.2.0.3)，交付主机Y</li></ul><p>虽然外部数据报从R1到R2可能要经过互联网上许多个网络和路由器，但是从逻辑上看，R1到R2之间好像是一条直通的点对点的链路，故叫“IP隧道技术”。</p><h3>6.4 内联网intranet和外联网extranet</h3><p>上述例子中的，由场所A和B的内部网络所构成的虚拟专用网VPN称为<strong>内联网</strong>（intranet或intranetVPN），表示场所A和B属于一个机构。</p><p>有时一个机构的VPN需要有些外部机构参加进来，这样的VPN称为<strong>外联网</strong>（extranent或extranetVPN）。</p><p>内联网和外联网都采用了互联网技术，都是基于TCP&#x2F;IP协议的。</p><h3>6.5 远程接入VPN</h3><p>在外地的员工通过拨号接入互联网，驻留在员工个人电脑中的VPN软件可以在员工个人电脑和公司主机之间建立VPN隧道且通信内容是保密的，感觉就像使用公司内部的本地网络一样。</p><h2>7.网络地址转换NAT</h2><p>问题：在专用网内部的一些主机本来已经分配到了本地IP地址，但是现在又想和互联网上的主机进行通信（且不需要加密），怎么办呢？</p><p>最简单的办法就是再申请全球IP地址，但是这很难做到！！</p><p><i class="fa-solid fa-arrow-down"></i></p><p><span class="red">目前使用的最多的就是<strong>网络地址转换</strong></span>。</p><h3>7.1 网络地址转换NAT简介</h3><p><strong>网络地址转换NAT</strong>：Network Address Translation, 需要再专用网连接到互联网上的路由器安装NAT软件。装有NAT软件的路由器称为<strong>NAT路由器</strong>，它至少有一个有效的外部全球IP地址。</p><p>那么所有本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和互联网连接。</p><h3>7.2 网络地址转换的过程</h3><p><img src="/img/NAT%E8%BF%87%E7%A8%8B.png" alt="NAT过程"></p><ul><li>主机A用本地地址IPA和互联网上的主机B通信所发的数据报必须经过<strong>NAT路由器</strong></li><li>NAT路由器将<strong>数据报的源地址IPA转换成全球地址IPGA</strong>，改写到数据报的首部作为新的源地址，并将转换的结果记录到<strong>NAT地址转换表</strong>中。将新的数据报转发出去。</li><li>主机B收到IP数据报后返回应答。源地址就是自己的地址IPGB，目的地址是刚才收到的数据报的源地址IPGA。此时B并不知道A的专用地址，且就算知道了也不能使用（互联网上的路由器不能转发目的地址为任何专用地址的IP数据报！）。</li><li>NAT路由器收到主机B返回的IP数据报时，<strong>再次进行地址的转换</strong>，通过NAT转换表将收到的IP地址IPGA转换为专用网内部的目的地址IPA，将最后的数据报发送给A。</li></ul><h3>7.3 网络地址与端口号转换NAPT</h3><p>那么我们还能不能更有效的利用NAT路由器上的全球IP地址呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><p>现在常用的NAT转换表把<span class="red">运输层的端口号也利用上</span>。</p><p>这样，就可以使多个拥有本地地址的主机，公用NAT路由器上的一个全球IP地址，因而可以同时和互联网上的不用主机进行通信！！！</p><p><strong>使用端口号的NAT</strong>也叫做<strong>网络地址与端口号转换NAPT</strong>（Network Address and Port Translation）。</p><p>不使用端口号的NAT就叫做传统的NAT</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防抖与节流</title>
    <link href="/2023/07/24/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/"/>
    <url>/2023/07/24/%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2><i class="fa-solid fa-thumbtack"></i>函数的防抖与节流</h2><p><mark>重要！重要！重要！（重要的事情说三遍！！！</mark><i class="fa-solid fa-face-grin-tears"></i></p><h3>1. 问题引入 - 卡顿现象</h3><p>由于用户操作过快，且每一次的触发，回调函数都需去执行，这时候如果事件很短且回调函数内部有计算，很有可能出现浏览器<mark>卡顿</mark>现象的出现。</p><p>【解决办法：<i class="fa-solid fa-arrow-down"></i>】</p><h3>2. 防抖</h3><p><mark>防抖</mark>：<span class="red">前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发。</span>也就是说<mark>如果连续快速的触发，只会执行一次</mark>。</p><h4>2.1 轻量三方库<span class="red">Lodash</span>实现防抖</h4><p>下载并引入lodash.js，注意lodash.js向外暴露的是一个下划线_。</p><p><mark>_.debounce(func,[wait&#x3D;0],[options&#x3D;])</mark>防抖函数</p><p>注意这个的返回值是个函数，需要用变量接收然后再调用~</p><p><img src="/img/%E9%98%B2%E6%8A%96lodash.png" alt="code"></p><h4>2.2 原生js实现防抖</h4><h3>3. 节流</h3><p><mark>节流</mark>：<span class="red">在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调</span>。也就是说<mark>把频繁触发变为少量触发</mark>。</p><h4>3.1 轻量三方库<span class="red">Lodash</span>实现节流</h4><p><mark>_.throttle(func,[wait&#x3D;0],[options&#x3D;])</mark>节流函数</p><p><img src="/img/%E8%8A%82%E6%B5%81lodash.png" alt="code"></p><h4>3.2 原生js实现节流</h4><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Chap3-数据链路层</title>
    <link href="/2023/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2023/07/24/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2>1. 数据链路层基本概念</h2><h3>1.1 数据链路层使用的信道类型</h3><p><img src="/img/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%BF%A1%E9%81%93.png" alt="数据链路层信道"></p><ul><li>点到点信道：一对一的通信</li><li>广播信道：一对多的通信，必须使用专用的共享信道协议来协调这些主机的数据发送。</li></ul><h3>1.2 链路以及数据链路</h3><ul><li><p>链路：link，从一个节点到相邻节点的一段物理线路，<span class="red">中间没有任何其他的交换节点</span>。</p><p>一条链路知识一条通路的一个组成部分。</p><p><mark>但是</mark>，当需要在一条线路上传送数据的时候，除了必须的物理线路（链路）外，还必须有一些必要的<span class="red">通信协议</span>来控制数据的传输。</p><p><i class="fa-solid fa-arrow-down"></i></p></li><li><p>数据链路：data link，若把实现上述协议的硬件和软件加到链路上，就构成了数据链路。</p><p>最常用的方法就是使用<span class="red">适配器</span>（网卡）来实现协议的硬件和软件。</p></li></ul><h3>1.3 帧</h3><p><mark>帧</mark>：数据链路层的协议数据单</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E5%B8%A7.png" alt="三层简化模型"></p><p>数据链路层在进行通信的时候主要步骤（不考虑物理层的细节，设想好像是水平方向）：</p><ul><li>节点A的数据链路层把网络层交下来的IP数据报添加<span class="red"><strong>首部和尾部</strong></span>封装成帧</li><li>节点A把封装好的帧发送给节点B的数据链路层</li><li>若节点B的数据链路层收到帧，则从帧中提取IP数据报交付给上面的网络层</li></ul><h2>2. 数据链路层基本问题</h2><p>数据链路层协议有多种，但是又三个基本问题是共同的。</p><h3>2.1 封装成帧</h3><p><img src="/img/%E5%B0%81%E8%A3%85%E6%88%90%E5%B8%A7.png" alt="封装成帧"></p><p><strong>封装成帧</strong> (framing)就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。</p><p>首部和尾部的一个重要作用就是进行<strong>帧定界</strong>。</p><p>且每一种链路层协议都规定了所能传输的<strong>帧的数据部分长度上限—最大传送单元MTU</strong>。</p><p>【思考：为什么要加这个首部和尾部呢？】</p><p>设想，在发送端尚未发送完一个帧时突然出现故障，中断了发送，当恢复正常时重新从头开始发送这个帧。由于使用了帧定界符，接收端就会知道刚才前面的是不完整帧（只有首部开始符号SOH而没有传输结束符EOT）则必须丢弃。去接收下一个帧。</p><h3>2.2 透明传输</h3><p><strong>透明</strong>：就是指一个实际存在的事物看起来却好像不存在一样</p><p><strong>透明传输</strong>：在链路层透明传输数据就是表示无论传输什么样的数据，这些数据都能按照原来的样子无差错的通过数据链路层进行传输。也就是说对于数据来讲，数据链路层是透明的。</p><p><i class="fa-solid fa-arrow-down"></i></p><ul><li><p><i class="fa-solid fa-check"></i>当传送的帧的数据部分是文本文件（从键盘输入的），数据部分肯定不会出现SOH或EOT这样的帧定界控制字符（规定使用不可打印字符），所以不管从键盘输入什么字符都可以放在帧中传输，这样的传输就是透明传输</p></li><li><p><i class="fa-solid fa-xmark"></i>但是如果当传送的数据是非ASCII码的文件时，若其中某个字节的二进制编码恰好和SOH或者EOT控制字符一样，数据链路层就会错误的找到帧的边界，把部分帧手下，将剩下的数据丢弃。显然这就不是透明传输。</p><p><img src="/img/%E4%B8%8D%E9%80%8F%E6%98%8E%E4%BC%A0%E8%BE%93%E9%97%AE%E9%A2%98.png" alt="问题"></p><p><i class="fa-solid fa-arrow-down"></i></p><p><i class="fa-solid fa-wrench"></i>解决办法：为了解决这种情况下的透明传输的问题，就必须设法使数据中可能出现的控制字符SOH或EOT在接收端不被解释为控制字符。想起编程中的<mark>转义字符</mark>。</p><p><mark>字节（字符）填充</mark>：就是在发送端的数据链路层中出现SOH或者EOT的前面加上一个转义字符ESC，接收端的数据链路层在数据送往网络层之前删除这个转移字符。故用字节填充的办法解决透明传输的问题。</p><p><img src="/img/%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85.png" alt="字节填充实现透明传输"></p></li></ul><h3>2.3 差错检测</h3><p><strong>比特差错</strong> ： 现实的通信链路都不会是理想的，比特在传输过程成可能会出现差错：1 -&gt; 0  &#x2F;  0 -&gt; 1。</p><p><strong>误码率</strong>： 在一段时间内，传输错误的比特占所传输的比特总数的比率。</p><p>那么为了保证数据传输的可靠性，在传输数据时，必须采用各种<strong>差错检测措施</strong>，<mark>目前在数据链路层广泛使用的差错检测措施为<strong>循环冗余检验CRC</strong></mark></p><p><i class="fa-solid fa-arrow-down"></i></p><p>使用CRC可以做到<mark>无差错接受</mark>，也就是凡是接受的帧（也就是不包括丢弃的帧）都能以非常接近于1的概率认为传输中没差错。</p><p>但是单纯的使用CRC<mark>无法做到</mark><mark>无差错传输</mark>(发送什么就接收到什么)，还必须加上确认和重传机制。</p><p>所以这一章的数据链路层协议都是不可靠传输的协议。</p><h2>3. 两种情况下的数据链路层</h2><h3>3.1 使用点对点信道的数据链路层</h3><p>对于<span class="red">点对点</span>的链路，<mark>目前使用最广泛的数据链路层协议是点对点协议PPP</mark>（Point-to-Point Protocol）。</p><p>PPP协议帧的格式如下图：</p><p><img src="/img/PPP.png" alt="PPP协议帧格式"></p><h3>3.2 使用广播信道的数据链路层</h3><p>广播信道可以进行一对多的通信，且局域网使用的就是广播信道。</p><p><mark>以太网采用的协议是CSMA&#x2F;CD</mark>(Carrier Sense Multiple Access with Collision Detection)载波监听多点接入&#x2F;碰撞检测。</p><h4>3.2.1 局域网的数据链路层</h4><p><strong>局域网的特点</strong>：网络为一个单位所拥有，地理范围和站点数据有限。</p><h4>3.2.2 共享信道</h4><p>共享信道要着重考虑的问题是如何使众多用户能够合理而方便的共享通信媒体资源。方法如下：</p><ul><li><p>静态划分信道：如频分复用、时分复用等等</p></li><li><p><strong>动态媒体接入控制（多点接入）</strong>：信道并非在用户通信时固定分配给用户</p><ul><li><p>受控接入</p></li><li><p><strong>随机接入（<mark>主要被以太网采用</mark>）</strong>：所有的用户都可随机的发送消息，如果恰巧两个或多个用户在同一时刻发送消息，那么在共享媒体上就要产生碰撞，因此必须要又解决碰撞的网络协议。</p></li></ul></li></ul><h3>3.3 CSMA/CD协议</h4><p>多点接入：总线型网络。</p><p>协议的实质是载波监听、碰撞检测。</p><p>载波监听：边发送边监听。</p><p>碰撞检测：在发送中检测信道，就即使发现如果有其他站也在发送就立即中断本站的发送。</p><h2>4. 以太局域网（以太网）</h2><h3>4.1 以太网的两个标准</h3><ul><li>DIX Ethernet V2：世界上第一个局域网产品（以太网）的规约。</li><li>IEEE 802.3：第一个 IEEE的以太网标准。</li></ul><p><strong>DIX Ethernet V2</strong> <strong>标准与</strong> <strong>IEEE</strong> <strong>的</strong> <strong>802.3</strong> <strong>标准只有很小的差别，因此可以将</strong> <strong>802.3</strong> <strong>局域网简称为“以太网”。</strong></p><p><strong>严格说来，“以太网”应当是指符合</strong> <strong>DIX Ethernet V2</strong> <strong>标准的局域网 。</strong></p><h3>4.2 数据链路层的两个子层</h3><p><mark>为了使数据链路层能更好的适应多种局域网标准</mark>，IEEE802委员会将局域网的数据链路层拆成两个子层：</p><p><img src="/img/%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82%E4%B8%A4%E4%B8%AA%E5%AD%90%E5%B1%82.png" alt="detail"></p><ul><li><mark><del>逻辑链路控制LLC</del></mark>（Logical Link Control）子层：无论哪种协议的局域网对LLC子层都是透明的，且由于目前使用的最多的局域网是DIX Ethernet V2（以太网）,故802委员会指定的LLC层作用不大了，且很多厂商生产的适配器上都没有LLC协议了，<u>故一般都不考虑本层了</u>。</li><li><mark>媒体接入控制MAC</mark>（Medium Access Control）子层:<strong>与接入到传输媒体有关的内容都放在</strong> <strong>MAC子层</strong></li></ul><h3>4.3 以太网的MAC层</h3><h4>4.3.1 MAC层的硬件地址</h4><p><strong><span class="red">MAC地址</span><strong>：在局域网中，</strong>硬件地址</strong>又称为<strong>物理地址</strong>或者<strong>MAC地址</strong>（因为这种地址会被用在MAC帧中）。MAC地址用于在网络中<strong>唯一</strong>标识一个网卡（也叫网络适配器）。</p><p>MAC地址一般是<mark>48位（6个字节）</mark>组成，前面24位(高位24位)为了标识厂家，称为<strong>组织唯一标识符</strong>，后24位(低位24位)厂家自己指定，称为<strong>扩展唯一标识符</strong>。通常采用<strong>十六进制数</strong>表示每个字节。</p><h4>4.3.2 MAC帧的格式</h4><p><img src="/img/MAC%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="MAC帧格式"></p><h2>5. 扩展以太网</h2><p>很多情况下我们希望把以太网的覆盖范围扩展。</p><h3>5.1 在物理层扩展以太网</h3><ul><li>使用光纤扩展</li><li>使用集线器扩展</li></ul><h3>5.2 在数据链路层扩展以太网</h3><ul><li>使用网桥（早期）</li><li>使用以太网交换机（现在）</li></ul><h2>6. 高速以太网</h2><p>速率达到或超过<strong>100 Mbit&#x2F;s</strong>的以太网称为<strong>高速以太网</strong>。</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vuex的基本使用</title>
    <link href="/2023/07/21/vuex%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/07/21/vuex%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2>1. 使用vuex的背景</h2><p>我们在小的项目（组件少且关系简单）可以通过父子组件props、兄弟组件eventbus等方法进行传参，但是如果一个比较庞大的项目会有上百个组件且他们之间的关系错综复杂，那么我们就需要一个管家。</p><h2>2. vuex概念</h2><p><mark>vuex: </mark> vue官方提供的<mark>状态管理插件</mark>，采用<mark>集中式存储</mark>管理应用的所有组件的状态，解决多组件间的数据通信。</p><p><i class="fa-solid fa-hippo"></i>可以想象成一个共享的大仓库，哪个组件想要拿数据就直接去仓库拿就行。</p><h2>3. vuex的基本使用</h2><h3>3.1 vuex的安装</h3><p>vue2.x可以安装3.2.0版本适配~</p><h3>3.2 vuex的配置</h3><p>一般会在<mark>src-&gt;store-&gt;index.js</mark>中配置vuex相关属性。</p><p>可以类比另一个vue官方提供的专门做路由的插件vue-router的使用</p><ul><li>先导入Vue和Vuex</li><li>使用Vue.use(Vuex)注册为插件，使用一次</li><li>向外暴露</li><li>在入口文件中导入并挂载，<span class="red">此时所有的组件都会带有$.store属性</span>。</li></ul><p><img src="/img/vuex%E9%85%8D%E7%BD%AE.png" alt="配置"></p><h3>3.3 vuex的使用</h3><ul><li><mark>在任何组件中，通过this.$store.state.属性名才获取公共数据</mark>，公共数据在配置对象的state对象中定义</li><li><mark>在任何组件中，通过this.$store.commit(‘mutation事件名’, mapper参数)修改state里的数据</mark>，公共数据的修改函数在mutations中定义</li><li><mark>在任何组件中，通过this.$store.getters.属性名来获取getters派生后的值</mark>，getters就可以类比计算属性</li></ul><p>上面都是修改和定义数据，但是如果我们想从服务器发起请求拿数据的时候，我们就不可避免的要发<span class="red">异步请求</span>获取数据。</p><ul><li><mark>在任何组件中，通过this.$store.dispatch(‘actions的名字’，参数)调用action</mark>，</li></ul><p><img src="/img/vuex.png" alt="code"></p><h2>4. vuex的进阶 - 辅助函数的使用</h2><p>根据上述vuex的介绍和操作，我们知道有了vuex，不需要再考虑不同关系组件间的数据传递，可以直接通过$store进行获取数据。</p><p>那么：如何将state中的count数据定义在组件内的计算属性中？</p><ul><li><p>法一：computed：{count() {return this.$store.state.count}}</p><p>虽然this.$store.state可以很方便的把state中的数据融入computed，但如果要融入多个就会出现代码冗余的情况。</p><p><i class="fa-solid fa-arrow-down"></i></p></li><li><p>法二：<mark>mapState辅助函数</mark>，vuex提供的更简便的办法</p><p>import {mapState} from ‘vuex’</p><p>expoer default {</p><p>​computed: mapState([‘count1’, ‘count2’, …])}&#x2F;&#x2F;填了那些就会自动映射为一个计算属性</p><p>这样写的问题：如果这个组件本身有自己的计算属性，那么这样写的话就会覆盖</p><p><i class="fa-solid fa-arrow-down"></i></p><p><mark>使用es6语法中的展开运算符</mark></p><p>computed: {</p><p>​xxx,</p><p>​…mapState([count1, count2,…])}</p></li></ul><p>reference: <a href="https://juejin.cn/post/6969553033545941022">Vuex详解一：彻底弄懂state、mapState、mapGetters、mapMutations、mapActions - 掘金 (juejin.cn)</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Chap2-物理层</title>
    <link href="/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap2-%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2023/07/21/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap2-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2>1. 物理层基本概念</h2><p>物理层的主要是<strong>考虑怎样才能在连接各种计算机的传输媒体上传输数据比特流</strong>，而不是指具体的传输媒体。那么物理层的作用就是要尽可能的规避掉不同传输媒体和通信手段的差异。</p><p><span class="red">物理层的主要任务</span>：确定与传输媒体的接口的一些特性，e.g.机械特性、电气特性、功能特性、过程特性等。</p><h2>2. 数据通信的基础知识</h2><h3>2.1 数据通信系统</h3><p>一个数据通信系统包括三大部分：</p><ul><li>源系统（发送端）</li><li>传输系统（传输网络）</li><li>目的系统（接收端）</li></ul><p><img src="/img/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%B3%BB%E7%BB%9F.png" alt="数据通信系统"></p><h3>2.2 信道相关概念</h3><ul><li><p><strong>信道</strong>： 表示向<u>某一个方式</u>传送信息的媒体。</p><p>所以，一条通信线路往往包含一条发送信道和一条接收信道。</p></li><li><p>从通信双方的信息交互的方式来看，有以下三种方式：</p><ul><li>单向通信（单工通信）</li><li>双向交替通信（半双工通信）</li><li>双向同时通信（全双工通信）</li></ul></li></ul><h2>3. 物理层下面的传输媒体</h2><p>传输媒体：也称传输介质或者传输媒介，是数据传输系统中在发送器和接收器之间的物理通路。</p><p>传输媒体可以分为两类：</p><ul><li>导引型传输媒体：电磁波被导引沿着固体媒体（铜线或光纤）传播。</li><li>非导引型传输媒体：电磁波的传输常称为无线传输。</li></ul><h2>4. 信道复用技术</h2><p>信道复用：<strong>它允许用户使用一个共享信道进行通信，降低成本，提高利用率。</strong></p><p><img src="/img/%E4%BF%A1%E9%81%93%E5%A4%8D%E7%94%A8.png" alt="信道复用"></p><p>最常用的复用技术有如下几种：</p><ul><li><p><strong>频分复用</strong>：将整个带宽分为多份，用户在分配到一定的<strong>频带</strong>后，在通信过程中自始至终都占用这个频带</p><p><img src="/img/%E9%A2%91%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="频分复用"></p></li><li><p><strong>时分复用</strong>：将时间划分为一段段等长的<strong>时分复用帧</strong>（<strong>TDM</strong>帧）。每一个时分复用的用户在每一个 TDM帧中占用固定序号的时隙。</p><p><img src="/img/%E6%97%B6%E5%88%86%E5%A4%8D%E7%94%A8.png" alt="时分复用"></p><p><strong>使用时分复用系统传送计算机数据时，由于计算机数据的突发性质，用户对分配到的子信道的利用率一般是不高的</strong></p><p>改进：统计时分复用</p></li><li><p><strong>码分复用</strong>：光的频分复用。</p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络Chap1-概述</title>
    <link href="/2023/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap1-%E6%A6%82%E8%BF%B0/"/>
    <url>/2023/07/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9CChap1-%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2>1. 因特网概述</h2><h3>1.1 区分基本概念</h3><ul><li>网络：计算机网络简称网络。是由<strong>若干节点和链接这些节点的链路组成</strong>。</li><li>互联网：互联网是网络的网络。<strong>由一些路由器相互连接起来，构成一个覆盖范围更大的计算机网络</strong>。</li><li>因特网Internet：因特网是全球最大的互联网。</li></ul><p><img src="/img/%E7%BD%91%E7%BB%9C.png" alt="网络vs互联网"></p><h3>1.2 互联网基础结构发展的三个阶段</h3><ol><li><p>第一阶段：从单个网络ARPANET向互联网发展的过程</p><p>1983年，TCP&#x2F;IP协议称为ARPANET的标准协议，所以1983被认为是互联网诞生的事件</p></li><li><p>第二阶段：三级结构的互联网：校园网 -&gt; 地区网 -&gt; 主干网</p></li><li><p>第三阶段： 逐渐形成<span class="red">多层次ISP结构的</span>互联网</p><p><strong>ISP: Internet Service Provider</strong>互联网服务提供者</p></li></ol><h3>1.3 互联网的标准化工作</h3><p>国际性组件<strong>互联网协会Internet Society（W-ISOC）</strong>：对互联网进行全面管理以及全世界范围内促进其发展和使用。其中又包括</p><ul><li>互联网工程部</li><li>互联网研究部</li></ul><h2>2. 互联网的组成</h2><ul><li>边缘部分：由所有连接在互联网上的主机（端系统）组成，这部分由用户直接使用。在网络边缘部分的端系统之间的通信方式可分为两种：<ul><li>客户-服务器方式（C&#x2F;S）：Client&#x2F;Server, 是互联网上最常用的传统的方式，客户端通过地址访问服务器数据。</li><li>对等方式（P2P）：Peer-to-Peer, 两台主机在通信时并不区分哪个是服务请求方和哪个是服务提供方，只要都运行对等连接P2P软件就可以通信。</li></ul></li><li>核心部分：由大量网络和连接这些网络的路由器组成。为边缘部分提供服务，使得边缘部分中的任何一台主机能够与其他主机通信。其中起特殊作用的是<strong>路由器router</strong>，路由<strong>是实现分组交换的关键构件，任务是转发收到的分组</strong>。</li></ul><p>什么是分组交换？</p><p><i class="fa-solid fa-arrow-down"></i></p><h3>2.1 数据交换的方式</h3><p><img src="/img/%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2%E6%80%BB%E7%BB%93.png" alt="数据交换总结"></p><ul><li><p>电路交换：适合于数据量很大的实时性传输。</p></li><li><p>报文交换：不做分组，直接加上目标地址源地址等就开始数据交换</p></li><li><p><mark>分组交换</mark>： <strong>互联网的核心部分采用了分组交换技术</strong>。</p><p>通常我们把需要发送的<strong>完整的数据</strong>称为<strong>报文message</strong>。</p><ul><li><p>发送端：由于完整数据较长，会先将报文划分为一个个更小的等长数据段，在每个数据段前面加上<strong>首部</strong>（包含了目的地址源地址第几段数据等重要控制信息），就构成了一个<strong>分组（包）</strong>分别进行发送。</p><p><img src="/img%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2.png" alt="分组交换"></p></li><li><p>接收端：收到分组后剥去首部还原成报文。</p></li></ul></li></ul><h2>3. 计算机网络的类别</h2><ul><li>按照网络的作用范围进行分类：<ul><li>广域网WAN：Wide Area Network，作用范围通常为几十到几千公里，其任务是长距离比如跨域不同国家运送主机所发送的数据</li><li>城域网MAN：Metropolitan Area Network，作用的范围一般是一个城市</li><li>局域网LAN：Local Area Network，作用的范围一般是1公里左右</li><li>个人区域网PAN：Personal Area Network，范围很小，大约在10米左右</li></ul></li><li>按照网络的使用者进行分类：<ul><li>公用网： 按规定缴纳费用的人都可以使用的网络</li><li>专用网：为特殊业务工作的需要而建造的网络</li></ul></li></ul><h2>4. 计算机网络的性能指标</h2><p>性能指标从不同的方面来度量计算机网络的性能。常用的性能指标如下：</p><ul><li><p><mark>速率</mark>： 数据的传送速率，单位是bit&#x2F;s、kbit&#x2F;s、Mbit&#x2F;s、Gbit&#x2F;s</p><p><span class="red">速率往往是指额定速率或标称速率，而非实际运行速率</span></p></li><li><p><mark>带宽</mark>：表示单位时间内网络中的某信道能通过的<strong>最高数据率</strong></p></li><li><p><mark>吞吐量</mark>：表示在单位时间内通过某个网络的<strong>实际数据量</strong></p></li><li><p><mark>时延</mark>：指数据（一个报文或者是分组甚至是比特）从链路的一段到另一端需要的时间。其中，网络的时延是由以下几个不同的部分组成的：</p><ul><li><p>发送时延：是指主机或者路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起到该帧的最后一个比特所需的时间。类比火车完整的从火车站开出去的时间~</p><p>发送时延 &#x3D; 数据帧长度（bit）&#x2F;   发送速率（bit&#x2F;s)</p></li><li><p>传播时延：在传播过程中需要花费的时间。</p><p>传播时延 &#x3D; 信道长度  &#x2F;  信号在信道上传播的速率</p></li><li><p>处理时延： 主机或者路由器在收到分组时需要花费一定的时间进行处理，比如分析分组的首部、提取数据、查找转发表等，所花费的时间</p></li><li><p>排队时延： 在分组进入路由器后要先在输入队列中排队等待处理。</p></li></ul></li><li><p><mark>时延带宽积</mark>：传播时延 *  带宽。时延代表了管道（链路）的长度，而带宽代表了管道的宽度，时延带宽积就代表了管道的体积，表示这样的链路可以容纳多少个比特</p></li><li><p><mark>往返时间RTT</mark>：从发送方发送数据开始，到发送方收到接收方确认的时间，也就是双向交互一次的时间。</p></li><li><p><mark>利用率</mark>：</p><ul><li>信道利用率：百分之几的时间是被利用的</li><li>网络利用率：全网络的信道利用率加权平均</li></ul></li></ul><h2>5. 计算机网络体系结构</h2><h3>5.1 OSI/RM</h3><p>为了使不同体系结构的计算机网络互联，国际标准化组织ISO提出了试图在全世界范围内的标准框架即开放系统互联基本参考模型<span class="red">OSI&#x2F;RM（OSI）</span>（Open Systems Interconnection Reference Model）。</p><p>但OSI只获得了理论研究的成果却在市场化方面失败了。</p><p>同时，法律上的非国际标准<mark>TCP&#x2F;IP</mark>却获得了最广泛的应用，被称为事实上的国际标准</p><h3>5.2 协议</h3><p>协议：为进行网络中的数据交换而建立的规则、标准或约定称为网络协议（协议）</p><h3>5.3 计算机网络体系结构</h3><p>计算机网络的体系结构是计算机网络的各层及其协议的集合。</p><h3>5.4 具有五层协议的体系结构</h3><p><img src="/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="对比"></p><ul><li><p>OSI七层协议体系结构：概念清楚，理论完整但是复杂不实用</p></li><li><p>TCP&#x2F;IP四层体系结构：实用但是最下面的网络接口层并没有具体内容</p></li><li><p><mark>结合OSI和TCP&#x2F;IP的优点的五层协议的体系结构</mark>：每层简要介绍如下，后面的章节会展开</p><ul><li><p><mark>应用层</mark>application layer：应用层<strong>任务</strong>是通过应用进程间的交互来完成特定网络应用。应用层<strong>协议</strong>是应用进程间通信和交互的规则，对于不同的网络应用需要不同的应用层协议，e.g.域名系统DNS、支持万维网应用的HTTP协议、支持电子邮件的SMTP协议等。</p><p>应用进程数据先传送到应用层，加上应用层首部，称为<mark>应用层协议数据单元PDU</mark>(Protocol Data Unit)</p></li><li><p><mark>运输层</mark>transport layer：运输层<strong>任务</strong>是向两台主机中进程之间的通信提供通用的数据传输服务。传输层<strong>协议</strong>主要为<strong>传输控制协议TCP</strong>和<strong>用户数据报协议UDP</strong></p><ul><li>传输控制协议TCP：Transmission Control Protocol，提供面向连接的、可靠的数据传输服务。</li><li>用户数据报协议UDP：User Datagram Protocol，提供无连接的尽最大努力的数据传输服务</li></ul><p>应用层PDU传送到运输层，加上运输层的首部，称为<mark>运输层报文</mark></p></li><li><p><mark>网络层</mark>network layer（IP层）：网络层<strong>任务</strong>是为分组交换网上的不同主机提供通信服务。互联网使用的网络层<strong>协议</strong>是无连接的<strong>网际协议IP</strong>和许多路由选择协议。</p><p>传输层报文传送到网络层，加上网络层的首部，称为<mark>IP数据报（或分组）</mark></p></li><li><p><mark>数据链路层</mark>data link layer（链路层）</p><p>IP数据报传送到数据链路层，加上链路层的首部和尾部，称为<mark>数据链路层帧</mark></p></li><li><p><mark>物理层</mark>physical layer（链路层）：在物理层数据传输的单位是比特，物理层要考虑用多大的电压表示1或者0</p><p>数据链路层帧传送到物理层，最下面的物理层把比特流传送到物理媒体</p><p>电信号（或光信号）在物理媒体中传播，从发送端物理层传送到接收端物理层</p><p>物理层接收到比特流，上交给数据链路层</p><p>数据链路层剥去帧首部和帧尾部，取出数据部分，上交给网络层</p><p>网络层剥去首部，取出数据部分上交给运输层</p><p>运输层剥去首部，取出数据部分上交给应用层</p><p>应用层剥去首部，取出应用程序数据上交给应用进程</p></li></ul><p><img src="/img/%E9%A6%96%E9%83%A8%E4%BD%8D%E7%BD%AE.png" alt="process"></p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>计算机基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路由传参</title>
    <link href="/2023/07/18/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/"/>
    <url>/2023/07/18/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%82/</url>
    
    <content type="html"><![CDATA[<h2>路由传参总结</h2><h3>1. 路由跳转的两种方式</h3><ul><li>声明式导航：点击链接实现导航的方式，a或者router-link</li><li>编程式导航：调用API实现导航的方式，this.$router.push()或者location.href</li></ul><h3>2. 路由传参方式</h3><h4>2.1 <mark>params传参-显示参数</mark></h4><p>显示参数的意思就是：会在URL地址中展示出参数</p><ul><li><p><strong>声明式router-link</strong>: </p><p><img src="/img/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%821.png" alt="code"></p><ul><li><u>父组件</u>： 通过<span class="red">router-link的to属性</span>进行传参</li><li><u>路由配置文件中</u>：要对子路由提前配置好参数</li><li><u>子组件</u>： 通过<span class="red">$route.params.xxx</span>进行参数的获取</li></ul></li><li><p><strong>编程式this.$route.push</strong>: </p><p>和上面大差不差…</p><p><img src="/img/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%822.png" alt="code"></p></li></ul><h4>2.2 <mark>params传参-不显示参数</mark></h4><p><span class="red">如果不向在URL中显示参数</span>：需要通过路由的<span class="red">别名name</span>进行传值</p><ul><li><p><strong>声明式router-link</strong>: </p><p><img src="/img/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%823.png" alt="code"></p><ul><li><u>父组件</u>：<span class="red">router-link的to属性需要动态绑定传<mark>对象形式</mark></span>的参数</li><li><u>路由配置文件中</u>：给路由规则相同的name值</li><li><u>子组件</u>： 通过<span class="red">$route.params.xxx</span>进行参数的获取</li></ul></li><li><p><strong>编程式this.$route.push</strong>: </p><p><img src="/img/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%824.png" alt="code"></p></li></ul><h4>2.3 <mark>query传参</mark></h4><p>query作为查询参数是肯定会显示在URL中的，以？开始。</p><ul><li><p><strong>声明式router-link</strong>: （类比2.2的声明式）</p><p><img src="/img/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%825.png" alt="code"></p><ul><li><u>父组件</u>：<span class="red">router-link的to属性需要动态绑定传<mark>对象形式</mark></span>的参数，只不过params属性换成query属性进行赋值传递</li><li><u>路由配置文件中</u>：给路由规则相同的name值</li><li><u>子组件</u>： 通过<span class="red">$route.<mark>query</mark>.xxx</span>进行参数的获取</li></ul></li><li><p><strong>编程式this.$route.push</strong>: </p><p><img src="/img/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%826.png" alt="code"></p></li></ul><h3>3. 常见面试题</h3><ul><li><p>路由传递参数（对象形式）path是否可以结合params参数一起使用？</p><p><mark>达咩！！！</mark>path的写法传参需要在规则里进行占位而不能使用params一起使用</p></li><li><p>如何指定params参数可传不可传？</p><p>如果路由要求传递params参数但是你就不传，URL会出问题。</p><p>在配置路由的时候，占位后面加？</p></li><li><p>如果params传空字符串怎么办？</p><p>使用undefined</p></li><li><p>路由组件能不能传递props数据？</p><p>可以</p></li></ul><p>reference: <a href="https://www.bilibili.com/video/BV1Vf4y1T7bw?p=8&spm_id_from=pageDriver&vd_source=f0ab2b0ee62d30e8b358723d82e84549">008-尚硅谷-尚品汇-路由传递参数_哔哩哔哩_bilibili</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue后台项目</title>
    <link href="/2023/07/18/vue%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/07/18/vue%E5%90%8E%E5%8F%B0%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p><mark>技术架构</mark>：vue+webpack+vuex+vue-router+axios+less+elementUI+Echarts</p><p><span class="red">实现功能</span>：</p><ul><li>菜单权限</li><li>按钮权限</li><li>数据可视化</li></ul>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>projects</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue前台项目</title>
    <link href="/2023/07/18/vue%E5%89%8D%E5%8F%B0%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/07/18/vue%E5%89%8D%E5%8F%B0%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h2>Vue前台项目-电商平台</h2><p><mark>技术架构</mark>：vue2+vue-cli+vuex+vue-router+axios+less</p><p><span class="red">实现功能</span>：</p><ul><li>封装通用组件</li><li>登录注册</li><li>token</li><li>守卫</li><li>购物车</li><li>支付</li><li>项目性能优化等</li></ul><h3>1. 初始化项目</h3><p>vue-cli脚手架依赖环境：node+webpack</p><h4>1.1 vue create 项目名称</h4><p>选择安装<u>Vue2的default</u></p><p>用vue-cli脚手架初始化的项目目录中</p><ul><li>node_modules文件夹: 项目依赖</li><li>public文件夹：一般放置静态资源，webpack在打包的时候会<span class="red">原封不动打包到dist文件夹中</span></li><li><mark>src文件夹</mark>(程序员源代码文件夹)：<ul><li>assets文件夹：一般放置多个组件公用的静态资源，webpack打包的时候会把静态资源<span class="red">当成一个模块打包到JS文件中</span></li><li>components文件夹：非路由组件</li><li>App.vue：唯一的根组件</li><li>main.js: 程序的入口文件，整个程序最先执行的文件</li></ul></li><li>babel.config.js: 配置文件，与babel相关。</li><li>package.json文件： 记录项目各种信息，e.g. 项目名称、项目依赖、项目如何运行等。</li><li>package-lock.json: 缓存性文件</li></ul><h4>1.2 项目的其他配置</h4><ul><li><p>项目运行起来的时候，让浏览器自动打开</p><p>在package.json中的scripts节点下，找到serve命令，添加–open，就可以自动在输入npm run serve命令后自动打开</p><p>“scripts”: {</p><p>  “serve”: “vue-cli-service serve <span class="red">–open</span>“,</p><p>  “build”: “vue-cli-service build”,</p><p>  “lint”: “vue-cli-service lint”</p><p> }</p></li><li><p>将eslint校验功能关闭</p><p>在vue.config.js的导出中，添加：lintOnSave: false</p></li><li><p>配置src目录路径的简写形式。因为我们程序员需要经常大量的操作src目录下的文件，避免各种..&#x2F;路径的查找，我们可以配置给src一个别名，如：@。</p><p>在jsconfig.json中</p><p>“compilerOptions”: {</p><p>  “baseUrl”: “.”,</p><p>  “paths”: {</p><p>   “@&#x2F;<em>“: [“.&#x2F;src&#x2F;</em>“]}</p></li></ul><h3>2. 项目的路由分析</h3><p>我希望达到的效果是在&#x2F;home地址中展示主页，在&#x2F;search地址中展示搜索页面，但是在切换页面时，整体页面的header和footer部分是不变的，故考虑将这两个组件放到<span class="red">非路由组件</span>，而不同地址对应的页面中间部分的组件考虑放到<span class="red">路由组件</span>中。</p><p>其他页面同理，拆分路由组件和非路由组件。</p><h3>3. Header-非路由组件</h3><p>注意，非路由组件放到<mark>components节点</mark>里。</p><h4>3.1 布局</h4><p>在抽取组件内容之前，我先写了静态的HTML页面搭配Less样式和js行为。</p><ul><li><p>.top：头部的第一行，可以进行点击跳转，设置行高等于height可以让字体垂直居中，设置背景颜色。再将内容都包含在其中的版心模块container，设置margin: 0 auto, overflow: hidden</p><ul><li><p>.loginList: 需要贴着版心的左侧显示，设置向左浮动</p></li><li><p>.typeList: 向右浮动</p><p>对于文字中间的 | 分割，可以考虑用展示左边框实现。在less文件中，使用<mark>&amp;+a选择除了第一个a以外的所有a设置border-left</mark></p></li></ul></li><li><p>.bottom:  头部的第二行，主要是搜索区域，同样设置居中</p><ul><li><p>.logoArea：在头部放置logo图片的位置，向左浮动</p><p>其中，图片img首先需要被a包裹，确保可以进行点击，a还需要被h1包裹，<mark>以便于SEO优化</mark></p></li><li><p>.searchArea:  搜索栏的位置，向右浮动</p><p>中间只有一个form表单元素。form中包含input和button。</p></li></ul></li></ul><h4>3.2 抽取为组件</h4><ul><li><p>在components节点下新建Header文件夹，里面新建myHeader.vue头部组件，以及存放logo的images文件夹</p></li><li><p>将样式粘贴到头部组件的template中</p></li><li><p>将less样式粘贴到style中，注意要确保项目安装了<mark>less、less-loader</mark>，还需给style标签添加lang&#x3D;”less”属性</p></li><li><p>将reset.css清除默认样式的css文件放到静态资源public中</p></li></ul><h3>4. Footer-非路由组件</h3><h4>4.1 布局</h4><p>footer.footer设置一个背景颜色，里面只包含一个footer-container，设置成版心格式。在版心中包含上下两个部分</p><ul><li>.footerList: footer的上面部分，其中又分为六个部分，统一给类名：.footerItem再统一浮动起来在一排显示。每个.footerItem里包含一个h4标题和一个ul，只有最后一个的ul替换为img</li><li>.copyright: footer的下面部分，由一个ul、两个p组成。</li></ul><h4>4.2 抽取为组件</h4><p>和3.2同理</p><h4>4.3 显示与隐藏的控制</h4><p>Footer组件虽和Header组件同为非路由组件，但只在Home、Search界面中同时出现Header和Footer，登录注册界面没有Footer只有Header，在这里进行Footer的显示与隐藏的控制。控制组件的显示与隐藏有以下三个方案：</p><ul><li><p><del>v-if：具有很高的切换开销</del></p></li><li><p>v-show：</p><ul><li><p>在App根组件中利用v-show控制footer的显示与隐藏，利用$route.path的值来判断式哪个页面</p><p>&lt; Footer v-show&#x3D;”$route.path&#x3D;&#x3D;’&#x2F;home’ || $route.path&#x3D;&#x3D;’&#x2F;search’” &gt;&lt; &#x2F;Footer &gt;</p></li><li><p><mark>问题：</mark>如果这里可展示的组件有100个，写起来太麻烦了</p></li></ul><p><i class="fa-solid fa-arrow-down"></i></p><ul><li><p><mark>利用路由元信息meta</mark>：在index.js路由规则配置中，加入对象格式的meta元信息，存储是否展示footer的布尔值。</p><p>meta的获取：$route.meta</p></li></ul><p><img src="/img/%E8%B7%AF%E7%94%B1%E5%85%83%E4%BF%A1%E6%81%AF.png" alt="code"></p></li><li><p>动态组件component: 通过对is属性的赋值来控制展示什么组件，同样需要搭配路由元信息的使用</p><p><img src="/img/%E5%85%83%E4%BF%A1%E6%81%AF%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.png" alt="code"></p></li></ul><h3>5. 路由组件的搭建</h3><h4>5.1 vue-router的安装</h4><p>注意！<mark>vue-router3.x配合vue2.x使用，vue-router4.x配合vue3.x使用</mark></p><h4>5.2 router文件夹的创建</h4><p>如果使用vue-cli脚手架搭建的时候没有选router，则需要在项目中install然后在src目录下新建<mark>pages文件夹，用来存放路由组件</mark>。</p><p>根据项目需要，在里面给每一个组件新建一个文件夹。</p><h4>5.3 配置路由</h4><p><mark>在项目中配置路由一般在src-&gt;router文件夹中</mark>！</p><ul><li><p>新建router文件夹，在里面新建<mark>index.js文件</mark>用来配置路由</p><ul><li>因为Vue-router是Vue的插件，先引入Vue</li><li>再引入Vue-router</li><li>使用<mark>Vue.use(VueRouter)方法来使用vuerouter这个插件</mark></li><li>用new VueRouter（）创建一个路由实例router，在里面配置路由<ul><li><mark>routes数组声明路由的匹配规则</mark>，每条规则用对象的形式，path指定hash地址，component指定需要展示的组件，所以还需要再index.js中import所需的所有路由组件</li><li>我们希望一进来就直接展示首页，这里做路由的redirect<mark>重定向</mark></li></ul></li><li>向外导出路由实例router</li></ul></li><li><p>我们需要让index.js生效，所以需要<mark>在入口文件main.js中<span class="red">导入并挂载</span>路由模块</mark></p><ul><li>这里需要注意！！挂载router的时候就是在注册路由信息，这样可以<mark>使每！个！组！件！（路由和非路由都有）身上都有$route, $routers属性</mark></li><li><strong>$route</strong>: 一般使获取<span class="red">路由信息</span>的，e.g. 路径、query、params等</li><li><strong>$router</strong>: 一般<span class="red">进行编程式导航进行路由跳转</span>, e.g. push、replace</li></ul></li><li><p>我们的路由还需要一个展示的出口，在App.vue中<mark><span class="red">router-link声明路由链接和router-view占位符</span></mark></p></li></ul><h4>5.4 路由跳转</h4><p><span class="red">路由跳转有两种形式：声明式导航和编程式导航</span></p><p><mark>回顾：编程式导航能做所有声明式导航可以做的，并且还能实现一些其他的业务逻辑</mark></p><ul><li><p>在我们的Header组件中，将包含登录的a改造成<span class="red">router-link</span>, to属性设置为&#x2F;login，注册、点击图片。</p></li><li><p>我们还需要在点击搜索按钮的时候跳转到search，这里尝试用<strong>编程式导航</strong>：</p><p>给button绑定点击事件goSearch，在methods中声明，处理函数为<mark>this.$router.push(‘&#x2F;search’)</mark></p></li></ul><h4>5.5 路由传参</h4><p>【<strong>知识点可以参考我的另一篇笔记：路由传参</strong>】</p><p>现在我想实现的业务逻辑为：当点击搜索的button按钮进行路由跳转的同时，将前面input输入框的值传递到Search组件中</p><p><img src="/img/%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%8F%827.png" alt="code"></p><p><mark>注意</mark>：</p><ul><li>路由传参的时候，对象的写法可以是name或者path形式，但是path不能和params参数一起</li><li>在配置路由的时候，params已经占位了（&#x2F;search&#x2F;:keyword)， 但是如果路由跳转的时候没带params就会出现路径上的问题无法跳转，如果想<span class="red">指定params可传可不传</span>，需要<strong>在配置路由的时候，params占位后面加个？</strong></li></ul><p>【<span class="red">问题</span>】：现在我们发现，使用编程式导航进行路由跳转时，如果参数不变，多次执行就会抛出<span class="red">redundant navigation</span>的错误警告</p><p>【<span class="red">原因</span>】：打印了以下this.$router.push的返回值，发现是一个Promise类型，但是promise需要成功、失败的回调函数</p><p>【<span class="red">解决1</span>】：想着给this.$router.push再传两个空的函数，this.$router.push({name: ‘search’, params: {keyword: ‘’}, query: {k: this.keyword.toUpperCase()}}, () &#x3D;&gt; {}, () &#x3D;&gt; {}); &#x2F;&#x2F;但是这种解决方法在别的组件中每次都要这么写</p><p>【<span class="red">解决2</span>】：<mark>改写push方法</mark></p><p>首先通过打印，发现push方法是VueRouter.prototype上的方法</p><p>$router是VueRouter类的一个实例</p><p>VueRouter.prototype.push &#x3D; function() {</p><p>&#x2F;&#x2F;上下文是VueRouter类的一个实例}</p><p><img src="/img/%E6%94%B9%E5%86%99push.png" alt="改写push"></p><h3>6. 三级联动-全局组件</h3><p>因为三级联动这个功能在很多组件中都需要使用，现在想把三级联动抽成一个组件的时候就考虑全局组件，只需要注册一次就可以全局使用。</p><h4>6.1 布局</h4><p>.typeNav添加下边框且包含.container来控制这一行导航居中展示。</p><ul><li><p>.all全部商品分类给宽高和红色背景</p></li><li><p>.nav包含了导航栏其他的窗格，其中每个窗格都被一个a包裹</p></li><li><p>.sort就是竖着这个精细的导航栏部分，想用定位定到全部商品分类的下面，所以添加position: absolute同时给父元素container添加position: relative。其中每一个分类都是一个.item，为了完成三级联动的效果，每个.item除了包含本身左侧的h3标题，还包含要在中间展示的具体内容.item-list</p><ul><li><p>.item-list: 首先在我们不用鼠标经过的时候是不展示的，设置display:none；其次，展示的时候位置需要通过定位的形式，添加position: absolute，通过<span class="red">left：.sort的宽度</span>就可以定位到贴着sort的右侧展示的位置；子元素.sub-item向左浮动。</p><p>中间的内容每一条选择用自定义表单元素dl进行包含，dt是左侧的，dd是右侧的</p></li></ul></li></ul><h4>6.2 注册为全局组件</h4><p>抽取出template中的UI结构以及style组成typeNav.vue</p><p>需要在<mark>main.js中引入并Vue.component(全局组件的名字，哪个组件)注册为全局组件</mark>： </p><h4>6.3 在Home组件中使用</h4><p>因为已经是注册为全局组件了，不需要引入注册，可以直接使用~</p><h3>7. ListContainer组件：包含轮播图和快报</h3><h4>7.1 布局</h4><p>.list-container设置版心结构，加个padding-left展示出6的三级联动组件。</p><ul><li><p>.center是轮播图模块：找到想要的效果的demo对应的html文件打开复制样式、结构和初始js</p></li><li><p>.right就是轮播图右侧的模块：</p><ul><li><p>.news是尚品汇快报模块：其中第一行用h4展示，里面两个模块分别向左右浮动；第二行的.news-list中放ul展示新闻</p></li><li><p>ul.lifeservices是三行小图标模块：设置为<mark>display:flex布局，为了让中间的li可以多行展示，再添加flex-wrap: wrap属性</mark>；</p><p>其中<mark>小图标选择使用精灵图</mark>，给每个.list-item设置精灵图为background-image，然后再通过nth-child选择器给每个item调整background-position</p></li><li><p>.ads是最下的广告模块：选择插入一张广告图，并且添加transition属性，当鼠标经过hover的时候opacity从0.8变1</p></li></ul></li></ul><h4>7.2 在Home组件中使用</h4><p>这次需要严格按照引入、注册、使用的步骤</p><h3>8. Home首页剩下的其他组件</h3><h4>8.1 Recommend今日推荐</h4><p>包含container做版心的居中对齐，其中包含一个ul.recommend中每个li是一个推荐。</p><h4>8.2 Rank商品排行</h4><ul><li>.tab: 上面的切换栏。设置margin: 0 auto水平居中。给每个块用a包裹达到点击的效果，每个a里面包含上一个img下一个p。</li><li>.content: 下面的内容区域。一看到这种整齐的结构就考虑用ul&gt;li去呈现。给每个item设置一个红色的border，里面再分别包含上面图片下面相关信息。</li></ul><h4>8.3 Like猜你喜欢</h4><ul><li>.title: 上面的文字+可点击的换一换</li><li>.bd: 还是考虑用ul&gt;li去呈现每个item。</li></ul><h4>8.4 Floor可以做组件的复用</h4><ul><li>.title: 上面的标题和导航栏。一个h3左浮动，一个ul&gt;li*7右浮动</li><li>.tab-content: 内容栏。每一列是一个子元素，需要分裂的.split。</li></ul><h4>8.5 Brand商标组件</h4><p>看到整齐的结构，ul&gt;li，只不过每个li包含一个商标的图片</p><h3>9. axios二次封装</h3><p><strong>为了设置请求拦截器和响应拦截器</strong></p><p>首先需要在项目装安装axios【<strong>axios知识点可以参考我的另一篇笔记：数据的请求与发送</strong>】</p><p>且在项目中通常在src下面的<mark>api</mark>文件夹存放axios相关js文件。故在src下新建api文件夹，在文件夹中新建request.js来使用axios发送请求。在这里对axios进行二次封装。</p><h4>9.1 配置axios实例</h4><p>利用<mark>axios.create()</mark>方法可以创建一个axios实例，传入配置对象就可以进行配置。配置对象中比较常用的两个属性：</p><ul><li>baseURL：基础路径，比如我们的接口文档中路径都带有api，就可以配置上，免得手写</li><li>timeout：设置请求超时的时间</li></ul><h4>9.1 请求拦截器</h4><p>请求拦截器：在发送请求之<span class="red">前</span>，请求拦截器可以检测到，就可以在请求发出去之前做一些事情。</p><h4>9.2 响应拦截器</h4><p>响应拦截器：在服务器响应之后，响应拦截器可以检测到，这时候可以完成一些业务逻辑，比如设置成功和失败的回调</p><p><img src="/img/axios%E4%BA%8C%E6%AC%A1%E5%B0%81%E8%A3%85.png" alt="axios二次封装"></p><h3>10. api接口统一管理</h3><p>因为项目较大，在api下新建index.js用来统一管理api接口。</p><h4>10.1 跨域问题</h4><p>在api-&gt;index.js文件中我们向外暴露了一个获取三级联动数据的函数，但是出现了404错误，原因是跨域了。</p><p><mark>跨域</mark>： <span class="red">协议、域名、端口号</span>不同请求，就成为跨域。（<mark>非同源</mark>）</p><p>Reference: <a href="https://zhuanlan.zhihu.com/p/145837536">你还不知道跨域问题是怎样造成的吗？ - 知乎 (zhihu.com)</a></p><p> <a href="http://localhost:8080/#/home">http://localhost:8080/#/home</a>  这是前端项目的本地服务器</p><p> <a href="http://gmall-h5-api.atguigu.cn/">http://gmall-h5-api.atguigu.cn</a>  这是后台服务器</p><h4>10.2 跨域问题解决</h4><p>由于跨域问题只存在于浏览器间，服务器间不存在，故考虑使用代理服务器！！</p><p><mark>在vue.config.js中配置代理<span class="red">proxy</span></mark>：只要请求路径中有&#x2F;api，代理服务器就会去找真实服务器请求数据</p><p><img src="/img/%E8%B7%A8%E5%9F%9F.png" alt="code"></p><h3>11. nprogress插件显示进度条</h3><p>首先业务逻辑是开始发请求的时候就开始显示进度条，服务器的数据返回之后进度条结束。</p><p>想到可以在<mark>请求和响应拦截器</mark>中使用nprogress的start和done方法。</p><p>然后引入nproress进度条css样式即可。如果想要修改样式就到css中去修改就行了~</p><h3>12. 在项目中使用vuex状态管理库</h3><p>vuex：官方提供的一个插件，（vue-router也是），是做状态管理用的库，可以<span class="red">集中式管理项目中组件公用的数据</span></p><h4>12.1 vuex的安装</h4><p>我用的vue2.x，要注意npm i –save <a href="mailto:&#x76;&#117;&#101;&#120;&#64;&#x33;&#46;&#50;&#46;&#48;">&#x76;&#117;&#101;&#120;&#64;&#x33;&#46;&#50;&#46;&#48;</a>才能版本适配</p><h4>12.2 在项目中配置vuex</h4><p>src下新建<mark>store文件夹</mark>。在其中新建index.js来配置vuex。</p><p>下面就可以类比配置vuerouter的步骤了。</p><ul><li><p>引入vue和vuex，vue.use（vuex）注册为插件</p></li><li><p>向外暴露<mark>Vuex.Store({配置对象})</mark>的这样一个实例对象</p><p>其中，配置对象主要有以下几个属性：</p><ul><li><mark>state</mark>：仓库存储数据的地方</li><li><mark>mutations</mark>：修改state的唯一手段</li><li><mark>actions</mark>：处理action</li><li><mark>getters</mark>：理解为计算属性，用于简化仓库数据</li></ul></li><li><p>在入口文件中引入、注册仓库。此时，所有的组件身上会带有<span class="red">$store</span>的属性了。</p></li></ul><h4>12.3 利用vuex进行模块化开发</h4><p>在store下面为每个模块新建一个文件夹，分别存储这个模块里的数据，在文件夹中新建index.js文件，向外暴露state、mutations、actions和getters对象。</p><p>再在store下面的index.js中的<mark>modules</mark>进行引用：</p><p><img src="/img/modules.png" alt="code"></p><h3>13. 三级联动的静态页面改写</h3><p>现在我们的三级联动TypeNav组件里面的内容都是我们手动写死的，但是项目接口文档中指出了请求路径和方式，我们要把里面手动写死的数据替换为动态请求来的数据。</p><h3>13.1 何时发送请求？</h3><p>我们考虑在<mark>组件挂载完毕，就可以通知vuex向服务器发送请求数据，存储在仓库中</mark></p><ul><li><p>挂载完毕：就是在组件的mounted()声明周期函数里完成这个发送请求的业务逻辑</p></li><li><p>通过vuex进行数据的统一管理</p><ul><li><p>因为是要发送数据请求，所以需要异步操作，要用this.$store.dispatch(‘’)派发actions里的函数</p></li><li><p>我们已经封装好了发送请求的函数，引入调接口即可</p></li><li><p>注意axios发出的数据请求返回的是一个<span class="red">Promise对象</span>，为了拿到调用成功的结果，使用<span class="red">async&#x2F;await</span>对函数进行改造</p></li><li><p>如果请求成功，则需要修改state里面的数据，所以我们需要传入context参数，这里选择对齐做解构赋值{commit}作为参数，判断如果res.code &#x3D;&#x3D; 200, 那么通过commit再去提交mutation去修改state中的值</p><p><mark>这里注意一下在vuex的使用中，为了方便这些函数间的相互调用，每个对象里方法的参数！！！注意！！！</mark></p><p>Reference：<a href="https://blog.csdn.net/hbwhypw/article/details/112577588">(70条消息) vuex commit 传递多个参数的两种方法_vuex传递多个参数_hbwhypw的博客-CSDN博客</a></p></li></ul></li></ul><h3>13.2 请求到了数据如何修改template？</h3><p>现在已经拿到了数据，所以将我们的template中的所有并列的一级结构中除了第一个都删了，给第一个加<mark>v-for</mark>指令。</p><p>v-for&#x3D;”(c1, index) in categoryList”</p><p><mark>注意！！v-for还要绑定key！！！</mark></p><p><img src="/img/code.png" alt="code"></p><h3><i class="fa-solid fa-bookmark"></i>13.3 <mark>卡顿现象引入防抖与节流</mark></h3><p>我们发现，如果从全部商品分类快速的用鼠标下划，并不会触发所有一级分类的mouseenter事件的回调函数，这是由于用户操作过快，且每一次的触发，回调函数都需去执行，这时候如果事件很短且回调函数内部有计算，很有可能出现浏览器<mark>卡顿</mark>现象的出现。</p><p><mark>防抖</mark>：<span class="red">前面的所有触发都被取消，最后一次执行在规定的时间之后才会触发。</span>也就是说<mark>如果连续快速的触发，只会执行一次</mark>。</p><p><mark>节流</mark>：<span class="red">在规定的间隔时间范围内不会重复触发回调，只有大于这个时间间隔才会触发回调</span>。也就是说<mark>把频繁触发变为少量触发</mark>。</p><p>所以我们考虑在三级联动的模块使用lodash添加节流的技术，防止mouseover事件触发的太频繁造成的卡顿现象。</p><p>但是我们es6语法的methods中的格式没法用lodash，考虑写es5格式的kv</p><p>changeIndex: _.throttle(function(id) {</p><p>   this.currentIndex &#x3D; id;</p><p>  },50)</p><h3>13.4 三级联动路由跳转 - 编程式导航+事件的委派</h3><p>在我们的三级联动模块，业务需要点击一级或二级或三级分类标题就可以跳转到搜索模块，并将用户选中的产品名字和id在路由跳转的时候进行传递。</p><p>这时候路由跳转我们有两种选择：声明式导航和编程式导航。</p><p>虽然声明式导航router-link可以实现路由的跳转和参数的传递，但是会造成卡顿的现象！！因为它可是一个组件！！在for循环的时候创建太多的组件再渲染是一件高开销的事情。故尝试编程式导航。</p><p>但是给每个a都加一个click事件的处理函数进行this.$router.push的跳转虽然会比声明式导航好一些，但是也是大量的回调函数。</p><p><mark>考虑事件的委派</mark>！！！太妙了啊！！！！给就近的父盒子添加@click事件</p><p>但是还仍然存在两个问题：</p><ul><li><p>如何知道点击的一定是a标签才触发的父盒子的click事件呢？</p><p>ans：利用自定义属性，给所有子节点中的a都加上data-categoryName</p></li><li><p>现在已经知道是a标签，如何区分是一级？二级还是三级？</p><p>ans：可以借鉴上面的思想，也利用自定义属性，分别给一二三级a标签添加自定义属性data-category1Id、data-category2Id、data-category3Id来进行区分</p></li><li><p>整理参数就可以跳转啦~~~</p></li></ul><h3>14. Search页面</h3><h4>14.1 Search页面引入三级联动并加入过渡效果</h4><p>因为三级联动组件TypeNav已经注册为了全局组件，直接在search页面中引入即可。</p><p><i class="fa-regular fa-face-sad-cry"></i>但是现在和我们想要的效果还相差甚远啊55555</p><ul><li><p>问题1：我们希望已进入search界面这个三级联动的下拉菜单是默认隐藏的，当鼠标经过才下拉显示</p><p>解决：在TypeNav组件中，给下拉的导航栏首先尝试写死v-show:’false’达到目的，现在我们就考虑通过定义一个变量navShow的值来动态的控制下拉导航栏的显示与隐藏。</p><p><i class="fa-solid fa-arrow-down"></i></p></li><li><p>问题2：那么从home跳转到search组件的时候，哪里会有区别可以改写navShow的值呢？</p><p>解决：<mark>mounted！！！！！</mark></p><p>mounted() {</p><p>​if(this.$route.path!&#x3D;’&#x2F;home’) {</p><p>​this.navShow &#x3D; false</p><p>}}</p></li><li><p>问题3：如何添加过渡动画效果？</p><p>解决：要注意<mark>组件或者元素能够添加过渡动画效果的前提是必须有v-if&#x2F;v-show指令！！！</mark></p><p>用transition标签将包含v-show的内容包含，其中过渡动画的效果是用指令来完成的。</p></li></ul><h4>14.2 从Home首页跳转到Search页面的参数合并</h4><p>现在我们有两个入口可以从Home首页跳转到Search页面，且我们分别在搜索框的button按钮和三级联动写好了路由传参。</p><p>但是现在业务想要实现的逻辑是，如果有params就把params和query一起传递然后跳转到search。</p><p><u>解决</u>：我们在三级联动中push之前先判断if(this.$route.params)如果为true，就合并参数再传递。同理在header组件中push之前也先判断有无query参数~</p><h4>14.3 Search模块数据操作</h4><p>现在写好的是静态的页面，我们还是需要向服务器发送请求、将数据存储到vuex的仓库中、再在Search组件中动态展示数据。</p><h4>14.3.1 api</h4><p>在api&#x2F;index.js中写上获取搜索商品的数据的部分，根据接口文档，注意发起axios请求的类型是<strong>POST</strong>。</p><p>这个地方要注意发起axios请求的post的语法，axios({method:’post’, url: ‘xxx’, <span class="red">data</span>: xxx})传递post的参数要用data！！</p><p>且根据接口文档，传的参数起码是一个空对象。</p><h4>14.3.2 vuex操作</h4><p>注意现在已经要切换到search小仓库啦~</p><p>然后就是vuex的三连环操作，actions中发请求，mutations中修改state中的数据就已经存储到仓库中了</p><p>在组件中引用mapState把仓库的数据映射成组件身上的数据</p><h4>14.3.3 在组件中动态展示数据</h4><p><u>本来的写法</u>：computed: {</p><p>  …mapState({</p><p>   goodsList: state&#x3D;&gt;state.search.searchList.goodsList</p><p>  })}</p><p>但是这个地方太复杂了，想要在<span class="red">仓库中先利用getters简化一下数据再在search组件中使用mapGetters将getters映射成组件自己的计算属性</span></p><p>注意！state是分模块的（home、search等模块）所以mapState({})中间是对象的格式，但是getters部分模块，直接用数据的形式就行</p><p><u>改进</u>：</p><p><img src="/img/imp.png" alt="code"></p><h4>14.4 发送请求的位置改写</h4><p>现在我们的请求数据的代码是写在了mounted钩子函数中，但是这只会执行一次，我们的业务需求是当携带不同的参数进行查询时，都应当返回不一样的数据。</p><p><span class="red"><strong>考虑将发送请求的部分封装在函数（methods）里</strong></span>，这样就可以声明一次，多次调用。</p><p>考虑<mark>watch监听路由的变化再次发送请求获取新的数据</mark></p><p>我们选择在beforeMount声明周期函数中，修改params这样的话就可以在mounted前有要在mounted中传递的参数了</p><p>这里的小trick：</p><p><u>原始版本</u>：this.searchParams.keyword &#x3D; this.$route.qarams.keyword</p><p>​this.searchParams.category1Id &#x3D; this.$route.query.category1Id,…..</p><p><u>改进版本</u>：<span class="red">使用es6语法：<mark>Object.assign方法</mark></span></p><p>​Object.assign(this.searchParams, this.$route.params, this.$route.query)</p><h4><i class="fa-solid fa-star"></i>14.5 分页器</h4><h4>14.5.1 将静态页面中的分页器摘出来做全局组件</h4><p>全局组件书写的位置：src-&gt;components-&gt;Pagination-&gt;myPagination.vue</p><p>在main.js中注册全局组件</p><h4>14.5.2 对自定义分页器使用假的数据进行调试</h4><p>在父组件Search.vue中通过自定义属性向子组件传递假数据：</p><ul><li>pageNo：当前是第几页的数据</li><li>pageSize：每一页有多少条数据</li><li>total：一共有多少条数据</li><li>continues：连续的页码数</li></ul><p>e.g. &lt; Pagination :pageNo&#x3D;”1” :pageSize&#x3D;”3” :total&#x3D;”91” :continues&#x3D;”5”&gt;&lt; &#x2F;Pagination&gt;</p><p>Q1: 如何算出连续页面的起始数字和结束数字？</p><p>Ans：这个地方需要考虑很多种情况。</p><ul><li>continues &gt; 一共的页数</li><li>continues &lt;&#x3D; 一共的页数 :<ul><li>出现负的页码数</li><li>超出totalPages</li><li>正常</li></ul></li></ul><p><img src="/img/%E5%88%86%E9%A1%B5%E5%99%A8%E8%BF%9E%E7%BB%AD%E7%9A%84%E8%B5%B7%E5%A7%8B%E9%A1%B5%E6%95%B0%E5%92%8C%E7%BB%93%E6%9D%9F%E9%A1%B5%E6%95%B0.png" alt="code"></p><h4>14.5.3 向服务器发送请求真实的数据动态展示</h4><p>我们将分页器的结构分为三部分：</p><ul><li>上一页 + 1 + …</li><li>中间的连续页数部分</li><li>… + totalPages + 下一页</li></ul><p>这个时候我们要分别考虑这三块的显示与隐藏：</p><ol><li>考虑中间的部分： 将start和end中间的数字push到一个数组中，用v-for遍历展示。</li><li>第一部分：<ul><li>1：如果start &gt; 1就显示</li><li>… : 如果start &gt; 2就显示</li></ul></li><li>第二部分：<ul><li>totalPages :  如果end&lt;totalPages就显示</li><li>… : 如果end &lt; totalPages - 1就显示</li></ul></li></ol><p>为每个button添加点击事件，通过自定义事件向父组件传递pageNo，父组件向服务器请求数据，将父组件Search中传递的数据替换成服务器返回的数据。</p><h3>15. Home首页</h3><p>在Home首页，我们可以从服务器请求回来的数据只有三级联动里面的数据。</p><p>其他的数据服务器都不提供，就需要<mark>模拟mock</mark>数据，这里利用第三方插件<mark>mock.js</mark>: <mark>生成随机数据，拦截Ajax请求</mark>。</p><p>也就是说前端mock的数据不会和服务器进行任何的通信。</p><p>首先，在我们的项目中安装mock.js： </p><p>mock.js的使用步骤： </p><ul><li><p>src下创建mock文件夹，在文件夹中创建相应的json文件</p></li><li><p>将mock数据需要的图片放到public文件夹中</p></li><li><p>在mock文件夹下创建mockServe.js来进行相应的配置。</p><ul><li><p>引入mockjs</p></li><li><p>引入两个json文件</p><p>注意！！！<mark>webpack默认json文件是对外暴露的</mark></p></li><li><p>Mock.mock(rurl,template): 当拦截到匹配rurl的ajax请求时，将根据数据模板template生成模拟数据并作为响应数据返回。</p></li></ul></li><li><p>将我们的mockServe.js文件在入口文件main.js中引入</p></li></ul><h4>15.1 ListContainer组件</h4><p>在mounted生命周期函数中发请求，mock回来的数据用vuex存储到仓库中。</p><p>现在有了数据了，要开始对轮播图进行动态的展示。</p><ul><li><p>引入swiper的js和css</p></li><li><p><span class="red">new Swiper实例</span>（新版本的Swiper可能不是这种写法了）</p><p>问题！！！！我发现在mounted中写这个new Swiper不起效果！！！！</p><p>原因v-for！！！！是动态创建的！！！！！！！！！！！！！！！前提是服务器返回了数据我才能生成对应的DOM，这是异步的！！！！！</p><p>【解决】：<mark>watch+nextTick</mark></p><ul><li><p><mark>watch对bannerList进行监听</mark>：从初始化的空数组到接收到服务器返回来的数据，定义handler函数，函数内部肯定是在已经拿到了数据的基础上进行操作的。</p><p>但是还不行!!!!!!</p><p>原因：还是因为结构的问题。当前的handler执行了只能保证有数据，但是v-for动态的往上渲染不能保证完毕。</p></li><li><p><mark>$nextTick</mark>: 在下次DOM更新循环结束之后执行延迟回调。<mark>在修改数据后立即使用这个方法获得更新后的DOM</mark>。</p></li></ul></li></ul><p><img src="/img/%E8%BD%AE%E6%92%AD%E5%9B%BEcode.png" alt="code"></p><p>问题：<mark>vue中尽量不使用原生的这个js获取元素的写法！！！</mark></p><p>改进：<strong>使用ref引用啊！！！</strong></p><p>给container添加ref属性&#x3D;”myswiper“，</p><p><img src="/img/improvement.png" alt="ref引用"></p><h4>15.2 Floor组件</h4><p>和上面15.1的逻辑大差不差，不做过多展示。</p><h3>16. 详情页</h3><p>src-&gt;pages-&gt;Detail-&gt;myDetail.vue</p><h4>16.1 注册为路由组件</h4><p>在router-&gt;index.js中引入Detail组件并且在routes数组中添加路由规则。注意要用id占位。在路由跳转带上id。</p><h4>16.2 解决在搜索页最底部点击商品跳转到详情页滚轮还在底下的问题</h4><p>利用Vue路由进阶-<mark>滚动行为scrollBehavior</mark>，注意和routes平级</p><p> scrollBehavior(to, from, savedPosition) {</p><p>  &#x2F;&#x2F;return 期望滚到的地方</p><p>  return { y: 0 }</p><p> }</p><h4>16.3 <i class="fa-solid fa-magnifying-glass"></i>放大镜功能的实现</h4><h4>16.3.1 放大镜的布局</h4><p>![放大镜.png]</p><p>通过.event:hover触发.big和.mask的显示</p><p><i class="fa-solid fa-magnifying-glass"></i>其中.big通过定位left：100%，overflow：hidden和提升z-idex&#x3D;999使得在盒子右侧压住其他内容显示。</p><p>其中的img就需要将width和height设置为200%，又因为本身img容器.big是overflow：hidden就会模拟出放大镜的效果嘞！！！！</p><h4>16.3.2 绑定mousemove事件使得mask随着鼠标移动</h4><p>在上述样式中，我们的mask的位置是写死的，现在需要给event添加mousemove事件，触发时使得mask随着鼠标移动。</p><p><span class="red">核心思想</span>：<mark>通过ref引用拿到mask的DOM对象的定位的left和top属性，将其改写为鼠标当前坐标（offsetX&#x2F;offsetY) - 1&#x2F;2(mask自身宽度offsetWidth&#x2F;高度)</mark></p><p>这里注意<u>clientX&#x2F;offsetX&#x2F;pageX的区别</u>：<a href="https://www.jianshu.com/p/a52077e8369d">https://www.jianshu.com/p/a52077e8369d</a></p><p>还需要注意：<u>对于没有设置宽度的元素或者是css设置宽度非内嵌式的，DOM.style.width并不能拿到宽度值，只能设置宽度值。<span class="red">只能通过offsetWidth拿到宽度</span>。</u></p><p>【问题：还需要对mask的范围进行约束】</p><p>top和left同理，只拿left记录：</p><ul><li>异常1：left&lt;&#x3D;0, 直接强制赋值left&#x3D;0</li><li>异常2：left&gt;&#x3D; 盒子宽度 - mask自身宽度（这时候mask的右侧边边超出去了！！），强制赋值left&#x3D;这个最大的left值</li></ul><h4>16.3.3 根据mask修改好的left和top修改大图定位的坐标</h4><p>注意现在大图big是按照2倍进行放大，那么left和top值也得是2倍！</p><h4>16.4 <i class="fa-solid fa-cart-shopping"></i>加入购物车功能的实现</h4><h4>16.4.1 购买产品个数操作</h4><p>给input表单元素绑定<mark>v-model</mark>,数据双向绑定！！</p><p>给+和-添加点击事件，给个数做+1和-1操作，需要注意个数的取值范围，必须大于等于1。</p><p>现在我们还希望用户可以自己输入购买的个数，那么就要注意判定输入的合法性啦~~</p><p><mark>为input表单绑定change事件</mark>，在文本框中的值发生变化且丧失焦点时触发。</p><p>（这个操作存在的合理性就在于：我们使用v-model双向绑定后不管用户输入什么都可以直接赋值给skuNum，但是我们想通过change事件的处理函数先检查<mark>e.target.value</mark>的合法性再存。）</p><ul><li><p>Q: 如何判断用户输入的带字符？</p><p>A: 文本 * 1 只要是Nan就是！！！</p><p><img src="/img/testStr.png" alt="测试"></p><p>数字字符串*1是数字本身，只要带有其他字符的 * 1就是Nan</p></li></ul><h4>16.4.2 点击加入购物车需要实现的功能</h4><ol><li><p>向服务器发送请求，将产品加入到数据库</p></li><li><p>若服务器存储成功，进行带参路由跳转</p><p>需要传递的太多了，如果通过query传参，url地址贼混乱</p><p>考虑query传参只带个数，结合<mark>会话存储</mark>传递产品信息数据（复杂）</p><p>不考虑localStorage的原因：有上限（5M左右）、且持久化（购物的信息不需要一直存储在本地）</p><p>但是我本来想把skuInfo这个对象直接存储在sessionStorage里的！！失败了！！</p><p><mark>localStorage和sessionStorage都不能存储对象！！都是按键值对存储字符串！！存储的时候使用JSON.stringfy()将对象转化为字符串再存！！！从storage中取的时候也得用JSON.parse()将字符串再转化为对象进行使用！！！</mark></p></li><li><p>若服务器存储失败，给用户进行提示</p><p>catch(error) {alert(error.message)}</p></li></ol><h3>17. <i class="fa-solid fa-cart-shopping"></i>加入购物车成功页面</h3><ul><li><p>通过点击查看商品详情回退到详情页：</p><p>两种思路：</p><ul><li>绑定点击事件，处理函数中this.$router.go(-1)回退到上一页</li><li>利用声明式导航router-link带着id参数进行跳转</li></ul></li><li><p>通过点击去购物车结算的按钮： 路由跳转到 ‘&#x2F;shopcart’, 展示ShopCart组件</p></li></ul><h3>18. <i class="fa-solid fa-cart-shopping"></i>购物车页面</h3><p>第一步还是熟悉的操作啊…  </p><p>向服务器发送请求获取购物车的数据+操作vuex三连环+拿到数据在组件中动态的展示数据</p><p>还是同样的问题！！！注意<mark>this.$store.dispatch派发actions要写在methods的某个函数中，可以多次调用获取数据！！！不能写在mounted周期函数中</mark></p><p>可是现在的问题是我们发现：<strong>从服务器返回的数据是个空数组</strong></p><p>why？</p><p><mark><strong>问题出在了16.4.2添加购物车这个步骤</strong></mark>，<strong>我们需要再额外传递用户身份的信息</strong>！！！</p><p>身份有两种：登录了的用户 &#x2F;  游客身份</p><h4>16.6.1 增加detail模块中加入购物车功能时传递的参数</h4><p>利用<mark>uuid第三方库</mark>生成唯一的用户id来标识不同用户。</p><p>由于现在我们希望每个用户作为游客身份的时候不管何时再次浏览都是同样的ID！！！考虑<mark>localStorage</mark>！！</p><p>在src下新建<strong>utils文件夹</strong>，常放项目中的功能模块，如正则、临时身份等等。</p><p>但是uuid()方法每次调用都会生成一个新的唯一的标识id，我们希望可以对于一个用户只生成唯一的<strong>一个</strong>标识！！</p><p>解决：先判断本地存储有没有，没有就用uuid生成并存储，有了就直接getItem！</p><p>Q：如何在发送请求时带上用户身份id？</p><p>A：<mark>在请求头中加入UUID标识！</mark></p><p>在请求拦截器中配置，代码如图</p><p><img src="/img/%E8%AF%B7%E6%B1%82%E5%A4%B4.png" alt="code"></p><h4>16.6.2 利用计算属性才完成全选按钮的状态</h4><p>一开始没思路，记得todolist就是这个操作！！！</p><p>对产品array进行遍历！！<mark>用array.every更简单</mark></p><p>return this.cartInfoList.every(item &#x3D;&gt; item.isChecked &#x3D;&#x3D; 1)  &#x2F;&#x2F;evey方法发现数组的每一个都是勾选的状态就会返回true，不然返回false</p><h4>16.6.3 点击+-对产品购买数量进行修改</h4><p>这个地方除了需要完成对数量的修改操作外，还需要注意，每点击一次都需要<strong>发送请求</strong>，告诉服务器购物车模块里的数据变化。然后再从服务器获取最近的数据再展示。</p><p>现在我们发现<span class="red">不管点击+还是-还是在input中修改数量最终都会触发同一个action</span>，注意在方法中传递参数可以给三种不同的操作区分开。</p><p>另外！！！！！！为了避免用户点的太快！！！！！！！！！！<mark>用上节流</mark>（还是熟悉的节奏，引lodash）</p><h4>16.6.4 在购物车中删除某产品</h4><p>这里发送请求的方式是<mark>DELETE</mark>。</p><h4>16.6.5 删除全部选中的商品和全部商品勾选</h4><p>对于这种需要一键删除全部或者选中宣布的功能，肯定是需要遍历我们的购物车数据存放的数组的。</p><p>但是我们现在的actions里只有一次删除一条或者一次勾选上一条的函数，那么<span class="red">大体的思路</span>就是<strong>遍历数组，符合条件的多次派发action</strong></p><p>我们想在一个action中派发另一个action并且想拿到全部的购物车商品数据：就需要在<strong>占位中解构出{dispatch，getters}</strong></p><p>我们每次派发action都会有一个promise返回值，那我们怎么在我们现在的点击事件中拿到唯一的返回的promise值呢？</p><p><mark>利用Promise.all([p1,p2,…])方法！！！</mark>数组中都是promise，只有都为成功时，Promise.all就会返回成功，有一个失败就是失败啦~</p><p><img src="/img/%E4%B8%80%E9%94%AE%E5%85%A8%E9%83%A8.png" alt="code"></p><h2>19. 登录注册页面</h2><h3>19.1 注册页面</h3><h4>19.1.1 点击按钮获取验证码</h4><p>业务逻辑：点击按钮发送请求，需要携带的参数就是用户第一行填写的手机号值。</p><h4>19.1.2 点击完成注册按钮进行跳转</h4><p>业务逻辑：点击完成注册，先向服务器发送请求，如果成功就跳转到登录页，失败就停在注册页。</p><h3>19.2 登录页面</h3><h4>19.2.1 token</h4><p>现在我们点击登录按钮，带着手机号和密码向服务器发送请求，服务器成功的data里面会返回一个<mark>token</mark>。</p><p><strong>token</strong>：<strong>令牌</strong>，是<span class="red">用户的唯一标识符</span>。</p><p><strong>前台需要持久化存储这个token</strong>，这样的话我们就可以拿着token去找服务器要这个用户的各种数据了。</p><p>Q1：我们向服务器发送了登录请求后，服务器成功返回唯一的用户标识token，我们现在只是在vuex的仓库中进行存储，but！！！<mark>vuex并不能持久化存储</mark>，一刷新就没了，我们想持久化存储token怎么办？</p><p>Ans1：拿到token就存在localStorage中</p><p>Q2：我们在发送请求得到res&#x3D;&#x3D;200后，进行路由跳转到home组件，还是和之前一样！！怎么才能展示用户名和退出登录的部分呢？</p><p>Ans2：还需要<span class="red">带着token</span>再次向服务器发送请求555555，api: &#x2F;user&#x2F;passport&#x2F;auth&#x2F;getUserInfo,get请求。因为接口没有占位，我们想get还带参数的话，用<span class="red">请求头</span>带进去。<mark>注意派发action的时间是在主页的mounted渲染好后派发！</mark>在Header组件中，需要根据有无用户信息来<span class="red">动态展示左上角登录的地方</span>，考虑v-show&#x2F;v-if</p><h4>19.2.2 退出登录</h4><p>需要做的事情：</p><ul><li>发请求，通知服务器清除一些数据如token</li><li>清除前台项目里的数据如token、userInfo等</li><li>退出成功就回到首页</li></ul><h3>19.3 导航守卫</h3><p>导航守卫：可以控制路由的访问权限。</p><p>分为：全局导航守卫、路由独享守卫、组件内守卫</p><p>全局守卫又分：全局前置守卫、全局解析守卫和全局后置守卫</p><p>我们在这里使用<mark>全局前置守卫，router.beforeEach(to,from,next)</mark></p><p>待解决问题1：现在用户已经登录了但是还能跳转到login页面</p><p>解决：通过登录用户才有token来判断！再进行全局守卫的判断和放行。</p><p>if(token) {</p><p>​&#x2F;&#x2F;成功登录的状态</p><p>​if(to.path &#x3D;&#x3D; ‘&#x2F;login’) {   <mark>通过to.path来判断去哪！！</mark></p><p>​next(‘&#x2F;‘)}</p><p>​else{</p><p>​&#x2F;&#x2F;去除了login以外的其他页面</p><p>​if(name) {</p><p>​next()}</p><p>​else {</p><p>​&#x2F;&#x2F;没有用户信息</p><p>​try {</p><p>​await store.dispatch(‘getUserInfo’);</p><p>​next()} catch(error) {</p><p>​&#x2F;&#x2F;有token但是捞不到用户的信息！！！（有可能token国企捏）先清空信息再跳到login界面</p><p>​await store.dispatch(‘logOut’);</p><p>​next(‘&#x2F;login’)}</p><p>​}}</p><p>}</p><p><mark>路由独享守卫</mark>：<span class="red">beforeEnter: (to, from, next) &#x3D;&gt; {}</span></p><p>现在我们希望对于想跳到trade的路由必须得从shopcart购物车跳过来才行！！！</p><p>其他的就停留在原地，next(false)</p><p> {</p><p>   path: ‘&#x2F;trade’,</p><p>   component: Trade,</p><p>   meta: { show: true },</p><p>   &#x2F;&#x2F;路由独享守卫</p><p>   beforeEnter: (to, from, next) &#x3D;&gt; {</p><p>​    if (from.path &#x3D;&#x3D; ‘&#x2F;shopcart’) {</p><p>​     next()</p><p>​    } else {</p><p>​     next(false)</p><p>​    }</p><p>   },</p><p>  },</p><p>其他的同理，比如pay支付页必须从trade页跳来等等。</p><h2>20.交易页面</h2><h3>20.1 用户地址信息的显示</h3><p>在正常的发请求-&gt;vuex存数据-&gt;组件中捞并替换为动态展示的数据之后</p><p>我们希望可以实现点击哪个地址就给哪个地址加上被勾选的状态：<mark>排他</mark></p><p>且不管是点人还是点地址都想触发click，就<mark>委派</mark>给父亲p标签~~~</p><p>函数传递的参数 - 点击的address和数组addresses</p><p>给数组进行遍历全部清除相关样式，再给点击的那个添加样式</p><h3>20.2 提交订单</h3><p>之前都是固定操作：写api发请求，拿到数据写vuex，在组件中捞数据进行展示</p><p>现在想不用vuex，直接在组件中存数据。</p><p>但是我又不想在每一个组件中分别引用api里写好的方法，怎么才能将api里的方法暴露一次就全局可用了呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><p>想到了event bus！！和它类似操作</p><p>在<span class="red">main.js</span>中引入api中全部的请求函数</p><p>import * as API from ‘@&#x2F;api&#x2F;index.js’，这个对象就包含了所有的请求方法</p><p>然后<mark>Vue.prototype.$API &#x3D; API</mark>!!!!!直接挂载到vue原型对象的身上。所有的组件可以直接使用。</p><hr><p>但是在我们获取支付信息的时候，遇到了在mounted钩子函数中调用API发送请求，<mark>不要给周期函数加async</mark></p><p><span class="red">巧妙的解决办法：</span>在生命周期函数中写个this.某个函数，再在methods中声明这个方法即可~~~</p><h3>20.3 立即支付</h3><p>业务需求：点击立即支付会弹出一个担忧微信支付二维码的弹窗。</p><p>我自己写的话会采用加一个遮罩层再加上z-index。</p><p>这里用<mark>elementUI</mark>组件库的<mark>MessageBox弹框组件</mark>。</p><p>组件库总结：</p><p><strong>React</strong>:  pc - antd     移动 - antd-mobile</p><p><strong>Vue</strong>: pc - ElementUi   移动端 - vant</p><p>这个二维码支付成功与失败需要向服务器发送请求才能知道。</p><p>那么什么时候发？发几次？</p><p><i class="fa-solid fa-arrow-down"></i></p><p><span class="red">我们需要在展示二维码的时候<mark>用定时器</mark>一！！！直！！！！发！！！！</span></p><h3>20.4 查看订单</h3><p>点击查看订单跳转到个人中心</p><h2>21.个人中心页面</h2><h3>21.1 二级路由的搭建</h3><p><img src="/img/order%E4%BA%8C%E7%BA%A7%E8%B7%AF%E7%94%B1.png" alt="code"></p><p>注意二级路由的路径的写法！！</p><h3>21.2 请求我的订单的数据</h3><p>api：   ‘&#x2F;api&#x2F;order&#x2F;auth&#x2F;{page}&#x2F;{limit}’</p><p>注意何时向服务器发送请求要数据呢？</p><p><mark>有分页器需要每次点击都重新获取，所以不考虑写在mounted里，应该写在methods里，然后在mounted和每次点击分别调用</mark></p><h2>22.图片懒加载</h2><p><mark>利用插件：<a href="mailto:&#x76;&#x75;&#x65;&#45;&#108;&#x61;&#122;&#x79;&#108;&#111;&#x61;&#x64;&#x40;&#49;&#46;&#x33;&#x2e;&#x33;">&#x76;&#x75;&#x65;&#45;&#108;&#x61;&#122;&#x79;&#108;&#111;&#x61;&#x64;&#x40;&#49;&#46;&#x33;&#x2e;&#x33;</a></mark></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>projects</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6模块化与异步编程</title>
    <link href="/2023/07/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
    <url>/2023/07/17/ES6%E6%A8%A1%E5%9D%97%E5%8C%96%E4%B8%8E%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2>1. ES6模块化</h2><h3>1.1 前端模块化规范的分类</h3><p>在<span class="red">ES6模块化规范</span>诞生之前，js社区尝试提出AMD、CMD、CommonJS等模块化规范，但不在浏览器和服务器端通用，故产生了ES6模块化规范。</p><h3>1.2 什么是ES6模块化规范？</h3><p>ES6模块化规范是浏览器端与服务器端通用的模块化开发规范。ES6模块化规范中定义：</p><ul><li>每个js文件是一个独立的模块</li><li>导入其他模块成员使用import关键字</li><li>向外共享模块成员使用export关键字</li></ul><h3>1.3 ES6模块化中的<mark>默认导出与默认导入</mark></h3><ul><li>默认导出： export default 默认导出的成员</li><li>默认导入：import 接收名称（一个对象） from ‘模块标识符’</li></ul><h3>1.4 ES6模块化中的<mark>按需导出与按需导入</mark></h3><ul><li><p>按需导出：export 按需导出的成员</p></li><li><p>按需导入：import {xxx} from ‘模块标识符’</p></li></ul><hr><p><span class="red"><u>默认v.s.按需</u></span></p><ul><li>默认导出只能用一次，按需导出可以使用多次</li><li>导入默认导出成员可自定义名字，而导入按需导出的成员必须按照{按需导出成员名字（as xx）}的格式</li></ul><h2><i class="fa-sharp fa-solid fa-stars"></i>2. Promise</h2><h3>2.1 回调地狱的问题</h3><p>回调地狱：<strong>多层回调函数的相互嵌套</strong>就会形成回调地狱，难以理解和维护。</p><p>e.g. 基于回调函数的按顺序读取文件内容的代码</p><p><img src="/img/%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1.png" alt="回调地狱"></p><p>回调地狱的问题在于其使得代码难以扩展、理解和调试。</p><p>为了解决回调地狱的问题，ES6新增了<mark>Promise</mark>的概念。</p><h3>2.2 Promise的基本概念</h3><p>Promise是js中用于处理异步操作的对象，<span class="red">它代表了一个尚未完成但最终会完成的操作</span>。</p><ul><li><p><mark>Promise是一个构造函数</mark>:</p><p>const p &#x3D; new Promise(  (resolve, reject) &#x3D;&gt; {  &#x2F;&#x2F; p是一个Promise的实例对象，代表一个异步操作</p><p>​&#x2F;&#x2F; 异步操作  </p><p>​&#x2F;&#x2F; 如果操作成功，调用 resolve(value) </p><p>​    &#x2F;&#x2F; 如果操作失败，调用 reject(error) }) </p></li><li><p><mark>Promise.prototype上包含then()方法，用于预先指定成功和失败的回调函数</mark>：</p><p>p.then(</p><p>​(result) &#x3D;&gt; {</p><p>​&#x2F;&#x2F;处理操作成功的情况}，</p><p>​(error) &#x3D;&gt; {</p><p>​&#x2F;&#x2F;处理操作失败的情况}</p><p>)</p></li></ul><hr><p>在2.1中展示的读取文件操作是基于node.js官方提供的fs模块，但是fs仅支持以回调函数的方式读取文件，不支持Promise调用方式。</p><p>安装<span class="red">then-fs第三方包</span></p><p>调用then-fs的readFile()方法可以异步读取文件的内容，<span class="red">返回值是一个Promise实例对象</span>，再调用.then()方法为每一个异步操作指定成功和失败的回调函数。</p><p>e.g. 基于Promise的调用方式（不完善）</p><p><img src="/img/Promise1.png" alt="基于Promise的调用方式1"></p><p><span class="red">问题:</span> 一次性开启三个异步操作去读文件，哪个先读取完成是位置的，无法保证读取顺序</p><p><img src="/img/%E4%B8%80%E6%AC%A1%E6%80%A7%E5%BC%80%E5%90%AF%E4%B8%89%E4%B8%AA%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C.png" alt="问题"></p><p><i class="fa-solid fa-arrow-down"></i></p><p><mark>链式调用</mark>: Promise对象的<code>then()</code>方法可以返回一个新的Promise对象，使得可以使用链式调用来处理多个异步操作。这种方式可以避免回调地狱，使代码更加清晰。</p><p><img src="/img/Promise2.png" alt="Promise链式调用"></p><p>那么错误如何捕获？</p><p><i class="fa-solid fa-arrow-down"></i></p><p><mark>通过catch捕获和处理错误</mark>：</p><p><img src="/img/catch.png" alt="catch"></p><p>如果不希望前面的错误导致后续的.then()无法正常执行，可以将catch的调用提前。</p><h3>2.3 Promise.all()方法</h3><p>Promise.all()能够一次并行处理多个Promise异步操作，等所有的异步操作全部结束后才会执行下一步的.then()操作，也就是一个<span class="red">等待机制</span>。</p><p><img src="/img/PromiseAll.png" alt="Promise.all"></p><h3>2.4 Promise.race()方法</h3><p>Promise.race()方法会发起并行的Promise异步操作，只要任何一个异步操作完成，就会立即执行下一步的.then()操作，这里是<span class="red">赛跑机制</span>，顺序不定！</p><p><img src="/img/promiseRace.png" alt="Promise.race"></p><h2><i class="fa-sharp fa-solid fa-stars"></i>3. async / await</h2><h3>3.1 什么是async / await？</h3><p><mark>async &#x2F; await是ES8引入的语法，为了简化Promise异步操作</mark>。</p><p>在之前，我们只能通过<u>链式.then()</u>的方式处理Promise异步操作</p><p>虽然解决了回调地域的问题，但是代码仍然可读性差、不易理解</p><h3>3.2 async / await基本使用</h3><ul><li><mark>async</mark>: async是一个加在函数前的修饰符，被async定义的函数会默认返回一个Promise对象resolve的值。</li><li><mark>await</mark>: async修饰的函数本来应该返回一个Promise实例对象，加上await就会返回读取结果。</li></ul><p><img src="/img/asyncawait.png" alt="简化Promise异步操作"></p><hr><p>注：具体的Promise&amp;async&#x2F;await可以参考：</p><p><a href="https://javascript.info/async">https://javascript.info/async</a></p><h2>4. EventLoop</h2><h3>4.1 单线程语言</h3><p>Js是一门<span class="red">单线程执行</span>的编程语言。也就是说若前一个任务十分耗时，则后续任务都需要一致等待，导致<span class="red">程序假死</span>的现象。</p><h3>4.2 同步任务和异步任务的概念</h3><p>为了防止上述的程序假死问题，js把<u>待执行的任务</u>分成了两类：</p><ul><li><mark>同步任务</mark>： <span class="red">非耗时任务</span>，在主线程上排队执行的任务。特点就是前一个执行完毕才会执行后一个。</li><li><mark>异步任务</mark>： <span class="red">耗时任务</span>，由js委托给宿主环境进行执行。特点是当异步任务执行完成后，会通知js主线程执行异步任务的回调函数。</li></ul><h3>4.3 同步任务和异步任务的执行过程</h3><p><img src="/img/%E5%90%8C%E6%AD%A5%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="同步任务和异步任务的执行过程"></p><ul><li>同步任务由js主线程按次序执行</li><li>异步任务委托给宿主环境执行</li><li>已完成的异步任务对应的回调函数，会被加入到任务队列中等待</li><li>js主线程的执行栈被清空后，会读取任务队列中的回调函数，按次序执行</li><li>js主线程不断重复上面的步骤</li></ul><h3>4.4 EventLoop的基本概念</h3><p><mark>js主线程从“任务队列”中读取异步任务的回调函数并放到执行栈中依次执行</mark>。这过程是循环不断的，整个运行机制又称为EventLoop。</p><h2>5. 宏任务和微任务</h2><p><mark>js又将异步任务更一步划分为：宏任务和微任务</mark></p><h3>5.1 什么是宏任务和微任务？</h3><ul><li><mark>宏任务</mark>: macrotask，通常是一些比较耗时的操作<ul><li>异步Ajax请求</li><li>setTimeout、setInterval</li><li>文件操作</li><li>其他宏任务</li></ul></li><li><mark>微任务</mark>: macrotask，通常是一些轻量级的任务<ul><li>Promise.then()、catch()</li><li>process.nextTick</li><li>其他微任务</li></ul></li></ul><h3>5.2 宏任务和微任务的执行顺序</h3><p>每一个宏任务执行完都会检查是否存在待执行的微任务</p><p><img src="/img/%E5%AE%8F%E4%BB%BB%E5%8A%A1%E5%92%8C%E5%BE%AE%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg" alt="宏任务和微任务的执行顺序"></p><hr><p>事件循环的执行顺序：</p><ol><li>执行当前的同步任务。</li><li>检查微任务队列，按顺序执行所有微任务，直到微任务队列为空。</li><li>更新 UI 渲染（如果需要）。</li><li>执行下一个宏任务，从宏任务队列中取出一个宏任务执行。</li><li>回到步骤 2，继续执行微任务和宏任务，直到所有任务完成。</li></ol><hr><p>经典面试题：</p><p><img src="/img/%E9%A1%BA%E5%BA%8F%E4%BB%A3%E7%A0%81%E9%A2%98.png" alt="题"></p><p>ans: 1,5,6,2,3,4,7,8,9</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路由</title>
    <link href="/2023/07/16/%E8%B7%AF%E7%94%B1/"/>
    <url>/2023/07/16/%E8%B7%AF%E7%94%B1/</url>
    
    <content type="html"><![CDATA[<h2>路由</h2><h3>1. 前端路由的概念与原理</h3><h4>1.1 什么是路由？</h4><p><span class="red">路由（router)</span>：<span class="red">对应关系</span>。</p><h4>1.2 什么是前端路由？</h4><p><span class="red">Hash地址</span>与<span class="red">组件</span>之间的对应关系。</p><h4>1.3 SPA与前端路由</h4><p>SPA：single page application单页面应用，一个web网站只有唯一的HTML页面，所有组件的展示与切换都在这一个唯一的页面上进行。</p><p>所以：<span class="red">不同组件之间的切换需要通过前端路由来实现</span>。</p><h4>1.4 前端路由的工作方式</h4><ul><li>用户点击了页面上的<span class="red">路由链接</span></li><li>导致<span class="red">URL地址栏中的Hash值发生了变化</span></li><li>前端路由<span class="red">监听</span>到了Hash地址的变化</li><li>前端路由把当前Hash地址对应的组件<span class="red">渲染</span>到浏览器中</li></ul><h3>2. vue-router的基本使用</h3><p><mark>vue-router是vue官方给出的路由解决方案</mark></p><h4>2.1 vue-router的安装和配置</h4><ul><li><p><span class="red">安装vue-router</span>：vue-router3.x只能配合vue2.x使用；vue-router4.x只能配合vue3.x使用</p><p>如果是用脚手架vue-cli来快速创建项目的，若在创建时选择了router则不需要额外安装。若不选择router，则需要在项目中npm i vue-router@版本号 -S; </p></li><li><p><span class="red">创建路由模块index.js</span>：在src下和components节点平行创建router模块，在router中创建index.js</p><p><img src="/img/indexjs.png" alt="index.js"></p></li><li><p><span class="red">在main.js中导入并挂载路由模块</span>：</p><p><img src="/img/mainjsrouter.png" alt="main.js"></p></li><li><p><span class="red">声明路由链接和占位符</span>：在App根组件中，使用vue-router提供的<mark>router-link和router-view分别声明路由链接和占位符</mark></p><p><img src="/img/%E5%A3%B0%E6%98%8E%E8%B7%AF%E7%94%B1%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8D%A0%E4%BD%8D%E7%AC%A6.png" alt="声明路由链接和占位符"></p></li><li><p><span class="red">声明路由匹配规则</span>：在index.js路由模块中，通过<span class="red">routes数组</span>声明路由的匹配规则</p><p><img src="/img/%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99.png" alt="匹配规则"></p></li></ul><h4>2.2 路由重定向redirect</h4><p><strong>使用场景</strong>：用户在访问地址A的时候，强制用户跳转到地址C，从而展示特定的组件界面</p><p>e.g.: 用户访问’&#x2F;‘的时候，并没有对应的路由规则，通过<span class="red">redirect重定向属性</span>可以强制跳转到’&#x2F;home’，再渲染Home组件。</p><p>routes: [</p><p>​{path: ‘&#x2F;‘, <span class="red">redirect: ‘&#x2F;home’</span>}]</p><h4>2.3 嵌套路由</h4><p>可以通过路由实现组件的嵌套展示。</p><ul><li><p>在组件中通过router-link和router-view声明子路由链接和子路由占位符</p><p><img src="/img/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B11.png" alt="声明子路由链接和子路由占位符"></p></li><li><p>在路由模块index.js中通过<span class="red">children属性</span>声明子路由规则</p><p><img src="/img/%E5%B5%8C%E5%A5%97%E8%B7%AF%E7%94%B12.png" alt="声明子路由规则"></p></li></ul><p>问题：现在在Movie组件下有三个子路由链接，但是不管点击哪个都想展示的是Movie组件，还要写三遍子路由链接，如果有n条就要写n遍，<span class="red">路由规则复用性差</span></p><p><i class="fa-solid fa-arrow-down"></i></p><h4>2.4 动态路由</h4><p>动态路由：将Hash地址中<span class="red">可变的部分</span>定义为<span class="red">参数项</span>，从而提高路由规则的可复用性。</p><p>e.g. </p><p>{path: ‘&#x2F;movie&#x2F;1’, component: Movie},</p><p>{path: ‘&#x2F;movie&#x2F;2’, component: Movie},</p><p>{path: ‘&#x2F;movie&#x2F;3’, component: Movie}</p><p>可以写为：</p><p>{path: ‘&#x2F;movie&#x2F;<mark>:id</mark>‘, component: Movie}</p><p>其中，：id就是动态参数项</p><p>注意： hash地址中</p><ul><li>&#x2F; 后面的是<span class="red">路径参数</span>， 通过<span class="red">this.$route.params</span>访问</li><li>? 后面的是<span class="red">查询参数</span>，通过<span class="red">this.$route.query</span>访问</li></ul><h3>3. 声明式导航和编程式导航</h3><ul><li><span class="red">点击链接</span>实现导航的方式： <span class="red">声明式导航</span>，e.g.: 点击a链接跳转，vue项目中点击router-link等。</li><li><span class="red">调用API</span>实现导航的方式： <span class="red">编程式导航</span>，e.g.: 普通js中调用location.href跳转。</li></ul><h3>4. vue-router中的编程式导航API</h3><ul><li>this.$router.push(‘hash地址’)：跳转到指定hash地址，并增加一条历史记录</li><li>this.$router.replace(‘hash地址’)：跳转到指定hash地址，并替换掉当前的历史记录</li><li>this.$router.go(n): 实现导航的前进、后退</li></ul><hr><p><mark>$route和$router</mark></p><ul><li>this.$route是路由的“参数对象”</li><li>this.$router是路由的“导航对象”</li></ul><h3>5. 导航守卫</h3><p>导航守卫的作用：<span class="red">控制路由的访问权限</span></p><p>导航守卫的使用场景：e.g. &#x2F;main首页只有登陆后才能访问！</p><p><img src="/img/%E5%AF%BC%E8%88%AA%E5%AE%88%E5%8D%AB.jpg" alt="导航守卫"></p><h4>5.1 全局前置守卫</h4><p><strong>全局</strong>：全局生效</p><p><strong>前置</strong>：从hash地址A-&gt;B，在跳转前就会触发守卫</p><p><strong>全局前置守卫</strong>：每次发生路由的导航跳转时，都会触发全局前置守卫，可以对每个路由进行访问权限的控制。</p><p>在index.js中</p><p>const router &#x3D; new VueRouter({…}); &#x2F;&#x2F; 调用beforeEach方法即可声明全局前置守卫</p><p>router.beforeEach(fn)；&#x2F;&#x2F;每次路由导航发生跳转的时候都会触发fn回调函数</p><h4>5.2 守卫方法fn的形参</h4><p><span class="red">全局前置守卫的回调函数中接收3个形参</span></p><p><mark>router.beforeEach( (to, from, next) &#x3D;&gt; {xxx})</mark></p><ul><li>to: 将要访问的路由信息对象</li><li>from：将要离开的路由信息对象</li><li>next:  是一个<span class="red">函数</span>，<strong>调用<span class="red">next()表示放行，允许导航通过</span></strong>，具体next函数的几种调用方式如下：<ul><li>当用户拥有后台主页的访问权限，直接放行： next()</li><li>当用户没有后台主页的访问权限，强制调转到登录页面：next(‘&#x2F;login’)</li><li>当用户没有后台主页的访问权限，不允许调转到后台主页： next(false)</li></ul></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自定义指令</title>
    <link href="/2023/07/16/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/"/>
    <url>/2023/07/16/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2>自定义指令</h2><h3>1. 什么是自定义指令？</h3><p>Vue官方提供了v-text, v-for, v-if, v-bind, v-slot等常用的<span class="red">指令</span>。</p><p>除此以外，Vue还<strong>允许开发者自定义指令</strong>。</p><p>在Vue中，自定义指令分为两类：</p><ul><li>私有自定义指令（在组件内部）</li><li>全局自定义指令</li></ul><h3>2. 私有自定义指令</h3><p>在每个vue组件中，可以在<span class="red"><mark>directives节点</mark></span>下声明私有自定义指令。</p><h4>2.1 钩子函数bind</h4><p>bind只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。</p><p>directives: {</p><p>​xxxx:{&#x2F;&#x2F;这里是指令的名字，比如：color</p><p>​bind(el) { &#x2F;&#x2F; el: 指令所绑定的DOM元素对象</p><p>​el.style.color &#x3D; ‘red’;</p><p>}}}</p><hr><p>问题：v-bind&#x3D; “”可以动态绑定参数值，那么自定义的指令可以吗？</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>2.2 为自定义指令动态绑定属性值</h4><p><img src="/img/bind.png" alt="自定义指令动态绑定属性值"></p><h4>2.3 钩子函数update</h4><p>2.1中的bind函数只会在指令第一次绑定到元素上时调用，<span class="red"><strong>update</strong></span>函数会在每次DOM更新时被调用。</p><p>directives: {</p><p>​color:{</p><p>​bind(el,binding) { </p><p>​el.style.color &#x3D; binding.value;},</p><p>​<span class="red">update(el,binding) {</span></p><p>​…}</p><p>}}</p><h4>2.4 钩子函数简写</h4><p>在上述代码中，如果钩子函数bind和update中的逻辑完全相同，<span class="red"><strong>对象格式的自定义指令简化为函数格式</strong></span>。</p><p>directives: {</p><p>​color(el, binding) {  &#x2F;&#x2F;所有的钩子函数都会触发相同的业务逻辑</p><p>​el.style.color &#x3D; binding.value</p><p>}}</p><h3>3. 全局自定义指令</h3><p><mark>在main.js中定义和<span class="red">全局</span>相关的！！</mark></p><p>（这里可以类比全局过滤器）</p><h4>3.1 声明函数格式的全局自定义指令</h4><p>Vue.directive(‘color’, function(el, binding) {</p><p>​el.style.color &#x3D; binding.value})</p><p>这里和私有自定义指令相同，当钩子函数的逻辑完全相同，则可以简写成这样的函数格式。</p><h4>3.2 声明对象格式的全局自定义指令</h4><p>当不同的钩子函数时期会进行不同的操作，则需要改造成对象形式：</p><p>Vue.directive(‘color’, {</p><p>​bind(el, binding) {</p><p>​el.style.color &#x3D; binding.value},</p><p>​update(el, binding) {</p><p>​el.style.color &#x3D; binding.value}</p><p>})</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插槽</title>
    <link href="/2023/07/16/%E6%8F%92%E6%A7%BD/"/>
    <url>/2023/07/16/%E6%8F%92%E6%A7%BD/</url>
    
    <content type="html"><![CDATA[<h2>插槽</h2><h3>1. 插槽的定义</h3><p>插槽：Vue为<mark>组件的封装者</mark>提供的能力。允许开发者在封装组件时，把<strong>不确定的、希望由用户指定的部分</strong>定义为插槽。</p><p>【理解】：组件封装期间为用户预留的内容占位符。</p><h3>2. slot标签的使用</h3><p>之前我们使用组件时，在标签中间没有任何内容，比如&lt; Left&gt;&lt; &#x2F;Left&gt;，如果在封装Left组件时预留了插槽slot，则可以在标签中加内容！</p><p><img src="/img/slot.png" alt="slot标签"></p><p>如果在Left组件中没有slot插槽，则在使用者App中Left标签中的p标签则不会显示。</p><h3>3. 后备内容插槽</h3><p>如果用户没有指定插槽的具体内容是什么，那么插槽的位置就展示默认内容（后备内容）</p><p><img src="/img/%E5%90%8E%E5%A4%87%E5%86%85%E5%AE%B9.png" alt="后备内容"></p><p>那如果在封装组件的时候预留了多个插槽节点，如何将我想指定的内容插入到某个具体的插槽中？</p><p><i class="fa-solid fa-arrow-down"></i></p><h3>4. 具名插槽</h3><p>slot元素中的<span class="red">name属性</span>可以定义和区别不同的插槽。</p><p>如果&lt; slot&gt;不带name属性值，则默认为<strong>default</strong>。</p><p>怎么在使用组件时插入指定的插槽？</p><p><i class="fa-solid fa-arrow-down"></i></p><p><mark>v-slot指令</mark></p><p><del>&lt; p v-slot&#x3D;”s1”&gt;</del></p><p><mark>v-slot只能在<span class="red">组件</span>或者是<span class="red">template标签</span>中使用</mark></p><p>其中，template标签只是一个虚拟的标签，起到<strong>包裹性质</strong>的作用，不会被渲染成任何实质性的html元素。</p><p><img src="/img/%E5%85%B7%E5%90%8D%E6%8F%92%E6%A7%BD.png" alt="具名插槽"></p><h3>5. 作用域插槽</h3><p>slot本身是有作用域的，即父作用域和子作用域，它们是各自渲染的，也就是说，父作用域无法拿到子作用域中的数据</p><p>那么有时候我们希望在父作用域拿到子作用域的数据或者对子组件的显示进行控制怎么办？</p><p><i class="fa-solid fa-arrow-down"></i></p><p><img src="/img/%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%8F%92%E6%A7%BD.png" alt="作用域插槽"></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态组件</title>
    <link href="/2023/07/16/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/07/16/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2>Vue中的动态组件</h2><h3>1. 什么是动态组件</h3><p>动态组件：动态切换组件的显示与隐藏</p><p>使用场景：需要的组件不确定时，就可以使用动态组件的方式生成，例如接收到文本数据就生成文本组件，接收到图片数据就生成图片组件。</p><h3>2. 动态组件的渲染</h3><p>vue提供了一个<mark>内置的&lt; component &gt;组件</mark>，通过<mark>is属性动态指定想要渲染的组件</mark>。</p><p>可以把&lt; component &gt;组件<span class="red">看作占位符！</span></p><p><img src="/img/%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6%E6%B8%B2%E6%9F%93.png" alt="动态组件渲染"></p><h3>3. keep-alive组件</h3><p>问题：在Left组件中展示的count值++到4，切换到Right组件再切换回来就会重置为0。</p><p>原因：每一个发生组件的切换时，<u>被隐藏的组件默认被销毁，被展示的组件默认被创建</u></p><p>办法：使用vue内置的<mark> &lt; keep-live &gt; </mark>组件保持动态组件的状态。</p><h4>3.1 keep-alive组件用法</h4><p><img src="/img/keep-alive.png" alt="keep-alive组件"></p><h4>3.2 keep-alive组件的include属性</h4><p>keep-alive组件默认会将占位符可以展示的组件都进行缓存，使用<span class="red">include属性</span>可以用来指定名称匹配的组件才会被缓存</p><p>e.g. &lt; keep-alive include&#x3D;”MyLeft” &gt;</p><p>​&lt; component  :is&#x3D;”comName” &gt;&lt; &#x2F;component&gt;</p><p>​  &lt; &#x2F;keep-alive&gt;</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ref引用</title>
    <link href="/2023/07/14/ref%E5%BC%95%E7%94%A8/"/>
    <url>/2023/07/14/ref%E5%BC%95%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2>Vue中的ref引用</h2><p>Vue中一个很大的优势就是不用操作DOM，只需要把数据维护好，但是如果<u>想要在vue中拿到页面中某个DOM元素或者组件的引用</u>就需要使用ref引用。</p><h3>1. $refs</h3><p>所以$开头的都是vue内置成员。</p><p>在每个vue的组件实例上，都包含一个<span class="red"><mark>$refs对象</mark></span>，里面存储着对应的DOM元素或者组件的引用，默认组件的$refs指向一个空对象。</p><h3>2. 使用ref引用DOM元素</h3><ul><li>为DOM元素添加ref属性，命名为引用名称</li><li>通过<span class="red">this</span>就能操作这个对象了</li></ul><h3>3. 使用ref引用组件实例</h3><ul><li>为组件添加ref属性，命名为引用名称</li><li>通过<span class="red">this</span>就能引用，可以调methods中的方法</li></ul><hr><p><img src="/img/ref.png" alt="ref"></p><hr><h3>4. this.$nextTick(callback)方法</h3><h4>4.1 背景</h4><p>组件的$nextTick(callback)方法，会把callback回调函数<span class="red">推迟到下一个DOM更新周期之后再执行</span></p><p>也就是，等组件的DOM更新完成之后，再执行callback回调函数，从而<span class="red">保证callback可以操作到最新的DOM元素</span>。</p><h4>4.2 实例</h4><p><img src="/img/nextTick.png" alt="$nextTick"></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>组件间的数据共享</title>
    <link href="/2023/07/14/%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/"/>
    <url>/2023/07/14/%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h2>组件间的数据共享</h2><h3>1. 父子组件间的数据共享</h3><h4>1.1 <mark>父组件向子组件：使用自定义属性</mark></h4><p>核心思想：在父组件中通过自定义属性和v-bind传递，在子组件中用props接收并使用</p><h4>1.2 <mark>子组件向父组件：使用自定义事件</mark></h4><p>核心思想：在子组件中通过<span class="red"><strong>$emit(事件名称，参数)</strong></span>来触发这个自定义事件</p><hr><p><img src="/img/%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE.png" alt="父子之间的数据传递"></p><hr><h3>2. <mark>兄弟组件间的数据共享:通过EventBus</mark></h3><p>兄弟组件之间的数据共享方案是EventBus，可以借助第三方的js库<span class="red">mitt</span>来创建eventbus对象从而实现数据共享。</p><p><mark>接收方调用on方法，声明自定义事件，通过事件的回调接收数据</mark></p><p><mark>发送方调用emit方法，发送数据</mark></p><p><img src="/img/eventbus.png" alt="eventbus"></p><h3>2. <mark>后代组件间的数据共享:通过provide和inject</mark></h3><p>后代组件：<u>父组件向子孙组件共享数据</u></p><p><img src="/img/%E5%AD%90%E5%AD%99%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB.png" alt="父组件向子孙组件共享数据"></p><h3>3. vuex</h3><p>对于小型应用或者是简单状态管理需求，使用上述机制即可，但是对于中大型复杂应用需要更强大的状态管理能力，需要借助vuex。</p><p>vuex的优点：</p><ul><li>集中式状态管理：Vuex提供了一个全局的状态树（store）来存储应用程序的状态，而不是将状态分散在各个组件中。</li><li>状态共享和访问：vuex允许在任何组件中直接访问和修改状态数据，而不需要通过props或事件传递</li><li>响应式更新： 当状态发生变化时，使用Vuex的组件会自动响应状态的更新</li><li>状态的改变是可追踪的：在Vuex中，所有对状态的修改都通过提交(mutations)来进行，这使得可以清楚地追踪状态的变化历史。对于调试和故障排除非常有帮助，并且可以通过时间旅行工具来回退到先前的状态。</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>生命周期</title>
    <link href="/2023/07/14/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/07/14/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<h2>组件的生命周期</h2><h3>1. 生命周期定义</h3><p>生命周期Life Circle: 是指一个组件从<span class="red">创建、运行、销毁</span>的整个过程。强调一个时间段！</p><h3>2. 生命周期函数</h3><p>生命周期函数是vue框架提供的<span class="red">内置函数</span>，伴随组件的生命周期<u>自动按次序执行</u>。</p><p>这些叫做<strong>生命周期钩子</strong>的函数，可以给用户在不同阶段添加代码的机会。</p><p><mark>钩子名固定，与data和methods属于平级的关系</mark></p><h4>2.1 vue2.x生命周期函数</h4><p><img src="/img/vue2.x%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vue2.x生命周期"></p><hr><ul><li>beforeCreate(): 在实例初始化之后，但数据代理还没开始，故<strong>无法通过vm访问到data中的数据和methods中的方法</strong></li><li><span class="red">created()</span>: 在实例创建完成后被立即同步调用</li><li>beforeMount(): 在挂载开始之前被调用，页面呈现<strong>未经vue编译的DOM结构，所有DOM操作都不奏效</strong></li><li><span class="red">mounted()</span>: 组件初次在页面中渲染完毕后</li><li>beforeUpdate(): 数据发生改变后，在DOM被更新之前调用</li><li><span class="red">updated()</span>: 在数据更改导致的虚拟DOM重新渲染和更新完毕后执行</li><li>调用vm.$destroy()才会销毁</li><li>beforeDestroy(): 实例销毁前调用，这里实例完全可用，可以访问数据也能调用方法，但数据的修改不会触发更新了</li><li>destroyed(): 所有的指令解绑，事件监听器被移除。</li></ul><hr><p><mark>常用的钩子函数：</mark></p><ul><li><code>mounted</code>: 发送ajax请求、启动定时器、绑定自定义事件、订阅消息等【<strong>初始化操作</strong>】。</li><li><code>beforeDestroy</code>: 清除定时器、解绑自定义事件、取消订阅消息等【<strong>收尾工作</strong>】。</li></ul><p>reference：<a href="https://blog.csdn.net/qq_45890970/article/details/123120797">(70条消息) Vue2生命周期详细讲解——周期图示、代码演示变化_vue2 vue-router生命周期_焦妮敲代码的博客-CSDN博客</a></p><hr><h4>2.2 vue3.x生命周期函数</h4><p><img src="/img/vue3%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="vue3.x生命周期"></p><hr><p>我们可以发现，vue3.x的钩子函数和2.x大部分相同，只是最后<strong>实例销毁</strong>有不同。</p><p>reference：<a href="https://blog.csdn.net/f_fengzilin/article/details/116458929">(70条消息) Vue2.和Vue3.生命周期的区别，对比。 详解生命周期中的每个钩子函数，setup,_南工gjl的博客-CSDN博客</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue组件</title>
    <link href="/2023/07/10/vue%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/07/10/vue%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3>1. 组件化开发</h3><p>根据<span class="red">封装</span>的思想，把页面上<span class="red">可复用的UI结构</span>封装为组件，从而方便开发和维护。</p><h3>2. Vue中的组件化开发</h3><p>Vue.js是一个支持组件化开发的前端框架，规定<span class="red">组件的后缀名为.vue</span></p><h3>3. Vue组件的组成部分</h3><p><span class="red">注意：</span>按下面的顺序！！！</p><ul><li><p><mark>template</mark>：组件的模板结构（UI结构）</p><p>vue2.x中template节点内的DOM结构仅支持单个根节点</p><p>vue3.x中支持多个根节点，就可以省略包裹性质的最外层的div了</p></li><li><p><mark>script</mark>：组建的js行为（js）</p><p>注意默认的写法，一打script就会默认出来</p><p>注意<span class="red">data</span>，要用函数的形式，定义在return对象里！！</p></li><li><p><mark>style</mark>：组件的样式（css）</p><p>默认是css语法，若想启用less等，则需要在style中添加lang属性，e.g. style lang&#x3D;”less”</p></li></ul><p><img src="/img/component.png" alt="组件的组成"></p><h3>4. 组件间的关系</h3><p>组件在封装好后，彼此之间是<strong>相互独立的</strong>，只是在使用组件的时候，根据<strong>彼此的嵌套关系</strong>，形成父子关系、兄弟关系。</p><h3>5. 使用组件</h3><ul><li>import导入组件</li><li>使用components节点注册组件</li><li>以标签形式使用注册好的组件</li></ul><h3>6.私有组件 v.s. 全局组件</h3><ul><li><p>通过<span class="red">components</span>注册的是私有子组件</p><p>私有：若在组件A的components下注册了组件F，则组件F只能在组件A中使用，若组件C也想使用还需要上述三步骤</p></li><li><p>在<span class="red">main.js</span>中通过<span class="red">Vue.component(标签名，注册的组件名)</span>注册全局组件</p><p>全局：在main.js中注册后可以直接在组件中用标签名进行使用</p></li></ul><p>但是如果使用组件的不同父组件想要传递的初始值不同，怎么办？</p><p><i class="fa-solid fa-arrow-down"></i></p><h3><i class="fa-duotone fa-stars"></i>7.组件的props</h3><p>props是组件的<span class="red">自定义属性</span>，在封装通用组件的时候，合理使用props可以<span class="red">提高复用性</span>,props允许使用者通过自定义属性为组件指定初始值。</p><h4>7.1 语法</h4><p>export default {</p><p>​<span class="red">props</span>:  [’自定义属性1‘，’自定义属性2‘，’自定义属性3‘…],</p><p>​data() {</p><p>​return {}</p><p>​},</p><p>​…</p><p>}</p><h4>7.2 props v.s. data</h4><p>首先，这两种都是vue中提供的存储变量的不同方法，那么区别是什么？</p><ul><li>data是每个组件内部的私有数据，只能在改组件内部使用</li><li>props是从父组件传递给子组件的数据，可以进行读取，<strong>但不能修改</strong></li></ul><p><i class="fa-solid fa-arrow-down"></i></p><h4>7.3 props的只读性</h4><p>vue中规定组件封装的自定义属性是<span class="red">只读的</span>，<u>不能直接修改props的值</u></p><p>如果想要修改props的值，<mark>将props的值转存到data中</mark>，因为data中的数据就是可读写的了~</p><p><img src="/img/props%E5%8F%AA%E8%AF%BB.png" alt="props"></p><p>但是注意在父组件传参的时候！！！！！</p><p>不适用v-bind就会传入的是字符串！！！！</p><p><mark>v-bind：init &#x3D; 1</mark></p><p><mark>注意：只有当字符串传递的时候才不用v-bind！！</mark></p><hr><p>reference：<a href="https://blog.csdn.net/it1993/article/details/104468677">https://blog.csdn.net/it1993/article/details/104468677</a></p><h4>7.4 props的default默认值</h4><p>在声明自定义属性时，可以通过<strong>default</strong>来定义<strong>属性的默认值</strong></p><p>在7.3中，props在定义时以数组的形式，但是如果还想再额外的定义默认值，需要改造成<span class="red">对象</span>的形式。</p><p><i class="fa-solid fa-arrow-down"></i></p><p>props: {</p><p>​init: {</p><p>​default: 0</p><p>}}</p><h4>7.5 props的type值类型</h4><p><span class="red">type</span>可以在封装组件时对外界传递进来的props数据进行<span class="red">合法性的校验</span></p><p><img src="/img/propsType.png" alt="type对props传进来的值进行校验"></p><h4>7.6 props的required必填项</h4><p>注意: required和默认值default无关，哪怕设置了default，只要使用者没有传参就报错。</p><h3>8.组件间的样式冲突问题</h3><p>默认情况下：<strong>写在.vue中的样式会<span class="red">全局生效</span></strong>，很容易造成多组件间样式冲突问题。</p><h4>8.1 造成样式冲突的根本原因</h4><ul><li>单页面应用程序中，所有组件的DOM结构都是基于<u>唯一的html页面</u>进行呈现的</li><li>每个组件中的样式，都会影响整个index.html中的DOM元素</li></ul><h4>8.2 如何解决？</h4><ul><li><p>办法一：给每个组件分配唯一的自定义属性，e.g. data-v-001，然后通过属性选择器来控制样式的作用域</p><p>【缺点：所有的UI结构都需要编码并添加自定义属性，开发效率地下】</p></li><li><p>办法二： <mark>给style节点添加scoped属性</mark></p><p>底层逻辑就是自动添加唯一的自定义属性</p><p>style scoped</p><p>那么给当前组件添加scoped属性，但对其子组件不生效怎么办？</p><p><i class="fa-solid fa-arrow-down"></i></p></li><li><p>办法三：样式穿透  &#x2F;deep&#x2F;</p><p>&#x2F;deep&#x2F; .title {xxx}</p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue脚手架vue-cli</title>
    <link href="/2023/07/09/vue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli/"/>
    <url>/2023/07/09/vue%E8%84%9A%E6%89%8B%E6%9E%B6vue-cli/</url>
    
    <content type="html"><![CDATA[<h3>1. 单页面应用程序SPA</h3><p>单页面应用程序Single Page Application(SPA)是指一个web网站中只有唯一的一个HTML页面，所有的功能和交互都在这个页面中。</p><p>Vue官方提供了<span class="red">Vue-Cli</span>为单页面应用SPA快速搭建繁杂的脚手架。</p><h3>2. Vue-cli简介</h3><p>Vue-cli是vue.js开发的标准工具，<u>简化了基于webpack创建工程化的Vue项目</u>。</p><h3>3. Vue-cli的安装与使用</h3><h4>3.1 安装</h4><p>Vue-cli是npm的一个全局包，使用npm install直接安装即可。</p><p>输入命令行vue -V，若出现版本号，则检验为安装成功。</p><h4>3.2 使用vue-cli创建项目</h4><ul><li>vue create 项目名</li><li>可以选择默认的vue2.x或者3.x设置的preset，也可以选择<u>手动选择特性</u>Manually select features</li><li>我选择了Babel可以向下兼容更低的版本和css预处理</li><li>in dedicated config files可以将Babel的插件配置项放到独立的配置文件中</li></ul><hr><p><img src="/img/src%E7%9B%AE%E5%BD%95.png" alt="src目录"></p><ul><li><mark>assets</mark>文件夹:  存放项目中用到的<span class="red">静态源文件</span>，如css样式表、图片等</li><li><mark>components</mark>文件夹： 程序员封装的，存放<span class="red">可复用的组件</span></li><li><mark>App.vue</mark>: 项目的根组件</li><li><mark>main.js</mark>:  项目的入口文件，<u>整个项目的运行都会先执行main.js</u></li></ul><h4>3.3 项目的运行流程</h4><p>在工程化的项目中，vue要做的事情很单纯：</p><p>通过<span class="red">main.js</span>把<span class="red">App.vue</span><strong>渲染</strong>到<span class="red">index.html</span></p><p>所以，App.vue就是用来编写带渲染的模板结构</p><p>index.html需要预留一个el区域</p><p>main.js将App.vue渲染到index.html中预留的区域中</p>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据的请求与发送</title>
    <link href="/2023/07/08/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%8F%91%E9%80%81/"/>
    <url>/2023/07/08/%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%8F%91%E9%80%81/</url>
    
    <content type="html"><![CDATA[<h2>1. ajax原生js方法下数据的请求与发送</h2><h3>1.1 ajax的简介</h3><p><span class="red">ajax: Asynchronous Javascript And XML</span>     异步JavaScript和XML</p><p>Ajax本身并不是一种技术，而是将现有的一些技术结合起来使用的方法：HTML、JS、XML、及其最重要的<span class="red">XMLHttpRequest对象</span>。</p><p>使用Ajax后，<mark>异步</mark>特性使得它与服务器通信、交换数据并更新页面而无需刷新页面。</p><p><span class="red">注</span>：尽管Ajax中的x代表XML，但是<span class="red">轻量的JSON</span>是首选。在Ajax中，JSON和XML都被用来包装信息。</p><h3>1.2 发送HTTP请求</h3><ul><li><p>为了使用js向服务器发送一个HTTP请求，我们需要一个包含必要函数功能的对象实例。</p><p>const httpRequest &#x3D; new XMLHttpRequest();</p></li><li><p>为了将请求发送到服务器，我们需要调用<mark>实例对象的<span class="red">open()</span>和<span class="red">send()</span>方法</mark>。</p><ul><li><p><strong>httpRequest.open</strong>(method,url,async)用来<span class="red">创建http请求</span>，开启数据传输通路</p></li><li><p><strong>httpRequest.send</strong>(string)用来<span class="red">发送请求给服务器</span></p></li></ul></li><li><p>为了判断请求是否发送到服务器，我们还需要调用<mark>实例对象的<span class="red">onreadystatechange</span>属性</mark></p><p><u>readyState</u>变化时就会触发这个事件</p><p>redayState共有5个状态值，重点是最后一个<span class="red">readyStare&#x3D;&#x3D;4</span>状态，此时ajax异步对象完全接收到服务器的响应信息，但响应状态码未必是正确的。</p><p>status &#x3D;&#x3D; 200 &#x2F; 404 &#x2F; 500</p><p><mark>注意：onload事件只能监听到readyState&#x3D;&#x3D;4的状态码，而onreadystatechange可以监听到2、3、4的状态码</mark></p></li></ul><p><img src="/img/%E5%8E%9F%E7%94%9FajaxGet.png" alt="get"></p><h3>1.3 发送POST请求</h3><ul><li><p>创建XMLHttpRequest实例</p><p>const xhr &#x3D; new XMLHttpRequest()</p></li><li><p>调用实例.open()创建请求</p><p><strong>xhr.open</strong>(method,url,async)</p></li><li><p><mark>设置请求头</mark>:  这是唯一和get方法区分开的地方！！</p><p><mark>content-type属性</mark>再post请求中尤为重要，<strong>用于定义网络文件的类型和网页的编码，决定浏览器将以什么形式、什么编码读取这个文件</strong>。（毕竟你要传数据，你要告诉人家你穿的数据啥格式嘛~）</p><p>常见的content-type属性值：</p><ul><li><p>application&#x2F;json：传递到后台的是序列化后的json字符串</p><p><mark>json</mark>: javascript obejct notation, 是一种按照js对象语法的数据格式，同时是一种轻量级的数据交互格式，常用于再网站上表示和传输数据。</p></li><li><p>application&#x2F;x-www-form-urlencoded：表单数据被编码为key&#x2F;value格式发送到服务器，也是表单默认的提交数据的格式。</p></li></ul><p><img src="/img/%E5%8E%9F%E7%94%9FajaxPost.png" alt="post"></p></li></ul><h2>2. jQuery封装后的ajax数据的请求与发送</h2><h3>2.1 $.ajax语法</h3><p>$.ajax({</p><p>​type：”请求方式”,</p><p>​url：”发送请求的地址”，</p><p>​data: “预期服务器返回的数据类型”，&#x2F;&#x2F;post的时候，要求为Object或String类型的参数</p><p>​contentType: “设置请求头里的内容类型”, &#x2F;&#x2F;默认为”application&#x2F;x-www-form-urlencoded”</p><p>​async: “异步方式”，&#x2F;&#x2F;默认都是true</p><p>​success：’成功情况下的回调函数’，</p><p>​error：’失败情况下的处理函数‘})</p><hr><p><img src="/img/jqueryGet.png" alt="get"></p><hr><p><img src="/img/jqueryPost.png" alt="post"></p><h3>2.2 $.get语法</h3><p>$.get(URL, [data, function(data,status)])</p><ul><li>function可以用来规定当前请求成功时运行的函数。参数中data：来自请求的结果数据；status：请求的状态</li></ul><p><img src="/img/jqGet.png" alt="get"></p><h3>2.3 $.post语法</h3><p>$.post(url, [data, function(data,status)])</p><h2>3. axios</h2><p><mark>axios: 通过promise实现对ajax的封装</mark></p><p>ajax本身是针对MVC编程，不符合现在MVVM的趋势，但是axios就可以很好的支持~且axios相比ajax在数据处理方面有更大的优势，<strong>提供了一些并发请求的接口、自动转换JSON数据</strong>。</p><p>【注：MVC v.s. MVVM】</p><ul><li><strong>MVC</strong>代码架构设计模式：Model-View-Controller。Model数据层，View视图层，Controller主要控制视图层和数据层的关联，主要是通过监听DOM事件</li><li><strong>MVVM</strong>代码架构设计模式：Model-View-ViewModel。是MVC的改进版，支持自动且双向数据绑定。</li></ul><h3>3.1 axios.get语法</h3><p>axios.get(‘url’, {params:{}}).then(callback)</p><p><img src="/img/axiosGet.png" alt="get"></p><h3>3.2 axios.post语法</h3><p>axios.post(‘url’, {传递的数据}).then(callback)</p><p><img src="/img/axiosPost.png" alt="post"></p><h3>3.3 直接使用axios发请求</h3><p><strong>类比jquery的$.ajax()</strong></p><p>axios({</p><p>​method: ‘’,&#x2F;&#x2F;注意jquery封装的时候是type</p><p>​url: ‘’,</p><p>​params: {&#x2F;&#x2F;get参数}，</p><p>​data: {&#x2F;&#x2F;post传的数据}}).then(callback)</p><p><img src="/img/axiosGetPost.png" alt="axios"></p><h3>3.3 vue3.x中全局配置axios</h3><p>在实际项目中几乎每个组件都会用axios发起数据请求，会碰到的问题：</p><ul><li>每个组件都需要导入axios，<span class="red">代码臃肿</span></li><li>每次发请求需要填写完整的请求路径，<span class="red">不利于后期维护</span></li></ul><p><i class="fa-solid fa-arrow-down"></i></p><p><mark>全局配置axios</mark></p><ul><li>在<span class="red">main.js</span>中，通过<span class="red">app.defaults.baseURL</span>为axios配置请求的根路径</li><li>在<span class="red">main.js</span>中，通过<span class="red">app.config.globalProperties</span>全局挂载axios</li></ul><h2>4. 跨域问题与解决办法</h2><p>reference：[(70条消息) 前端数据请求方式总结（前端数据请求方式，原生JS发送请求， axios， jQuery AJAX，同源策略，跨域）_前端发送请求的方式_魔术师ID的博客-CSDN博客](<a href="https://blog.csdn.net/qq_45585640/article/details/122728992#:~:text=%E5%89%8D%E7%AB%AF%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%E6%96%B9%E5%BC%8F">https://blog.csdn.net/qq_45585640/article/details/122728992#:~:text=前端数据请求方式</a> 1  使用 form 表单的 action 向指定,的形式展示 5  使用 <script> 标签的 src 属性发__GET__请求，只能以脚本形式运行，JSONP)</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue基础</title>
    <link href="/2023/06/24/Vue%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/06/24/Vue%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2>Vue基础</h2><h3>1. Vue简介</h3><p>官方的定义：一套用于<span class="red">构建用户界面</span>的前端<span class="red">框架</span>。</p><h4><i class="fa-sharp fa-solid fa-stars"></i>1.1 Vue特性</h4><ul><li><span class="red">数据驱动视图</span>：Vue会监听数据的变化，从而自动重新渲染页面结构</li><li><span class="red">双向数据绑定</span>：不操作DOM的前提下，自动将表单内容同步到数据源中</li></ul><h4><i class="fa-sharp fa-solid fa-stars"></i>1.2 MVVM</h4><p><span class="red"><strong>MVVM</strong>: Model, View, ViewModel</span></p><p>MVVM是Vue实现数据驱动视图和双向数据绑定的核心原理，它把每个HTML页面都拆成了三部分：<mark>Model</mark>表示当前页面渲染时所依赖的数据源；<mark>View</mark>表示当前页面渲染的DOM结构；<mark>ViewModel</mark>表示<span class="red">vue的实例</span>，是MVVM的核心！</p><p><img src="/img/MVVM.jpg" alt="MVVM"></p><h3>2. Vue的基本使用</h3><h4>2.1 基本使用步骤</h4><ul><li>导入Vue.js的脚本文件，就会在window全局有Vue构造函数</li><li>在页面中声明一个将要被vue控制的DOM区域</li><li>创建vm实例对象（vue实例对象）</li></ul><p><img src="/img/vue-use.png" alt="Vue初试用"></p><h4>2.2 Vue的调式工具</h4><p>Vue.js devtools</p><h3>3. Vue指令</h3><h4>3.1 指令的概念</h4><p>指令Directives：是Vue为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。v-xxx</p><p>按照<u>不同的用途</u>可以分为：</p><ul><li>内容渲染指令：v-text, 插值表达式双花括号，v-html</li><li>属性绑定指定：v-bind</li><li>事件绑定指令：v-on</li><li>双向绑定指令：v-model</li><li>条件渲染指定：v-if，v-show，v-else，v-else-if</li><li>列表渲染指令：v-for</li></ul><h4>3.2 内容渲染指令</h4><p>用来辅助开发者渲染DOM元素的文本内容。</p><ul><li>v-text：将文本渲染到标签中，但是会<span class="red">覆盖元素内默认的值</span></li></ul><p><img src="/img/v-text.png" alt="v-text"></p><p>如何解决？</p><p><i class="fa-solid fa-arrow-down"></i></p><ul><li><p><i class="fa-light fa-star-christmas"></i> 插值表达式Mustache</p></li><li><p>v-html: 可以渲染包含html标签的字符串</p></li></ul><p><img src="/img/v-html.png" alt="插值表达式&amp;v-html"></p><hr><p>问题：插值表达式可以解决文本内容，但是属性是没办法用插值表达式的怎么办呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>3.3 属性绑定指令 <span class="red">v-bind:(:)</span></h4><p>为元素的属性动态绑定属性值</p><p><img src="/img/v-bind.png" alt="v-bind"></p><hr><p>经常会和布尔型Attribute联用：</p><p>button :disabled&#x3D;”isButtonDisabled”</p><h4>3.4 事件绑定指令 <span class="red">v-on:(@)</span></h4><p>辅助为DOM元素绑定事件监听</p><p><span class="red">注</span>：原生DOM对象有onclick、onkeyup等原生事件，替换为vue事件绑定形式后，为：<span class="red">v-on:click、v-on:keyup</span>或者简写形式：@click、@keyup</p><h5>3.4.1 事件对象event </h5><p>在原生的DOM事件绑定中，可以在事件处理函数的形参中，接收事件参数对象event。同理，在v-on指令所绑定的事件处理函数中，也可以接收事件对象event。</p><p><img src="/img/v-on.png" alt="$event"></p><h5>3.4.2 事件修饰符 </h5><p>在事件处理函数中调用<span class="red">event.preventDefault()</span>或者<span class="red">event.stopPropogation()</span>是很常见的需求。</p><p>Vue中提供了<span class="red">事件修饰符</span>的概念辅助对事件的触发进行控制。</p><ul><li><p><i class="fa-regular fa-star"></i><span class="red">event.stop</span>: 阻止事件冒泡</p></li><li><p><i class="fa-regular fa-star"></i><span class="red">event.prevent</span>: 阻止默认行为（比如a链接的跳转、表单的提交等）</p><p>e.g. a href&#x3D;”某度的网址嘻嘻” @click.prevent&#x3D;”事件处理函数”，就可以阻止默认的跳转行为</p></li></ul><h5>3.4.3 按键修饰符 </h5><p>监听键盘事件，常常需要判断详细的按键</p><ul><li>@keyup.enter&#x3D;”xx”：只有在按键为enter键时调用处理函数xx</li><li>@keyup.esc&#x3D;”yy”:  只有在按键为esc键时调用处理函数yy</li></ul><h4>3.5 <i class="fa-solid fa-star"></i>双向绑定指令 <span class="red">v-model</span></h4><p><span class="red">注意，v-model只能配合<mark>表单</mark>元素一起使用</span></p><p>vue中的v-model双向数据绑定指令，可以辅助在不操作DOM的前提下，快速获取表单的数据</p><p><img src="/img/v-model.png" alt="v-model"></p><h5>3.5.1 v-model指令的修饰符 </h5><p>为了方便对用户输入的内容进行处理，vue为v-model指令提供了以下修饰符</p><ul><li>.number: 自动将用户的输入值转为数值类型</li><li>.trim: 自动过滤用户输入的首尾空白字符</li><li>.lazy: 默认情况下v-model会在每次input事件后更新数据，添加lazy修饰符会在每次change事件后更新数据</li></ul><h4>3.6 条件渲染指令 </h4><p>按条件控制DOM的显示与隐藏，只有在指令表达式返回true时才被渲染</p><p><span class="red">v-if和v-show的区别</span>：</p><p><mark>实现原理不同：</mark></p><ul><li>v-if指令会<span class="red">动态的创建或者移除DOM元素</span>，从而控制元素在页面上的显示与隐藏；</li><li>v-show指定会动态的为元素<span class="red">添加或移除style&#x3D;”display:none”样式</span>，从而控制元素在页面上的显示与隐藏；</li></ul><p><mark>性能消耗不同：</mark></p><ul><li>v-if具有<span class="red">更高的切换开销</span>：如果需要频繁的切换还是用v-show好一点</li><li>v-show具有<span class="red">更高的初始渲染开销</span>，在运行时条件改变很少使用v-if好一点</li></ul><h4>3.7 条件渲染指令 </h4><p>v-for&#x3D;”(item,index) in list”</p><p>但是当列表数据变化的时候，vue默认会尽可能的复用已经存在的Dom元素，从而提升渲染的性能，但是有可能会导致有一些有状态的列表无法正确的被更新，<span class="red">vue官方建议用id作为key值</span>，方便追踪每个节点</p><p><mark>v-for使用时建议都指定key的值，既能提升性能，又可以防止列表状态紊乱</mark></p><p><img src="/img/v-key.png" alt="v-for&amp;key"></p><h3>4. *Vue2.x中的过滤器Filters</h3><p>了解即可，常用于文本的格式化，且以<span class="red">管道符</span>的形式进行调用</p><ul><li><p>在插值表达式中使用过滤器：</p></li><li><p>在v-bind属性绑定中使用过滤器：</p><p>div v-bind:id&#x3D;”rawId | formatId”</p></li></ul><p><img src="/img/filters.png" alt="filters"></p><p><strong>注意</strong>：</p><ul><li><p>methods v.s. filters：定义事件处理函数是定义在methods中，定义过滤器函数是在filters</p></li><li><p>私有过滤器 v.s. 全局过滤器：</p><p>私有过滤器：定义在filters节点下的过滤器，只能在vm实例控制的el区域内使用，但是不能在多个vue实例中共享</p><p>全局过滤器：独立于每个vm实例之外，用Vue.filter(名字，处理函数)进行定义</p><p><img src="/img/%E5%85%A8%E5%B1%80%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="全局过滤器 v.s. 私有过滤器"></p></li></ul><h3>5. 侦听器Watch</h3><p>用于<span class="red">监视数据变化</span></p><h4>5.1 定义 </h4><p>watch侦听器：用于监视数据的变化，从而针对数据的变化做特定的操作。</p><p>watch是以方法形式对被侦听对象的变化进行侦听。</p><p><span class="red">注意参数的顺序：newVal， oldVal！</span></p><p><img src="/img/watch.png" alt="watch的用法"></p><p>但是watch方法默认不会对对象的<u>初始值</u>进行侦听，有变化才会侦听，那么如果相对被侦听对象的初始值也侦听怎么办呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>5.2 immediate选项 </h4><p>默认的watch都是方法的形式，为了加入immediate选项，需要改造成<span class="red">对象</span>的形式</p><p>watch: {</p><p>​username: {</p><p>​handler: function(newVal, oldVal) {xxx},</p><p>​immediate: true</p><p>}}</p><p>但是watch侦听的对象如果是一个对象，对象中的属性值变化是侦听不到的怎么办？</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>5.3 deep选项 </h4><p>还是在上述对象的形式的基础上，加入deep: true就会对对象中所有属性的属性值变化进行侦听</p><p>但是我只想侦听某个属性值的变化怎么办呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>5.4 侦听对象单个属性的变化 </h4><p>注意引号的使用！</p><p><img src="/img/%E5%8D%95%E4%B8%80%E5%B1%9E%E6%80%A7%E5%80%BC%E4%BE%A6%E5%90%AC.png" alt="单个属性的变化"></p><h3>6. 计算属性Computed</h3><p>以<span class="red">function函数</span>形式声明到computed节点中，实时监听data，经过一系列的运算后最终<span class="red">通过return</span>返回一个属性值。</p><p>虽然计算属性在声明的时候被定义为方法，但是本质是一个属性，调用的使用也是通过属性的方式进行调用。</p><p><img src="/img/computed.png" alt="computed"></p><p><span class="red"><strong>计算属性 v.s. 侦听器</strong></span>： 侧重的应用场景不同</p><ul><li>计算属性侧重于监听多个值的变化，最终计算并返回一个新值</li><li>侦听器侧重于监听单个数据的变化，执行特定的业务处理并没有返回值</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端工程化与webpack</title>
    <link href="/2023/06/23/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/"/>
    <url>/2023/06/23/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96%E4%B8%8Ewebpack/</url>
    
    <content type="html"><![CDATA[<h2>前端工程化与webpack</h2><h3>1. 前端工程化</h3><p>实际上的前端开发：</p><ul><li>模块化（js模块化，css模块化，资源模块化）</li><li>组件化（复用现有的UI结构、样式、行为）</li><li>规范化（编码规范、接口规范、文档规范、Git分支管理）</li><li>自动化（自动化构建、自动部署、自动化测试）</li></ul><h4>1.1 前端工程化是什么？</h4><p>前端工程化：在企业及的前端项目开发中，把前端开发所需的工具、技术、流程、经验等进行规范化和标准化。</p><p><i class="fa-solid fa-arrow-down"></i></p><p>早期的前端工程化解决方案：gulp、grunt等</p><p><span class="red">目前主流的</span>前端工程化解决方案：<span class="red">webpack</span>、parcel</p><h3>2. webpack的基本使用</h3><h4>2.1 webpack是什么？</h4><p>webpack: 是前端工程化的具体解决方案。</p><p><strong>主要功能</strong>：提供了友好的前端模块化开发支持，以及<u>代码压缩混淆，处理浏览器端JavaScript的兼容性，性能优化</u>等强大的功能。</p><p><strong>好处</strong>：让技术人员将工作重心放在具体功能的实现上，提高了前端开发的效率和项目的可维护性</p><h4>2.2 webpack安装</h4><p>当我们在项目中想用ES6语法引入jQuery会报语法错误，有兼容性问题，想用webpack解决</p><ul><li><p>在项目中安装webpack： npm install webpack webpack-cli -D</p><p><strong>dependencies节点</strong>：开发+上线  -S   –save</p><p><strong>devDependencies节点</strong>:  仅开发阶段  -D    –save-dev</p></li></ul><h4>2.3 webpack配置</h4><ul><li><p>在项目根目录下创建<span class="red">webpack.config.js</span>的webpack配置文件，并初始化</p><p>module.exports &#x3D; {</p><p>​mode: ‘development’</p><p>}</p><hr><p>*mode的可选值</p><p><img src="/img/mode.jpg" alt="mode"></p><hr></li><li><p>在<span class="red">package.json</span>的<span class="red">scripts</span>节点下新增dev脚本</p><p>“scripts”: {</p><p>​“dev”: “webpack”</p><p>}</p><p>scripts节点下的脚本可以通过npm run执行， 比如这里定义dev脚本，就是npm run dev</p></li><li><p>在终端运行我们定义好的脚本命令：npm run dev，启动webpack对项目进行打包构建</p></li><li><p>最后将打包构建好的main文件导入，删掉有兼容性问题的文件</p></li></ul><h4>2.4 webpack默认约定</h4><p>在webpack4.x和5.x的版本中，有以下的<strong>默认约定</strong>：</p><ul><li>默认的打包入口文件为：<span class="red">src -&gt; index.js</span></li><li>默认的输出文件路径为：<span class="red">dist -&gt; main.js</span></li></ul><p>这个约定对名字很敏感，如果想要修改就需要通过webpack.config.js配置文件来修改</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>2.5 自定义打包的入口和出口</h4><p>在webpack.config.js中，通过<span class="red">entry</span>节点指定打包的<span class="red">入口</span>，通过<span class="red">output</span>节点指定打包的<span class="red">出口</span></p><p>entry: path.join(__dirname, ‘.&#x2F;src&#x2F;index.js’),</p><p>output: {</p><p>​path: path.join(__dirname, ‘.&#x2F;dist’),</p><p>​filename: ‘bundle.js’</p><p>}</p><p>那么，每次修改代码都需要重新运行npm run dev很麻烦</p><p><i class="fa-solid fa-arrow-down"></i></p><h3>3. webpack插件</h3><p>通过安装和配置第三方的插件，可以拓展webpack的能力，从而用起来更加的方便</p><h4>3.1 webpack-dev-server</h4><ul><li><p>安装：npm install <a href="mailto:&#119;&#x65;&#x62;&#x70;&#97;&#99;&#107;&#x2d;&#100;&#101;&#x76;&#x2d;&#x73;&#x65;&#114;&#x76;&#101;&#x72;&#x40;&#51;&#46;&#49;&#49;&#46;&#50;">&#119;&#x65;&#x62;&#x70;&#97;&#99;&#107;&#x2d;&#100;&#101;&#x76;&#x2d;&#x73;&#x65;&#114;&#x76;&#101;&#x72;&#x40;&#51;&#46;&#49;&#49;&#46;&#50;</a> -D</p></li><li><p>配置：将package.json -&gt; scripts中的dev命令修改</p><p>“dev”: “webpack serve”</p><p>再次运行npm run dev的命令</p><p>可以在localhost:8080查看自动打包效果</p></li></ul><p><i class="fa-solid fa-question"></i>问题：为什么页面并不会自动显示变化？</p><p><mark>答</mark>：webpack-dev-server并不能读取webpack.config.js中配置的output属性，<span class="red">默认</span>打包的文件名是<span class="red">bundle.js</span>,且不会出现在项目目录中。所以将index.html中引入js文件的路径直接换成’bundle.js’即可！</p><h4>3.2 html-webpack-plugin</h4><ul><li><p>安装：npm install <a href="mailto:&#104;&#x74;&#109;&#x6c;&#45;&#x77;&#x65;&#x62;&#112;&#97;&#x63;&#107;&#45;&#x70;&#108;&#117;&#103;&#105;&#x6e;&#x40;&#53;&#x2e;&#51;&#46;&#x32;">&#104;&#x74;&#109;&#x6c;&#45;&#x77;&#x65;&#x62;&#112;&#97;&#x63;&#107;&#45;&#x70;&#108;&#117;&#103;&#105;&#x6e;&#x40;&#53;&#x2e;&#51;&#46;&#x32;</a> -D</p></li><li><p>配置：在webpack.config.js中</p><p><img src="/img/html-webpack-plugin.jpg" alt="配置"></p></li></ul><h3>4. webpack中的loader</h3><p>引入：在实际开发中，webpack默认只能打包处理以.js后缀名结尾的模块。所以打包其他非js文件比如图片、css、字体等其他类型的资源文件均是基于<span class="red">Loader机制</span>来实现的。</p><h4>4.1 loader加载器的作用</h4><p><span class="red">协助webpack打包处理特定的文件模块</span>，如：</p><ul><li>css-loader：打包处理.css相关的文件</li><li>less-loader:   打包处理.less相关的文件</li><li>babel-loader:   打包处理webpack无法处理的高级js语法</li></ul><h4>4.2 loader的调用过程</h4><p><img src="/img/loader%E8%B0%83%E7%94%A8.png" alt="loader"></p><h4>4.3 打包处理css文件</h4><p>webpack允许用户为某些资源文件配置多个不同的loader，在处理 .css文件的时候，用到了style-loader和css-loader</p><ul><li><p>安装： npm i <a href="mailto:&#115;&#x74;&#x79;&#x6c;&#x65;&#x2d;&#108;&#111;&#x61;&#100;&#101;&#114;&#64;&#51;&#x2e;&#x30;&#46;&#x30;">&#115;&#x74;&#x79;&#x6c;&#x65;&#x2d;&#108;&#111;&#x61;&#100;&#101;&#114;&#64;&#51;&#x2e;&#x30;&#46;&#x30;</a> <a href="mailto:&#99;&#x73;&#x73;&#45;&#x6c;&#x6f;&#97;&#100;&#x65;&#114;&#x40;&#x35;&#46;&#x32;&#x2e;&#54;">&#99;&#x73;&#x73;&#45;&#x6c;&#x6f;&#97;&#100;&#x65;&#114;&#x40;&#x35;&#46;&#x32;&#x2e;&#54;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .css$&#x2F;, use: [‘style-loader’, ‘css-loader’]}&#x2F;&#x2F;注意顺序是固定的！</p><p>]</p><p>其中test是要匹配的文件类型，use是要对应调用的loader</p><p><span class="red">多个loader的调用顺序是：从后往前调用</span></p><p>过程：webpack先将.css后缀的文件交给use的最后一个loader(css-loader)处理完毕后，交给倒数第二个loader(style-loader)处理后，发现没有别的loader了就交给webpack,最终合并到main.js中。</p></li></ul><h4>4.3 打包处理less文件</h4><ul><li><p>安装： npm i <a href="mailto:&#108;&#x65;&#115;&#x73;&#45;&#108;&#111;&#x61;&#100;&#101;&#x72;&#x40;&#49;&#x30;&#46;&#x30;&#x2e;&#49;">&#108;&#x65;&#115;&#x73;&#45;&#108;&#111;&#x61;&#100;&#101;&#x72;&#x40;&#49;&#x30;&#46;&#x30;&#x2e;&#49;</a> <a href="mailto:&#x6c;&#101;&#115;&#x73;&#x40;&#x34;&#46;&#49;&#x2e;&#x31;">&#x6c;&#101;&#115;&#x73;&#x40;&#x34;&#46;&#49;&#x2e;&#x31;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .less$&#x2F;, use: [‘style-loader’, ‘css-loader’, ‘less-loader’]}</p><p>]</p></li></ul><h4>4.4 打包处理样式表中与url路径相关的文件</h4><ul><li><p>安装： npm i <a href="mailto:&#117;&#114;&#x6c;&#x2d;&#108;&#111;&#x61;&#100;&#x65;&#114;&#64;&#x34;&#x2e;&#49;&#x2e;&#49;">&#117;&#114;&#x6c;&#x2d;&#108;&#111;&#x61;&#100;&#x65;&#114;&#64;&#x34;&#x2e;&#49;&#x2e;&#49;</a> <a href="mailto:&#x66;&#105;&#108;&#x65;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#54;&#46;&#50;&#46;&#48;">&#x66;&#105;&#108;&#x65;&#45;&#108;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#54;&#46;&#50;&#46;&#48;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .jpg|png|gif$&#x2F;, use: ‘url-loader?limit&#x3D;22229’}</p><p>]</p><p>?后面是loader的参数，limit指定图片的大小，也就是说只有&lt;&#x3D;limit大小的图片才会被转为<a href="https://blog.csdn.net/sunyctf/article/details/125527656">base64格式</a>的图片。</p></li></ul><h4>4.5 打包处理js文件中的高级语法</h4><p>webpack只能打包处理一部分高级的js语法，对于webpack不能处理的，需要借助babel-loader进行打包处理。</p><ul><li><p>安装： npm i <a href="mailto:&#98;&#x61;&#x62;&#101;&#x6c;&#x2d;&#108;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#56;&#46;&#50;&#46;&#50;">&#98;&#x61;&#x62;&#101;&#x6c;&#x2d;&#108;&#x6f;&#97;&#100;&#x65;&#x72;&#x40;&#56;&#46;&#50;&#46;&#50;</a> @babel&#x2F;<a href="mailto:&#x63;&#x6f;&#x72;&#x65;&#x40;&#55;&#46;&#x31;&#52;&#46;&#x36;">&#x63;&#x6f;&#x72;&#x65;&#x40;&#55;&#46;&#x31;&#52;&#46;&#x36;</a> @babel&#x2F;<a href="mailto:&#112;&#108;&#x75;&#103;&#x69;&#x6e;&#x2d;&#112;&#x72;&#111;&#x70;&#111;&#115;&#x61;&#x6c;&#x2d;&#100;&#101;&#99;&#x6f;&#x72;&#97;&#x74;&#111;&#114;&#x73;&#64;&#x37;&#x2e;&#49;&#52;&#46;&#53;">&#112;&#108;&#x75;&#103;&#x69;&#x6e;&#x2d;&#112;&#x72;&#111;&#x70;&#111;&#115;&#x61;&#x6c;&#x2d;&#100;&#101;&#99;&#x6f;&#x72;&#97;&#x74;&#111;&#114;&#x73;&#64;&#x37;&#x2e;&#49;&#52;&#46;&#53;</a> -D</p></li><li><p>配置： webpack.config.js中<span class="red">module -&gt; rules数组</span>中添加loader规则</p><p>rules: [</p><p>​{ test: &#x2F; \ .js$&#x2F;, use: ‘babel-loader’, exclude: &#x2F;node_modules&#x2F;}&#x2F;&#x2F;node_modules目录下的第三方包不需要被打包</p><p>]</p></li><li><p>配置：在项目根目录下创建 babel.config.js 并配置</p><p>module.exports &#x3D; {</p><p> &#x2F;&#x2F;声明babel可用插件</p><p> plugins: [[‘@babel&#x2F;plugin-proposal-decorator’, {legacy: true}]]</p><p>}</p></li></ul><h3>5. 打包发布</h3><h4>5.1 为什么要用webpack进行打包发布？</h4><p>项目开发完成之后，需要使用webpack打包发布的原因有如下两条：</p><ul><li>开发环境下，打包生成的文件<span class="red">存放在内存中</span>，无法获取到最终打包生成的文件</li><li>开发环境下，打包生成的文件不会进行代码的压缩和性能的优化。</li></ul><h4>5.2 webpack打包发布的配置</h4><p>在package.json文件中的Scripts节点下，新建build命令：</p><p>“build”: “webpack –mode production”</p><h3>6. source map</h3><p>在已经压缩混淆之后的代码进行debug是一件及其困难的事情，因为所有的空格和注释都被删除并且变量被替换成没有任何语义的名称</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>6.1 什么是SourceMap？</h4><p>SourceMap是一个信息文件，里面存储了<span class="red">位置信息</span>：压缩混淆后的代码与源代码的对应关系。</p><p>在出错的时候，除错工具直接显示原始代码，而不是压缩后的代码，方便调试。</p><h4>6.2 webpack开发环境下的SourceMap</h4><ul><li>在开发环境下，webpack默认启用了sourcemap功能。</li></ul><p><strong>问题</strong>： 开发环境下默认生成的SourceMap记录的是<span class="red">生成后的代码位置</span>，会导致报错的位置和源代码的位置不一样。</p><p><strong>解决方案</strong>：在webpack.config.js中配置在开发环境下的devtool</p><p>devtool: ‘eval-source-map’</p><ul><li>在生产环境下，应该省略devtool选项，防止泄露源代码</li></ul><p><strong>问题</strong>：可是我还想找到出问题的源码</p><p><strong>解决方案</strong>：将devtool的值设置为nosources-source-map，就可以只定位报错的具体行数而不暴露源代码</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2023/06/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2023/06/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h2>正则表达式</h2><h4>1. 正则表达式概述</h4><p>正则表达式 regular expression：是于匹配字符串中字符组合的模式，js中，正则表达式也是对象。</p><p>正则表达式通常被用来<span class="red">检索、替换</span>那些符合某个模式（规则）的文本。</p><h4>2. 创建正则表达式</h4><ul><li>通过RegExp构造函数创建： var regexp &#x3D; new RegExp(&#x2F;表达式&#x2F;)</li><li>通过字面量创建：var regexp &#x3D; &#x2F;表达式&#x2F;</li></ul><p>那么如何检测输入的字符串是否符合正则表达式的要求呢？</p><p><i class="fa-solid fa-arrow-down"></i></p><h4>3. 测试正则表达式</h4><p>regexObj.test(str):检测str文本是否符合我们写的正则表达式regexObj的规范，返回true或者false</p><h4>4. 正则表达式中的元字符</h4><p>一个正则表达式可以由<span class="red">简单字符</span>构成，如&#x2F;123&#x2F;，也可以由<span class="red">特殊字符</span>组成，且在正则表达式中有特殊的意义。</p><h5>4.1 边界符（位置符）</h5><p>边界符用来提示字符所处位置</p><ul><li>^ 表示匹配以<span class="red">首</span>的文本（以谁开始）</li><li>$ 表示匹配以<span class="red">尾</span>的文本（以谁结束）</li></ul><hr><p><img src="/img/regExp%E8%BE%B9%E7%95%8C%E7%AC%A6.png" alt="边界符"></p><hr><h5>4.2 字符类</h5><ul><li>[]：方括号内放所有可供选择的字符，只要匹配其中一个就行</li><li>[-]：-表示范围，比如a-z之间的任意一个字母可以写成 &#x2F;[a-z]&#x2F;, 常用字符组合：&#x2F;a-zA-Z0-9_-&#x2F;</li><li>[^] : 方括号内的^表示取反</li></ul><h5>4.3 量词符</h5><p><img src="/img/regExp%E9%87%8F%E8%AF%8D%E7%AC%A6.jpg" alt="量词符"></p><h5>4.4 预定义类</h5><p><img src="/img/regExp%E9%A2%84%E5%AE%9A%E4%B9%89%E7%B1%BB.jpg" alt="预定义类"></p><h4>5. 正则表达式中的替换</h4><ul><li><p>stringObject.replace(regexp&#x2F;substr, replacement): 将替换的子字符串或者正则表达式替换为新的并且返回替换完毕的字符串。</p><p>经常使用正则表达式的形式替换为‘**’，避免敏感词，但是str.replace(&#x2F;激情&#x2F;，”  x “ )只能替换掉<strong>第一个</strong>出现的敏感词</p><p><i class="fa-solid fa-arrow-down"></i></p></li><li><p>正则表达式参数  &#x2F;表达式&#x2F;[switch]</p><p>switch有三个值：  <span class="red">g</span>全局匹配    <span class="red">i</span>忽略大小写   <span class="red">gi</span>全局匹配+忽略大小写</p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js函数进阶</title>
    <link href="/2023/06/22/js%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <url>/2023/06/22/js%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h2>js函数进阶</h2><h3>1. 函数的定义和调用</h3><h4>1.1 函数的定义方式</h4><ul><li><p>自定义函数（命名函数）</p><p>function functionName(params) {codexxx}</p></li><li><p>函数表达式（匿名函数）</p><p>var fun &#x3D; function(params) {codexxx}</p></li><li><p>new Function()</p><p>var func &#x3D; new Function(‘param1’, ‘param2’,…,’function’)</p></li></ul><hr><h4>1.2 函数的调用方式</h4><p>总结三种函数定义方式及其调用in js：</p><p><img src="/img/advanced-def.png" alt="code"></p><hr><h3>2. this</h3><h4>2.1 函数内的this</h4><p>函数内的this指向：调用时才能确定，一般指向调用者</p><p><img src="/img/this1.jpg" alt="this"></p><h4>2.2 改变函数内的this指向</h4><ul><li>fn.call(context，arg1，arg2，…): 可以调用函数，又可以改变this指向，主要可以实现继承。</li><li>fn.apply(context，[arg1，arg2,…]): 也是可以调用函数，又可以改变this指向，主要区别是函数需要将参数作为数组传递</li><li>fn.bind(context，arg1，arg2，…): <span class="red">不会调用函数，返回改变this指向后的新函数</span></li></ul><hr><p><img src="/img/advanced-this.png" alt="this"></p><hr><h3>3. 严格模式 strict mode</h3><p>ES5的严格模式是采用具有限制性JavaScript变体的一种方式，相对正常的js语义做了一些更改，为未来新版本的js做铺垫。</p><p>严格模式的开启可以分为 <u>为整个脚本开启严格模式</u>和<u>为个别函数开启严格模式</u></p><p>在所有语句（为整个脚本）或者在函数体（为个别函数）之前放特定语句<span class="red">“use strict”;</span></p><h4>3.1 严格模式下的变化</h4><ul><li><strong>变量规定</strong>： 变量必须先声明再使用，不允许删除已经声明的变量</li><li><strong>this指向</strong>：正常的js中全局作用域函数的this指向window对象，严格模式下，全局作用域的函数this指向undefined</li><li><strong>函数变化</strong>: 函数不能有重名的参数</li></ul><h3>4. 高阶函数</h3><p>高阶函数：对其他函数进行操作的函数（接收函数作为参数 或者 将函数作为返回值）</p><h4>4.1 函数作为参数的情况</h4><ul><li>arr.map(callback(currentValue, index, array)): 生成一个新数组，不改变原始数组的值。其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</li><li>arr.reduce(callback(accumulator, currentValue, currentIndex,arr ),initialValue):对数组中的每个元素执行一个提供的 reducer 函数(升序执行)，将其结果汇总为单个返回值。   -   经常用于数组求和</li><li>arr.sort(): 用原地算法对数组的元素进行排序，并返回数组</li></ul><p>reference： <a href="https://juejin.cn/post/6844903873983807502">【JS必知必会】高阶函数详解与实战 - 掘金 (juejin.cn)</a></p><h3><i class="fa-sharp fa-light fa-star-christmas"></i>5. 闭包</h3><h4>5.1 变量作用域</h4><p>变量根据作用域的不同分为：全局变量和局部变量。注意：</p><ul><li>函数外<strong>可以</strong>使用全局变量</li><li>函数内<strong>不可以</strong>使用局部变量</li><li>当函数执行完毕，本作用域内的局部变量会销毁</li></ul><p>那么如何从外部读取局部变量呢？ </p><h4>5.2 闭包的定义</h4><p><span class="red">闭包</span>：是指有权访问另一个函数作用域中的变量的<strong><u>函数</u></strong>。(本质是个函数)</p><h4>5.3 闭包的作用</h4><p><span class="red">延伸变量的作用范围</span></p><p>reference：<a href="https://juejin.cn/post/7097141521102667813">深入理解JS闭包 - 掘金 (juejin.cn)</a></p><h3><i class="fa-sharp fa-light fa-star-christmas"></i>6. 深拷贝和浅拷贝</h3><ul><li><p>浅拷贝shallow copy：只复制指向某对象的指针，而不复制对象本身，新旧对象共享一块内存。且浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用（地址）</p><p>es6新增Object.assign(目标，原)可以实现浅拷贝</p></li><li><p>深拷贝deep copy：复制并创建一个一模一样的对象，不共享内存，修改新对象不对影响旧对象。每一层的数据都会进行拷贝。</p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es6新增特性</title>
    <link href="/2023/06/21/es6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/"/>
    <url>/2023/06/21/es6%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h2>es6新增特性</h2><h3>1. let关键字</h3><p><i class="fa-regular fa-block-question"></i>那么let声明和var声明变量有什么<span class="red">异同</span>呢？</p><ul><li><p><strong>全局作用域下</strong>: 两者在全局作用域下作用相似，但是，let声明的变量不会作为全局对象window的属性，而var声明的变量却可以</p><p>var numvar &#x3D; 10;</p><p>let numlet &#x3D; 100;</p><p>console.log(window.numvar);&#x2F;&#x2F;10</p><p>console.log(window.numlet);&#x2F;&#x2F;undefined</p></li><li><p><strong>块作用域下</strong>：let声明的变量只在所处的块级（{}之间）有效。</p></li><li><p><strong>变量提升</strong>： let声明的变量不存在变量提升，故必须先声明再使用</p></li><li><p><strong>变量重名</strong>:  var允许再同一作用域声明同名的变量，只不过就是会把值覆盖而已；let则不允许在同一作用域声明同名的变量。</p></li><li><p><strong>暂时性死区</strong>： let声明的变量存在暂时性死区</p><p>var num &#x3D; 10;</p><p>if(true) {</p><p>​console.log(num);&#x2F;&#x2F; 这里程序会把num和块级绑定，认为在打印let声明的num</p><p>​let num;</p><p>}</p></li></ul><h3>2. const关键字</h3><p>const关键字声明变量的特点如下：</p><ul><li>具有块级作用域</li><li>声明的同时必须赋值</li><li>常量赋值后是不能修改的</li></ul><hr><p><span class="red">sum</span>: let, var, const的区别</p><p><img src="/img/var-let-const.jpg" alt="let, var, const"></p><hr><h3>3. 解构赋值</h3><p>解构-赋值：按照一定的模式，从<span class="red">数组</span>或者<span class="red">对象</span>中提取值并赋值给另外的变量。</p><h4>3.1 数组解构</h4><p>允许按照<span class="red">一一对应</span>的关系从数组中提取值并赋值给变量</p><p>如果变量数量 &gt; 数组元素数量，则后面的变量则为undefined</p><p>如果变量数量 &lt; 数组元素数量,  则按照数组的前n个分别赋值</p><h4>3.2 对象解构</h4><ul><li><p>方法一： 按照属性名一一对应赋值</p><p>let {attr1, attr2} &#x3D; {</p><p>​attr1: xxx,</p><p>​attr2: xxx}</p><p>但是这个解构赋值的方法<u>变量名必须和对象里的属性名一致</u></p></li><li><p>方法二： 自定义变量名</p><p>let {attr1: name1, attr2: name2} &#x3D; {</p><p>​attr1: xxx,</p><p>​attr2: xxx}</p><p>冒号前做属性匹配，冒号后才是真正的变量名</p></li></ul><h3>4. 箭头函数</h3><p>通常需要将箭头函数赋值给某个变量，方便调用。</p><p>var fn &#x3D; （arg1, …) &#x3D;&gt; {xxxx}</p><p>箭头函数的特点：</p><ul><li>如果函数体只有一句代码，且代码的执行结果就是返回值，则可以直接省略大括号</li><li>如果形参只有一个，则可以省略小括号</li><li>箭头函数不绑定this， 箭头函数中的this是函数定义位置的上下文this</li></ul><h3>5. 剩余参数...args</h3><p>剩余参数允许将不定数量的参数表示为一个<span class="red">数组</span></p><h3>6. ES6内置对象扩展</h3><h4>6.1 Array扩展方法</h3><ul><li><p>扩展运算符…：将数组或者对象拆分成用逗号分隔的参数序列</p><p>let arr &#x3D; [1,2,3]</p><p>…arr  &#x2F;&#x2F; 1, 2, 3</p><p><span class="red">应用</span>：拓展运算符可以很好的帮助我们<span class="red">合并数组</span>，<span class="red">将伪数组或者可遍历对象转换成真正的数组</span></p></li><li><p>构造函数法Array.from(): 可以将伪数组或者可遍历对象转换成真正的数组</p></li><li><p>find()：用于找出第一个符合条件的数组成员，找不到返回undefined</p></li><li><p>findIndex(): 找出第一个符合条件的数组成员的位置，找不到返回-1</p></li><li><p>includes() : 判断数组是否包含给定的值，返回布尔值</p></li></ul><h4>6.2 String扩展方法</h3><ul><li><i class="fa-regular fa-star-exclamation"></i>模板字符串&#96;&#96;: 和普通的字符串比，<span class="red">可以解析变量，可以换行，可以调用函数！！！！</span>注意解析变量和调用函数需要用 ${}包裹</li><li>str.startsWith(subStr) 和 str.endsWith(subStr) 判断str字符串是否以subStr开头或者结尾，返回true或者false</li><li>str.repeat(): 将字符串重复n次，返回新的字符串</li></ul><h4>6.3 Set数据结构</h3><p>Set数据结构是es6中提出的，类似于数组，但是与数组不同的是，Set中的成员都是<span class="red"><strong>唯一的</strong></span>。</p><p>const s &#x3D; new Set([1,2,3,3]); &#x2F;&#x2F; s &#x3D; [1,2,3]</p><p><span class="red">应用</span>：</p><ul><li><p>搭配扩展运算符进行数组去重</p><p>var arr &#x3D; [1,3,3,3,3,5]</p><p>var set &#x3D; new Set(arr);  &#x2F;&#x2F;去重</p><p>var arrNew &#x3D; […set]; &#x2F;&#x2F;用扩展运算符包装成新的数组</p></li></ul><ol><li><p>set实例的方法</p><p>a. add(value): 添加某个值，返回set结构本身</p><p>b. delete(value)：删除某个值，返回布尔值，表示删除成功与否</p><p>c. has(value): 返回布尔值，判断是否有这个成员</p><p>d. clear():清除所有成员</p></li></ol><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>es5新增方法</title>
    <link href="/2023/06/21/es5%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/"/>
    <url>/2023/06/21/es5%E6%96%B0%E5%A2%9E%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2>es5新增方法</h2><h3>1. 数组</h3><p>注意以下回调函数callback均只有currentVal是必须的参数</p><ul><li><p>forEach(): 遍历数组</p><p>array.forEach(callbackFn(currentVal, index,arr) )</p></li><li><p>filter()：筛选数组并返回新数组</p><p>array.filter(callbackFn(currentVal, index,arr))</p></li><li><p>some(): 查找数组中是否有满足条件的元素，返回布尔值</p><p>array.some(callbackFn(currentVal, index,arr))</p></li></ul><h3>2. 字符串</h3><ul><li><p>trim(): 删除字符串两端的空白字符，返回新的字符串</p><p><i class="fa-sharp fa-light fa-truck-fast"></i>可以用来防止输入空格</p></li></ul><h3>3. 对象方法</h3><ul><li><p>Object.keys(obj): 获取obj对象自身的所有属性</p></li><li><p>Object.defineProperty(obj, prop, descriptor): 定义对象中新属性或者修改原有属性</p><p><img src="/img/defineProperty.png" alt="code"></p></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js面向对象</title>
    <link href="/2023/06/15/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/15/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>JavaScript面向对象</h2><h4>1.面向对象编程 </h4><p>两大编程思想：</p><ul><li><p>面向<span class="red">过程</span>编程(POP) - Process-oriented Programming</p><p>这种编程思想需要分析出解决问题所需的步骤，然后利用函数将每一步实现，在使用时依次调用。</p></li><li><p>面向<span class="red">对象</span>编程(OOP) - Object-oriented Programming</p><p>这种编程思想需要把事务分解成一个个对象，然后由对象之间分工与合作。</p><p>每一个对象都是功能中心且分工明确，OOP具有<span style="color: #22a2c3">灵活、代码可复用、容易维护和开发</span>的优点。</p></li></ul><h4>2.ES6中的类和对象 - ES6新增了类的概念 </h4><p>当用面向对象的思想描述现实事物的时候，事物可以分为具体事务和抽象事物。</p><p>面向对象的思维特点：</p><ul><li>抽取抽象对象的公共属性和方法封装成一个<span style="color: #22a2c3">类</span></li><li>对类进行实例化，得到一个具体的<span style="color: #22a2c3">对象</span></li></ul><h4>3.创建类和实例的方法</h4><p>class Name {}；&#x2F;&#x2F;创建类</p><p>var obj &#x3D;  <span class="red">new</span> Name();  &#x2F;&#x2F;创建实例</p><h4>4.类constructor构造函数</h4><p>constructor()构造函数(方法)是一种用于创建和初始化创建的对象的特殊方法，并没有返回值。在new命令生成实例对象的时候自动调用该方法，如果没有显示的定义，类的内部会自动创一个constructor(),用于传递参数，返回实例对象。</p><p>class Person {</p><p>   constructor(name, age) {</p><p>​      this.name &#x3D; name;</p><p>​  this.age &#x3D; age;}</p><p>}</p><p>当创建刘昕瑶实例 var lxy &#x3D; Person(‘刘昕瑶’，25)的时候，会自动调用并且给刘昕瑶实例添加name和age属性。</p><p><i class="fa-regular fa-face-thinking"></i>【思考】：所以类中的共有<span class="red">属性</span>可以添加到constructor构造函数中，那么<span class="red">方法</span>呢？</p><h4>5.类添加方法</h4><p>在类中，所有的方法不需要function关键字也不能加逗号分割</p><p>e.g.  还拿4中的Person类举例</p><p>class Person {</p><p>   constructor(name, age) {</p><p>​      this.name &#x3D; name;</p><p>​  this.age &#x3D; age;}</p><p>​say() {</p><p>​  console.log( ‘hi’ + this.name )}</p><p>}</p><h4>6.类的继承</h4><p><span class="red"><strong>继承</strong></span>：子类可以继承父类的一些属性和方法，通过<span class="red"><strong>extends</strong></span>关键字</p><p>class Father {}</p><p>class Son <span class="red">entends</span> Father {&#x2F;&#x2F;子类继承父类</p><p>}</p><p>【问题：如果父类里某个方法是sum(){this.x+this.y},子类在继承的时候也想使用sum方法，<strong>如何调用父类的构造函数呢？</strong>】</p><h5>6.1 super关键字</h5><p>super关键字用于访问和调用对象父类上的函数，且<span class="red">可以调用父类的构造函数</span>，也可以调用普通函数。</p><p>class Father {</p><p>​constructor(x,y) {</p><p>​  this.x &#x3D; x;</p><p>​  this.y &#x3D; y;}</p><p>​sum() {</p><p>​  console.log(this.x + this.y)}</p><p>}</p><p>class Son extends Father{</p><p>​constructor(x,y) {</p><p>​super(x,y);&#x2F;&#x2F;调用父类的构造函数</p><p>​}</p><p>}</p><p>var son &#x3D; new Son(1,2)</p><p>son.sum()</p><h4>7. 构造函数</h4><p>引入：在es6之前，js中并没有引入类的概念，所以在es6之前对象都是用<span class="red">构造函数</span>来定义对象和他们的特征</p><p>回忆：创建对象的三种方式：</p><ul><li><p>字面量： var obj1 &#x3D; {}</p></li><li><p>new关键字：var obj2 &#x3D; new Object()</p></li><li><p>自定义<u>构造函数</u>： function Star(uname, age) {</p><p>​this.name &#x3D; uname;</p><p>​this.age &#x3D; age;</p><p>​this.sing &#x3D; function() {</p><p>​console.log(‘llalalalala’)}}</p></li></ul><h5>7.1 构造函数</h5><p>构造函数是一种特殊的函数，没有返回值。主要用于初始化对象，他总与new一起使用。</p><p>我们可以把对象中一些公共的属性和方法抽象出来，封装到这个函数中。</p><h5>7.2 new关键字执行时操作</h5><p>new在执行时会：</p><ol><li>在内存中创建一个新的空对象</li><li>让this指向这个新的对象</li><li>执行构造函数里的代码，给这个对象添加属性和方法</li><li>返回这个新的对象（故不需要return）</li></ol><h5>7.3 成员</h5><p>在构造函数中的属性和方法我们称为成员，成员可以在构造函数本身上添加，也可可以在构造函数内部this上添加。</p><p>function Star(uname, age) {</p><p>​this.name &#x3D; uname;</p><p>​this.age &#x3D; age;}</p><p>Star.sex &#x3D; ‘女’;</p><ul><li><p>在构造函数本身上添加的成员称为<strong><span class="red">静态成员</span></strong>，只能由构造函数本身来访问</p><p>console.log(Star.sex)</p></li><li><p>在构造函数内部创建的成员称为<strong><span class="red">实例成员</span></strong>，只能由实例化的对象来访问</p><p>var lxy &#x3D; Star(‘Lxy’, 25);</p><p>console.log(lxy.name)</p></li></ul><p>【问题：浪费内存】</p><h4>8. 构造函数原型 prototype</h4><p>在2中构造函数存在一个问题，两个不同的对象中相同的function会占用两份内存空间，造成内存的浪费，如何将不同对象使用同一个函数？</p><h5>8.1 构造函数原型 prototype</h5><p><span class="red">原型</span>：构造函数通过原型分配的函数是所有对象共享的。js规定， 每一个构造函数都有一个prototype属性，指向另一个对象。这个对象所有的属性和方法都会被构造函数所拥有。</p><p>故，我们可以把不变的方法直接定义在prototype对象上，这样所有的对象实例可以共享这些方法。</p><p>【一般，<span class="red">公共属性</span>定义在<strong>构造函数</strong>里，<span class="red">公共方法</span>定义在<strong>原型对象</strong>中】</p><p>还是以上面的Star构造函数为例：</p><p>Star.<span class="red">prototype.sing</span> &#x3D; function() {</p><p>​console.log(‘lalalala’)}</p><p>var ldh &#x3D; Star(‘刘德华’， 18)；</p><p>var zxy &#x3D; Star(‘张学友’， 19)；</p><p>console.log(ldh.sing &#x3D;&#x3D;&#x3D; zxy.sing);&#x2F;&#x2F;true</p><h5>8.2 原型对象 __proto__</h5><p>对象都会有一个属性 __ proto __，指向构造函数的prototype原型对象。</p><p>之所以对象可以使用构造函数中的prototype原型对象的属性和方法，就是因为对象中__ proto __原型的存在。</p><p><img src="/img/proto.jpg" alt="prototype和__ proto __ 的关系"></p><p> 对象原型存在的意义就是为对象的查找机制提供一个方向，在实际开发中不可以使用这个属性，只用来在内部指向prototype原型对象。</p><h4>9. constructor构造函数</h4><p>对象原型__ proto __ 和构造函数原型对象prototype里都有一个属性：constructor构造函数，指回构造函数本身。</p><p>constructor主要用于记录该对象引用于哪个构造函数，并让原型对象指向原来的构造函数。</p><p>一般情况下，对象的方法都在构造函数的原型对象中设置。</p><p>但是如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象的constructor就不再指向当前的构造函数了。</p><p>此时，可以在修改后的原型对象中，添加一个constructor指向原来的构造函数。</p><p><img src="/img/constructor.jpg" alt="constructor"></p><hr><p>总结：<strong>构造函数</strong>Star、<strong>实例</strong>ldh、<strong>原型对象</strong>Star.prototype之间的关系</p><p><img src="/img/protoobj.jpg" alt="关系图"></p><h4>10. 原型链</h4><p>当访问一个对象的某个属性时，会现在这个对象本身属性上找，如果没找到就会通过__ proto __ 隐形属性找到它的构造函数的原型对象，如果还没有，就继续在构造函数的prototype(也是对象，也有__ proto __ ) 中的__ proto __里去找。这样一层层向上查找就会形成一个链式结构，称为<span class="red">原型链</span>。</p><p><img src="/img/%E5%8E%9F%E5%9E%8B%E9%93%BE.jpg" alt="原型链"></p><p>javascript的成员查找机制：<span class="red">按照原型链</span>，一直找到null</p><p>所以说__ proto __ 对象原型的意义就是在于为对象成员查找机制提供一个方向。</p><p>reference：<a href="https://juejin.cn/post/6984678359275929637">一文搞懂JS原型与原型链（超详细，建议收藏） - 掘金 (juejin.cn)</a></p><h4>11. 原型对象中的this指向问题</h4><ul><li>构造函数中的this指向实例对象。</li><li>原型对象里面放的是方法，方法里的this指向的是方法的调用者，也就是实例对象。</li></ul><h4>12. es6之前的继承</h4><p>es6之前并没有extends继承，但是我们可以通过构造函数+原型对象这种<span class="red">组合继承</span>的方式模拟实现继承</p><h5>12.1 call()：调用，修改函数运行时的this指向</h5><p><img src="/img/call.png" alt="call"></p><h5>12.2 借助构造函数继承父类<span class="red">属性</span></h5><p><span class="red">核心原理</span>：通过call()将父类的this指向子类的this从而实现继承。</p><p><img src="/img/%E7%BB%A7%E6%89%BF.jpg" alt="继承"></p><h5>12.3 借助原型对象继承父类<span class="red">方法</span></h5><p><span class="red">核心原理</span>：将子类的共享方法提取出来，让子类的prototype原型对象 &#x3D; new 父类(),将子类的constructor重新指向子类的构造函数。</p><p>reference：[(70条消息) 借用原型对象继承父类型方法_susu1198的博客-CSDN博客](</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECharts项目-可视化展板随想</title>
    <link href="/2023/06/08/ECharts%E9%A1%B9%E7%9B%AE-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E6%9D%BF%E9%9A%8F%E6%83%B3/"/>
    <url>/2023/06/08/ECharts%E9%A1%B9%E7%9B%AE-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B1%95%E6%9D%BF%E9%9A%8F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h2>ECharts项目-可视化展板</h2><h4>1. 用到的技术栈</h4><ul><li>基于flexible.js + rem智能大屏适配</li><li>flex布局</li><li>less - 使用easy less插件直接将less转换为css引入</li><li>基于Echarts数据可视化展示</li><li>Echarts柱状图、饼状图</li><li>Echarts地图</li></ul><h4>2. 适配方案 - flexible.js + rem</h4><h5>2.1 flexible.js</h5><p>flexible.js是专门为了解决不同设备间显示适配方案的，根据可视区大小，默认除以10，也就是可视区的1&#x2F;10就是1rem的大小，设置为font-size，使得每个使用rem单位的元素都可以自动适应屏幕的大小。</p><p>因为我们的项目希望只在pc端进行显示，按照默认十份进行划分1rem有点大了，修改flexible.js改成24等分。</p><h5>2.2 px to rem插件</h5><p>为了省掉换算，使用插件px to rem，但是要将设置里的font-size改成我们的1920&#x2F;24&#x3D;80</p><h4>3. 布局</h4><h5>3.1 header部分</h5><p>里面用一个h1标题居中显示，一个时间模块靠右侧定位。</p><h5>3.2 主体部分</h5><p>给主体大盒子设置display：flex，提供flex布局，其中三个小盒子分别占比3：5：3。</p><p>准备一个公共的面板样式panel，设置公共的样式，其中上下两个角的样式按照伪元素before、after的border进行设计；下面两个角选择在panel里加个定位的盒子再继续使用这个新底部盒子的伪元素的border加两个角。每个panel里分为一个h2标题做图表的标题，一个chart图表部分。</p><p>中间的地球bg图片想要定位在水平垂直居中的位置：</p><p>position: absolute;</p><p>left: 50%;</p><p>top: 50%;</p><p>transform: translate(-50%, -50%);</p><p>在地球bg图片上覆盖一个可以做<u>不停旋转</u>动画的图片，利用index压住bg图片。</p><h4>4. 交互</h4><h5>4.1 header部分</h5><p>header中的时间模块的innerHTML显示为当前的时间代码：</p><p>var t &#x3D; null;</p><p>   t &#x3D; setTimeout(time, 1000);&#x2F;&#x2F;定时器：每1000ms执行time函数</p><p>   function time() {</p><p>​    clearTimeout(t);</p><p>​    dt &#x3D; new Date();</p><p>​    var y &#x3D; dt.getFullYear();</p><p>​    var m &#x3D; dt.getMonth() + 1;</p><p>​    var d &#x3D; dt.getDate();</p><p>​    var h &#x3D; dt.getHours();</p><p>​    var min &#x3D; dt.getMinutes();</p><p>​    var s &#x3D; dt.getSeconds();</p><p>​    document.querySelector(“.showTime”).innerHTML &#x3D; “当前时间：” + y + “年” + m + “月” + d + “日-“ + h + “时” + min + “分” + s + “秒”;</p><p>​    t &#x3D; setTimeout(time, 1000);</p><p>   }</p><h5>4.2 主体部分</h5><p>因为在主体部分我们已经准备好了很多图表的容器，但是在ECharts的使用过程中需要获取并且给每一个图表做不一样的配置，为了避免这样带来的变量污染，减少命名冲突，采取<span class="red">立即执行函数</span>的写法，这样里面的变量均为<span class="red">局部变量</span>。</p><h4>5. 字体样式</h4><p>在中间column的数字展示模块，引用图标字体electonicFont美化数字展示方式。</p><p>首先，要在css或者less最上面声明字体@font-face！然后就可以在li中使用了，将font-family属性值设置为‘electonicFont’。</p><h4>6. ECharts使用步骤总结</h4><ul><li><p>下载并引用echarts.js</p></li><li><p>为需要用Echarts的图表准备一个定义宽高的DOM容器</p></li><li><p>通过echarts.init方法初始化一个echarts实例</p></li><li><p>通过setOption方法指定配置项和相关数据使其生效</p><p>其中<u>配置项和数据</u>是使用的重难点。</p></li></ul><h4>7. ECharts配置</h4><ul><li><p>tooltip: 提示框</p></li><li><p>legend：图例。若series中有name值，则legend的data可以省略。</p></li><li><p>grid：网格</p><p>【注意：DOM容器时整个图表的大小，而grid是只有最中间的大小】</p><p><img src="/img/echartsGrid.png" alt="DOM v.s. grid"></p></li><li><p>series：系列图表，决定显示哪种类型的图表。这是<strong>数组</strong>的形式，里面包含了n个对象，每一个对象对应一条线。</p></li><li><p>color: 设置线条的颜色，注意也是数组的形式和series对应。</p></li></ul><h4>8. ECharts随着屏幕的自适应</h4><p>  window.addEventListener(“resize”, function() {<br>    myChart.resize();<br>  });</p><hr><p>最后做出来的效果belike！！！</p><p><img src="/img/EchartsProjFinal.png" alt="final version"></p><hr><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>projects</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jQuery项目-todolist随想</title>
    <link href="/2023/06/06/jQuery%E9%A1%B9%E7%9B%AE-todolist%E9%9A%8F%E6%83%B3/"/>
    <url>/2023/06/06/jQuery%E9%A1%B9%E7%9B%AE-todolist%E9%9A%8F%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<h2>JQuery项目-todolist</h2><h4>1. 布局</h4><p>body里主要分三个部分：header头部，footer底部和中间部分我用section包裹。</p><h5>1.1 header结构</h5><p>我希望可以将ToDoList和后面的输入框<strong><u>绑定</u></strong>， 所以选择使用label包围ToDoList， 这样就可以点击文字的时候同时选中输入框。</p><p>对于输入框input，需要注意id要和label的for的值一样才能绑定；对于想要默认展示的文字，需要使用placeholder属性；将autocomplete设置为”off”避免自动记录之前的历史；required&#x3D; “required”设置不能提交空表单。</p><h5>1.2 footer结构</h5><p>文字就可以，但是注意版权符号需要转义使用&amp;copy;</p><h5>1.3 主体结构</h5><p>再分成两部分：正在进行和已经完成。</p><p>这里选择也用section包围，因为这样的话就可以达到和header内容的版心对齐效果。</p><p>其中每部分的结构都是一样的，h2标题和数量在一行，下一行是list。</p><hr><p>最后，刚写完html的初版网页belike：</p><p><img src="/img/jq-1.png" alt="v1"></p><hr><h4>2. 样式</h4><h5>2.1 整体样式</h5><p>去除body默认的padding和margin，将背景颜色改为#CDCDCD</p><p>去除ol和ul默认的list-style和padding</p><h5>2.2 header样式</h5><p>固定高度，要不然由内容撑起来显得太窄了；将版心固定宽度然后居中对齐。</p><p>label的文字ToDoList垂直居中，需要设置line-height的大小和height一样大，并且左浮动。</p><p>input输入框使用border-radius设为圆角, 里面默认的字离左边框太近了，使用text-indent让文字往后缩进；当选定input输入框时，将outline-width设为0去掉；向右浮动。</p><h5>2.3 footer样式</h5><p>文字水平居中使用text-align：center；</p><h5>2.4 主体样式</h5><p>因为我的html结构里，把count写在h2里面了，所以给h2一个相对定位，count一个绝对定位来摆放他们的位置；我的count在结构里是用span包裹的，因为span是行内元素，想要改变大小，还需要将display设置为inline-block；</p><h5>2.5 响应式布局</h5><p>为了页面可以随着屏幕尺寸做自适应的拉伸，将版心section设定的固定的宽度注销掉，在媒体查询里定义。</p><hr><p>加上了css的v2版网页belike：</p><p><img src="/img/jq-2.png" alt="v2"></p><hr><h4>3. 交互</h4><p>因为我们希望可以达到刷新或者关掉页面也不会丢失数据的效果，需要用到本地存储localStorage</p><h5>3.1 todo1: 按下回车将完整的数据存储到本地存储里</h5><p>首先先给输入框绑定一个keydown的事件。在处理函数中要先通过事件对象e.keyCode判断按键是否为回车键，若是再判断是否为空，若空则alert提示。</p><p>若非空则先读取本地存储原来的数据，再将新数据合并再更新存储到本地存储。最后渲染到页面上再将输入框的值置空。</p><p>其中，读取数据的操作比较频繁就封装个函数，由于本地存储的数据都是<u>字符串格式</u>，需要<span class="red">JSON.parse()</span>转换为<u>javascipt对象</u>。同理，将数据存储到成本地存储也封装成函数，需要将javascipt对象data使用JSON.stringify(data)转换为本地存储的字符串格式。</p><p>将本地存储的所有数据渲染到页面上的功能也封装成函数。调用读取数据的方法，对data进行遍历，遍历的时候通过判断值的done属性值来判断是添加到哪个list。添加的方法选择使用prepend在内部的前面添加，添加的内容就是li标签。</p><h5>3.2 todo2: 删除操作</h5><p>并集选择ol和ul两个list中的a，如果点击就将data进行splice然后再存再渲染。</p><h5>3.3 todo3: 选项操作</h5><p>并集选择ol和ul两个list中的input，如果点击就将对应的数据的done属性进行修改，然后再存再渲染。</p><p>这里需要注意的是要通过$(this)的siblings找到a再找到id属性值。</p><hr><p>加上了js的v3版网页belike：</p><p><img src="/img/jq-3.png" alt="v3"></p><hr><h4>4. 再休整一下样式</h4><h5>4.1动态添加的li</h5><p>给两个list不同颜色左边框，圆角一点，左右padding把内容挤到中间一点；</p><p>给li加相对定位，这样给里面包含的input和a绝对定位就可以固定位置了；</p><hr><p>最后的final version!!!</p><p><img src="/img/jq-4.png" alt="v4"></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>projects</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery四-事件</title>
    <link href="/2023/06/06/JQuery%E5%9B%9B-%E4%BA%8B%E4%BB%B6/"/>
    <url>/2023/06/06/JQuery%E5%9B%9B-%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2>JQuery事件</h2><h4>1. 事件注册</h4><p>element.事件(function() {xxx})</p><p>e.g.  $(‘div’).click(function() {xxx})</p><h4>2. 事件处理on()绑定事件</h4><p>事件处理on()方法在匹配元素上绑定一个或多个事件的事件处理函数</p><p>element.on(events, [selector], fn)</p><p><img src="/img/jq-on.png" alt="on方法"></p><hr><p>[on()的优势]：</p><ul><li>可以绑定多个事件，多个处理事件的处理程序；如果处理事件的处理程序相同，可以在events使用并集的写法</li><li>可以<span class="red">事件委派</span>操作，把原来加给子元素身上的事件绑定在父元素身上。</li><li>可以给动态创建的元素绑定事件。</li></ul><h4>3. 事件处理off()解绑事件</h4><p>$(“p”).off() &#x2F;&#x2F;解绑p元素所有的事件处理程序</p><p>$(“p”).off(“click”)  &#x2F;&#x2F;解绑p元素的点击事件</p><p>$(“p”).off(“click”, “li”)&#x2F;&#x2F;解绑事件委托</p><h4>4. jQuery事件对象</h4><p>element.on(envents, [selectors], function(<span class="red">event</span>) {xxx})</p><p>阻止默认行为： event.preventDefault()</p><p>阻止冒泡：event.stopPropagation()</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery三-动画</title>
    <link href="/2023/06/06/JQuery%E4%B8%89-%E5%8A%A8%E7%94%BB/"/>
    <url>/2023/06/06/JQuery%E4%B8%89-%E5%8A%A8%E7%94%BB/</url>
    
    <content type="html"><![CDATA[<h2>JQuery动画效果</h2><p>JQuery中封装了很多动画效果，如显示隐藏、滑动、淡入淡出、自定义动画等。</p><h4>1. 显示隐藏</h4><p>一般用的时候都很少带参数，直接显示或者隐藏即可。</p><ul><li><p>show([speed, [easing], [fn]])</p></li><li><p>hide([speed, [easing], [fn]])</p></li><li><p>toggle([speed, [easing], [fn]])</p></li></ul><h4>2. 滑动效果</h4><ul><li>下滑slideDown([speed, [easing], [fn]])</li><li>上滑slideUp([speed, [easing], [fn]])</li><li>滑动切换slideToggle([speed, [easing], [fn]])</li></ul><h4>3. 事件切换</h4><p>hover([over,]out)</p><p>over: 鼠标移动到元素上触发的函数</p><p>out：鼠标移出元素要触发的函数</p><p>但是多次触发会造成动画或者效果排队执行，引入<span class="red">停止排队stop</span></p><p>stop(): 停止动画或者效果</p><h4>4. 淡入淡出效果</h4><ul><li>fadeIn([speed, [easing], [fn]])</li><li>fadeOut([speed, [easing], [fn]])</li><li>fadeToggle([speed, [easing], [fn]])</li><li>fadeTo([[speed],opacity, [easing], [fn]])修改透明度</li></ul><h4>5. 自定义动画animate</h4><p>animate(params, [speed], [easing], [fn])</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery二-常用API</title>
    <link href="/2023/06/06/JQuery%E4%BA%8C-%E5%B8%B8%E7%94%A8API/"/>
    <url>/2023/06/06/JQuery%E4%BA%8C-%E5%B8%B8%E7%94%A8API/</url>
    
    <content type="html"><![CDATA[<h2>jQuery常用API</h2><h4>1. jQuery选择器</h4><ul><li><p>ID选择器   $(“id”)</p></li><li><p>全选选择器   $(“*”)</p></li><li><p>类选择器    $(“.class”)</p></li><li><p>标签选择器   $(“div”)</p></li><li><p>并集选择器    $(“div,p,li”)</p></li><li><p>交集选择器    $(“li.current”)</p></li><li><p>子代选择器  $(“ul&gt;li”)</p></li><li><p>后代选择器   $(“ul li”)</p></li></ul><h4><i class="fa-sharp fa-solid fa-marker"></i><span class="red">2.隐式迭代</span></h4><p>遍历内部DOM元素（伪数组形式存储）的过程称为<span class="red">隐式迭代</span></p><h4>3. jQuery筛选方法（函数）</h4><ul><li>parent()    最近的父级</li><li>children(selector)   </li><li>find(selector)   后代选择器</li><li>siblings()   查找兄弟节点</li><li>eq(n)   下标为n的</li></ul><h4>4. 排他思想</h4><p>想要多选一的效果，思想：当前元素设置样式，其他兄弟元素清除样式。</p><p>e.g.    $(this).css(‘color’, ‘red’);</p><p>​  $(this).siblings().css(‘color’, ‘’);</p><h4>5. 链式编程</h4><p><i class="fa-sharp fa-solid fa-thumbs-up"></i>尊滴优雅啊！！！</p><p>e.g.     $(this).css(‘color’,’red’).siblings().css(‘color’, ‘’);</p><h4>6. jQuery样式操作</h4><p>当需要操作的<span class="red">样式少</span>的情况下，可以使用<span>css方法</span></p><p>当需要操作的样式多的情况下，可以操作类修改多个样式</p><h5>6.1 操作css方法</h5><ul><li>$(this).css(‘color’);   参数只写属性名，则返回属性值</li><li>$(this).css(‘color’, ‘red’);   设置属性</li><li>$(this).css({‘color’: ‘red’, ‘font-size’: ‘20px’})； 参数为对象形式可以设置多组样式</li></ul><h5>6.2 设置类样式方式</h5><ul><li>添加类： $(‘div’).addClass(‘current’)</li><li>移除类:   $(‘div’).removeClass(‘current’)</li><li>切换类： $(‘div’).toggleClass(‘current’)</li></ul><p>[注： 类操作与原生js里的className的区别]原生js的className会覆盖原来的类名，jQuery的类操作不影响原来的类名。</p><h4>7. jQuery属性操作</h4><ul><li><p>设置或获取元素<span class="red">固有属性值</span>：</p><p>获取：element.prop(‘属性’)   #prop &#x3D; property</p><p>设置：element.prop(‘属性’，’属性值’)</p></li><li><p>设置或获取元素<span class="red">自定义属性值</span>：</p><p>获取：element.attr(‘属性’)   #attr &#x3D; attribute</p><p>设置：element.attr(‘属性’，’属性值’)</p></li></ul><h4>8. jQuery内容文本值</h4><ul><li>普通元素内容html()   &#x2F;&#x2F;但是还有标签</li><li>普通元素文本内容text()</li><li>表单的值val()</li></ul><h4>9. jQuery元素操作</h4><h5>9.1 遍历元素</h5><p>jQuery隐式迭代是对同一类的元素做相同的操作，但是若想做不同操作则需要进行遍历</p><ul><li><p>$(‘div’).each(function (index, domEle) {xxx;})</p></li><li><p>$.each(object, function(index, element) {xxx;})</p></li></ul><h5>9.2 创建元素</h5><p>$(‘<li></li>‘)动态创建一个li</p><h5>9.3 添加元素</h5><ul><li>element.append(‘content’) 类似原生appendChild</li><li>element.prepend(‘content’)把内容放入匹配元素内部的最前面</li><li>element.after(‘content’) 把内容放入目标元素后面</li><li>element.before(‘content’)把内容放入目标元素前面</li></ul><h5>9.4 删除元素</h5><p>element.remove()</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JQuery一</title>
    <link href="/2023/06/06/JQuery%E4%B8%80/"/>
    <url>/2023/06/06/JQuery%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2>JQuery入门</h2><p>JQuery是一个JavaScript库，封装了javascript常用的功能代码，为了<span class="red">更快速方便的操作DOM</span>。</p><h4>1. jQuery基本使用</h4><p><img src="/img/jQueryUse.jpg" alt="基本使用"></p><p><i class="fa-sharp fa-solid fa-hippo"></i>原生js如果想把script标签写到div的上面，需要通过窗口加载事件load或者DOMContentLoaded，那么JQuery呢？</p><h4>2. JQuery入口函数</h4><p><span class="red">就相当于原生js的DOMContentLoaded</span>，等DOM结构渲染完毕，不需要等所有外部资源加载完成就可以执行function。</p><p>$(function() {});</p><h4>3. JQuery顶级对象$</h4><p>注意：</p><ul><li>$是jQuery的别称，可以互为替代，但是为了方便还是用$</li><li>$是jQuery的顶级对象，相当于原生js的window</li><li>用$包装元素成jQuery对象，就可以调用jQuery方法。</li></ul><h4>4. JQuery对象和DOM对象的区别</h4><p>JQuery对象是用jQuery方法获取来的对象</p><p>DOM对象是用原生JS获取来的对象</p><p>但是jQuery对象的<span class="red">本质</span>是：利用$对DOM元素进行包装，以<span class="red">伪数组</span>形式存储。</p><p><img src="/img/jqvsjs.png" alt="jQuery对象和DOM对象的区别"></p><h4>5. DOM对象和JQuery对象的相互转换</h4><p>因为jQuery只封装了原生js中的最常用的那部分属性和方法，所以如果想要使用剩下没被封装的，还需要进行转换。</p><ol><li><p>DOM对象 -&gt; JQuery对象： <span class="red">$(DOM对象)</span></p></li><li><p>JQuery对象 -&gt; DOM对象：用<span class="red">伪数组</span>方式调用</p><p>$(‘div’)[index]</p></li></ol><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jquery</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>本地存储</title>
    <link href="/2023/06/06/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <url>/2023/06/06/%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<h2>本地存储</h2><p>HTML5规范提出了需要本地存储大量数据的相关解决方案。</p><h4>1. window.sessionStorage</h4><p>[<span class="red">特点</span>]：</p><ul><li>生命周期为关闭浏览器窗口</li><li>在同一个窗口（页面）下数据可以共享</li><li>以键值对的形式存储</li></ul><p>[语法]：</p><ul><li>存储：sessionStorage.setItem(key, value)</li><li>获取：sessionStorage.getItem(key)</li><li>删除:   sessionStorage.removeItem(key)</li><li>删除全部数据: sessionStorage.clear()</li></ul><h4>2. window.localStorage</h4><p>[<span class="red">特点</span>]：</p><ul><li>生命周期永久有效，除非手动删除，不然关掉页面也会存在</li><li>可以多窗口（页面）共享数据，只要在同一浏览器中</li><li>也是以键值对的形式存储使用</li></ul><p>[语法]：</p><ul><li>存储：localStorage.setItem(key, value)</li><li>获取：localStorage.getItem(key)</li><li>删除：localStorage.removeItem(key)</li><li>删除全部数据: localStorage.clear()</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端网页特效</title>
    <link href="/2023/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/"/>
    <url>/2023/06/06/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2>触屏事件touch</h2><p>touch对象代表一个触摸点，触屏事件可相应用户对屏幕或者触控板的操作。</p><h4>1. 常见的touch事件</h4><ul><li>touchstart - 手指触摸到一个DOM元素时触发</li><li>touchmove - 手指在一个DOM元素上滑动时触发</li><li>touchend - 手指从一个DOM元素上移开时触发</li></ul><h4>2. 触摸事件对象</h4><p>TouchEvent是一类描述手指在触摸平面状态变化的事件。常见的触摸事件对象列表</p><ul><li>touches： 正在触摸屏幕的所有手指的列表</li><li>targetTouches：正在触摸当前DOM元素上的手指列表</li><li>changedTouches：手指状态发生改变的列表（从有到无&#x2F; 由无到有）</li></ul><h4>3. 移动端拖动元素</h4><p>思想：</p><p>step1： 触摸元素touchstart，计算手指的初始坐标，同时获得盒子原来的位置。</p><p>step2： 移动手指touchmove，计算手指的滑动距离，移动盒子。</p><p>step3： 离开手指touchend。</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>确定元素位置总结</title>
    <link href="/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4>offsetX</h4><p>偏移量offsetX - 相对offsetParent偏移了多少？</p><p>注意offsetParent是指带有定位的父级节点</p><p>offsetWidth和offsetHeight指包含border，padding，content的宽高。</p><h4>scrollX</h4><p>滚动量scrollX - 文档相对于当前浏览器视口滚动了多少？</p><h4>clientX</h4><p>这个属性描述自身位置。</p><p>clientTop就是border-top的值，clientWidth不包含border</p><p>Reference: <a href="https://blog.csdn.net/lefex/article/details/104682178">(68条消息) 彻底搞懂 offsetX、scrollX、clientX 的区别_lefex的博客-CSDN博客</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC端网页特效</title>
    <link href="/2023/06/05/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/"/>
    <url>/2023/06/05/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2>元素偏移量offset系列</h2><h4>1. offset偏移量概述</h4><p>使用offset系列相关属性可以<span class="red">动态的</span>得到该元素的位置（偏移）、大小等。</p><h4>2. offset系列常用属性</h4><ul><li>element.offsetParent: 返回作为该元素带有定位的父级元素</li><li>element.offsetTop: 返回元素相对带有定位的父元素上方的偏移</li><li>element.offsetLeft: 同上，但是左边框的偏移</li><li>element.offsetWidth: 返回自身包括padding，边框，内容区的宽度，且不带单位</li></ul><h4>3. offset v.s. style</h4><p><img src="/img/offsetvsstyle.jpg" alt="offset v.s. style"></p><hr><h2>元素可视区client系列</h2><h4>1. client概述</h4><p>client本身是客户端的意思，使用client系列相关属性可以获取<u>元素可视区</u>的相关信息, 动态的得到该元素边框大小，元素大小等。</p><h4>2. client系列属性</h4><ul><li>element.clientTop: 返回元素上边框的大小</li><li>element.clientLeft: 返回元素左边框的大小</li><li>element.clientWidth: 返回元素自身包括padding，内容区的宽度，但是不包含边框（这是和offset最大的区别)</li></ul><hr><h2>元素滚动scroll系列</h2><h4>1. scroll系列属性</h4><ul><li>element.scrollTop: 返回被卷上去的距离</li><li>element.scrollLeft: 返回被卷去的左侧距离</li><li>element.scrollWidth: 返回自身实际宽度，不包含边框，返回数值不带单位</li></ul><h4>2. onscroll事件</h4><p>当浏览器的高或者宽度不足以显示整个页面的时候，会自动出现滚动条。滚动条在滚动时会触发onscroll事件。</p><hr><p>【这里总结一下以上三种的异同！！】</p><p>[sum](<a href="https://noelleliu.github.io/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/">确定元素位置总结 - 德芭贝贝同学今天code了吗 (noelleliu.github.io)</a>)</p><hr><h2>动画函数封装</h2><p>通过setInterval（）不断移动盒子的位置就可以达到动画的效果。</p><h2><span class="red">节流阀</span></h2><p>目的：为了防止轮播图按钮连续点击造成播放太快</p><p>本质：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p><span class="red">核心实现思路</span>: 利用回调函数， 添加一个变量来控制，锁住和解锁函数。</p><p>伪代码：</p><p>​var flag&#x3D;true;&#x2F;&#x2F;默认水龙头开着</p><p>​if(flag) {</p><p>​flag &#x3D; false;</p><p>​        do something} &#x2F;&#x2F;为了确保无法连续触发， 关闭水龙头</p><p>​    callback，flag&#x3D;true；&#x2F;&#x2F;利用回调函数执行动画完毕后，打开水龙头</p><p>代码参考：</p><p><img src="/img/%E8%8A%82%E6%B5%81%E9%98%80%E4%BB%A3%E7%A0%81.png" alt="code"></p><p>Reference: <a href="https://blog.csdn.net/qq_36958206/article/details/109049938">(68条消息) JS的节流阀_前端节流阀_鹿小风的博客-CSDN博客</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM对象</title>
    <link href="/2023/06/05/BOM%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/05/BOM%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>Location对象</h2><h4>1. location对象的定义</h4><p>window对象给我们提供了一个location属性，用于<span class="red">获取或设置窗体的URL</span>，并且可以用于解析URL。因为这个属性返回的是一个对象，也称这个属性为location对象。</p><h4>2. URL: Uniform Resource Locator 统一资源定位符</h4><p>互联网上每个文件都有一个唯一的URL， 包含文件的位置以及浏览器应该如何处理等信息。</p><p><u>URL一般语法</u>： protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment</p><h4>3. location对象的属性</h4><p><img src="/img/location.jpg" alt="location对象的属性"></p><hr><h2>Navigator对象</h2><p>navigator对象包含有关浏览器的信息，它有很多属性，最常用的是<span class="red">userAgent</span>, 该属性可以返回由客户机发送服务器的user-agent头部的值，用来判断用户在哪个终端打开页面。</p><hr><h2>History对象</h2><p>windows对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p><h4>history对象方法</h4><ul><li>back(): 后退</li><li>forward(): 前进</li><li>go(argument): 参数为正则前进argument个页面，负则后退。</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js执行队列</title>
    <link href="/2023/06/05/js%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/06/05/js%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2>JS执行队列</h2><h4>1. JS是单线程</h4><p>JavaScript语言的一大特点就是<span class="red">单线程</span>，也就是同一个时间只能做一件事。这也就意味着所有任务需要排队，这就导致如果js执行的时间过长，会造成页面渲染不连贯，导致<span class="red">页面渲染加载阻塞</span>的感觉。</p><hr><p><i class="fa-solid fa-arrows-down-to-line" style="margin: 0 auto;"></i></p><hr><p>为了解决这个问题，利用多核cpu的计算能力，<span class="red">HTML5</span>允许JavaScript脚本创建多个线程，所以JS中出现了<span class="red">同步</span>和<span class="red">异步</span>。</p><h4>2. 同步</h4><p>前一个任务结束后再执行下一个任务，程序的执行顺序与任务的排队顺序一致。</p><h4>3. 异步</h4><p>在做一件事的同时还可以去处理其他事情。</p><h4>4. JS执行机制</h4><p>JS为了防止任务有排队等待时间过长的问题，把所有的任务分为两类。</p><ul><li><p>同步任务：都在主线程上执行，形成一个<span class="red">执行栈</span>。</p></li><li><p>异步任务：JS的异步是通过回调函数实现的，添加到<span class="red">任务队列（消息队列）</span>中。</p></li></ul><p>[<strong>JS执行机制</strong>]：先执行执行栈中的同步任务，异步任务（回调函数）放到任务队列中，一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，进行执行栈开始执行。</p><h4>5. 事件循环Event Loop</h4><p>由于主线程不断的重复获取任务，执行任务，再获取和执行任务，这种机制被称为<span class="red">事件循环</span></p><p><img src="/img/EventLoop.jpg" alt="Event Loop"> </p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-BOM</title>
    <link href="/2023/06/05/js-BOM/"/>
    <url>/2023/06/05/js-BOM/</url>
    
    <content type="html"><![CDATA[<h2>BOM</h2><h4>1. BOM的定义</h4><p>BOM ：Browser Object Model 浏览器对象模型</p><p>提供了独立于内容而与浏览器窗口进行交互的对象。BOM则由一系列相关的对象构成，并且每个对象提供了很多方法和属性。</p><p><verticalLine></verticalLine></p><p><img src="/img/DOMvsBOM.jpg" alt="DOM v.s. BOM"></p><h4>2. BOM的构成</h4><p>BOM： document，location, navigation, screen, history</p><p>[所以！！BOM包含了DOM]</p><h4>3. window对象的常见事件</h4><p>3.1 <strong>窗口加载事件</strong>：文档内容完全加载就会触发该事件，调用处理函数</p><p>window.onload &#x3D; function() {}&#x2F;&#x2F;传统方式注册</p><p>window.addEventListener(‘load’, function(){})&#x2F;&#x2F;方法监听方式注册</p><p>[好处]：有了window.onload就可以把js代码写到页面元素的上方，但是本质上还是等内容全部加载完毕再执行处理函数。</p><p>[ie9以上才支持的]：document.addEventListener(‘DOMContentLoaded’, function(){})，仅当DOM加载完成，就会触发执行函数。如果图片过多，onload触发需要较长的事件，DOMContentLoaded事件会比较合适。</p><p>3.2 <strong>调整窗口大小事件</strong>：常利用本事件完成响应式布局</p><p>window.onresize &#x3D; function() {}</p><p>window.addEventListener(‘resize’, function() {})</p><p>3.3 <strong>定时器</strong>：</p><ul><li><p>window.setTimeout(调用函数， [延迟毫秒数])：这是一个callback回调函数</p><p>var timer1 &#x3D; setTimeout(fn, 2000);</p><p>var timer2 &#x3D; setTimeout(fn, 5000);</p><hr><p>清除定时器的方式：window.clearTimeout(timeoutID)</p><p>e.g. 清除上面的timer1定时器</p><p>clearTimeout(timer1);</p></li><li><p>window.setInterval(回调函数，[间隔毫秒数]): 每隔一段时间就会反复调用</p><hr><p>清除定时器的方式：window.clearInterval(intervalID)</p></li></ul><p>3.4 <strong>this指向</strong>:</p><p>this的指向在函数定义的时候是确定不了的，只有在函数执行的时候才能确定this到底指向谁。一般this最终的指向的是调用它的对象。</p><ul><li>全局作用域下：this指向全局对象window</li><li>方法调用中：this指向调用的对象</li><li>构造函数中：this指向构造函数的实例</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-DOM事件流</title>
    <link href="/2023/06/05/js-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <url>/2023/06/05/js-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2>DOM事件流</h2><h4>1. 事件流</h4><p>描述从页面中接收事件的顺序。</p><h4>2. DOM事件流</h4><p>事件发生时会在节点元素之间按照特定的顺序传播。此传播过程即为DOM事件流。</p><h4> 3. DOM事件流三阶段</h4><p><span class="red">捕获阶段</span>：从windows对象依次向下传播，到达目标节点。捕获阶段不会相应任何事件。</p><p><span class="red">当前目标阶段</span>：目标节点触发事件。</p><p><span class="red">冒泡阶段</span>：从当前节点依次向上传播，直到windows对象。</p><p><a href="/img/EventFlow.jpg">DOM事件流三阶段</a></p><h4><span class="red">4. 注意<span></h4><p>a. JS代码中只能执行捕获或者是冒泡其中的一个阶段</p><p>b. onclick只能得到冒泡阶段</p><p>c. addEventListener(type, listener[,useCapture])如果第三个参数不写默认false就是在冒泡阶段调用事件处理程序；若设置为true，则是在事件捕获阶段调用事件处理程序。</p><p>d. 但是在开发中，关注事件冒泡会更多。</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件对象</title>
    <link href="/2023/06/05/js%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/05/js%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>事件对象</h2><h4>1. 事件对象的定义与理解</h4><p>事件对象的官方定义：event事件对象代表事件的状态，比如按键的状态，鼠标的位置等等。</p><p><span class="red">理解</span>：当DOM树中某一个元素事件被触发的时候，会同时自动产生一个用来描述事件的所有相关信息的对象，这就是event（事件对象）。</p><h4>2. 事件对象的使用语法</h4><p>2.1 可以直接通过event来获取</p><p>2.2 可以通过函数传参数的方式获取： eventTarget.onclick &#x3D; function(<span class="red">e</span>) {…}</p><h4>3. 事件对象常见的属性和方法</h4>[事件对象常见的方法和属性](/img/event.jpg)<h4>4. 阻止事件冒泡</h4><p>利用事件对象中的stopPropagation（）方法！！</p><p>var son &#x3D; document.querySelector(‘.son’);</p><p>son.addEventListener(‘click’, function(e) {</p><p>​alert(‘son’);</p><p>​<span class="red">e.stopPropagation();</span>&#x2F;&#x2F;阻止事件冒泡，这样就不会弹出下面的father！！！</p><p>})</p><p>var father &#x3D; document.querySelector(‘.father’);</p><p>father.addEventListener(‘click’, function() {</p><p>​alert(‘father’)})</p><h4>5. 事件委托（委派、代理）</h4><p>问题引出：如果想给ul的每个小li都注册事件，访问DOM次数过多会演唱整个页面的交互就绪时间。</p><p><strong>事件委托原理：</strong>不是给每个子节点单独设置事件监听器，而是设置在父节点上，利用冒泡影响每个子节点。</p><p>var ul &#x3D; document.querySelector(‘ul’); &#x2F;&#x2F;只需要获取一次</p><p>ul.addEventListener(‘click’, function(e) {</p><p>​alert(‘hhhhh’)})</p><h4>6. 常见的鼠标事件以及事件对象</h4><p><a href="/img/mouseEvent.jpg">常见的鼠标事件</a></p><p><a href="/img/%E9%BC%A0%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%BA%8B%E4%BB%B6.jpg">常见的鼠标事件对象</a></p><h4>7. 常见的键盘事件以及事件对象</h4><p><a href="/img/keyEvent.jpg">常见的键盘事件</a></p><p><a href="/img/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.jpg">常见的键盘事件对象</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件高级</title>
    <link href="/2023/06/05/js%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/06/05/js%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2>js事件高级</h2><h4>1. 注册事件（绑定事件）</h4><p>【传统的注册方式】：</p><p>​        var btn &#x3D; document.getElementById(‘btn’);&#x2F;&#x2F;获取事件源</p><p>​btn.onclick &#x3D; function() {alert(‘hhhhh’)}&#x2F;&#x2F;事件类型+事件处理程序</p><p><span class="red">特点</span>：注册事件的唯一性（同一个元素同一个事件只能设置一个处理函数，最后注册的会覆盖前面注册的处理函数</p><p>【<span class="red">方法监听注册方式</span>】：W3C标准推荐</p><p>​eventTarget.addEventListener(type, listener[, useCapture])</p><p><span class="red">特点</span>：同一个元素同一个事件只能注册多个监听器，按照注册顺序依次执行。</p><h4>2. 删除事件（解绑事件）</h4><p>注意：解绑事件需要写在function里的最后，这样才能保证先执行一次处理程序再解绑。</p><p>【传统的注册方式的解绑】：</p><p>​ var btn &#x3D; document.getElementById(‘btn’);</p><p>​ btn.onclick &#x3D; function() {</p><p>​alert(‘hhhhh’)；</p><p>​btn.onclick &#x3D; null;}</p><p>【<span class="red">方法监听注册方式的绑定与解绑</span>】：</p><p>​btn.addEventListener(‘click’, fn);</p><p>​function fn() {</p><p>​alert(‘hhhhh’);</p><p>​btn.removeEventListener(‘click’, fn)};</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js节点操作</title>
    <link href="/2023/05/23/js%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/05/23/js%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2>js节点操作</h2><p>利用DOM树可以把节点划分为不同的层级关系。</p><ol><li><p>父级节点</p><p>node.parentNode  这个属性返回node节点最近的一个父节点</p></li><li><p>子节点</p><p>node.childNode 返回指定节点的<span class="red">所有</span>子节点的集合</p><p>!注意：包括文本节点甚至空格等都会被一起返回， 若只想获得子元素节点就别用了</p></li></ol><p>​2.1  <i class="fa-sharp fa-light fa-sparkles"></i><span class="red">更推荐的方法</span></p><p>​<span class="red">node.children</span>只读属性，只返回所有子元素节点。</p><p>​2.2 返回某个特定的子节点</p><p>​node.firstChild（Child是包含所有节点，文字等）</p><p>​node.lastChild</p><p>​node.firstElementChild（真正的子节点）</p><p>​node.lastElementChild</p><ol start="3"><li><p>兄弟节点</p><p>node.nextSibling</p><p>node.previousSibling</p><p>node.nextElementSibling</p><p>node.previousElementSibling</p></li><li><p>节点的<span class="red">创建</span></p></li></ol><p>​document.createElement(‘tagName’)根据需求动态创建元素节点，但是创建了还不会显示，还需要<span class="red">添加</span></p><ol start="5"><li><p>节点的添加</p><p>node.appendChild(child)将一个节点添加到指定父节点的子节点列表末尾。<span class="blue">类似css中的after伪元素</span></p><p>node.insertChild(child)将一个节点添加到指定父节点的子节点前面。<span class="blue">类似css中的before伪元素</span></p></li><li><p>节点的删除</p><p>node.removeChild()返回删除节点</p></li><li><p>节点的赋值</p><p>node.cloneNode()返回节点的副本 - 若无参数就是浅拷贝，不克隆里面的子节点；若参数为true，则是深度拷贝，会复制节点本身以及里面所有的节点。</p></li></ol><head>    <style>        .red {            color: red;}        .blue {            color: blue;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件基础</title>
    <link href="/2023/05/23/js%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/23/js%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2>js事件基础</h2><h4>1. 事件概述</h4><p>​js使我们有能力创造动态页面，其中，<span class="red">事件</span>是可以被js侦测到的行为。</p><h4>2. 事件三要素</h4><ul><li>事件源：谁被触发  e.g.按钮</li><li>事件类型： 怎么触发  e.g.点击触发</li><li>事件处理程序：通过函数赋值的方式  e.g.弹出对话框</li></ul><h4>3. 执行事件的步骤</h4><ol><li>获取事件源</li><li>注册（绑定事件）</li><li>添加事件处理程序（函数赋值）</li></ol><h4>4. 常见的鼠标事件</h4><p><img src="/img/mouseevent.jpg" alt="常见的鼠标事件"></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-DOM</title>
    <link href="/2023/05/17/js-DOM/"/>
    <url>/2023/05/17/js-DOM/</url>
    
    <content type="html"><![CDATA[<h2>DOM</h2><h4>1. DOM的定义</h4><p>DOM：document object model文档对象模型，是W3C组织推荐的处理可扩展标记语言的标准编程接口，通过这些接口可以改变网页的内容、结构和样式。</p><h4>2. DOM树</h4><p><img src="/img/DOMTree.jpg" alt="DOM树结构"></p><ul><li>文档：一个页面就是一个文档，DOM中用document表示</li><li>元素：页面中所有的标签都是元素，DOM中用element表示</li><li>节点：页面中所有的内容都是节点，DOM中用node表示</li></ul><p>DOM把以上所有看作为<span class="red">对象</span>，所以叫做文档对象模型</p><h4>3. DOM是如何获取元素的？</h4><ul><li><p>根据id获取：<strong>document.getElementById(‘id’)</strong></p><p>若匹配到则返回<span class="pink">Element对象</span>，没找到返回null</p></li><li><p>根据标签名获取：<strong>document.getElementByTagName(‘标签名’)</strong></p><p>获取来的（不管是多个还是一个还是没有）都以<span class="pink">伪数组</span>的形式进行存储。</p></li><li><p>通过类型获取:<strong>document.getElementByClassName(‘类名’)</strong></p></li><li><p>通过<span class="red">选择器</span>选择（单）：<strong>document.querySelector(‘选择器’)</strong></p></li></ul><p>​会根据指定选择器返回<span class="red">第一个</span>元素对象</p><ul><li><p>通过<span class="red">选择器</span>选择（复数）：<strong>document.querySelectorAll(‘选择器’)</strong></p></li><li><p>两个特殊的元素(body, html)的获取方式</p><p>document.body, document.documentElement</p></li></ul><head>    <style>        .red {            color: red;}        .pink {            color: pink;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js简单数据类型和复杂数据类型</title>
    <link href="/2023/05/17/js%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/05/17/js%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2>JS简单数据类型和复杂数据类型</h2><h4>简单数据类型 - </h4><p>简单数据类型，又称<span class="red">值类型</span>，因为在存储时变量中存储的是值本身。</p><p>存在<span class="pink">栈</span>中</p><p>e.g. string, number, boolean, undefined, null等</p><h4>复杂数据类型</h4><p>复杂数据类型，又称<span class="red">引用类型</span>，因为在存储时变量中存储的是<strong>地址</strong></p><p>存在<span class="pink">堆</span>中</p><p>e.g. Object, Array,Date等</p><head>    <style>        .red {            color: red;}        .pink {            color: pink;        }        </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js对象</title>
    <link href="/2023/05/17/js%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/17/js%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>js中的对象数据结构</h2><ul><li><p>为什么需要对象？</p><p>保存一个值，我可以选择用变量来存<br></p><p>保存多个值，我可以选择用数组来存<br></p><p>那么如果我想存储一个人的完整信息，那么我就需要<span class="red">对象</span>啦~</p></li><li><p>对象的组成：属性 + 方法</p></li><li><p>如何创建一个对象呢？</p><ol><li>利用<span class="red">字面量</span>来进行创建 : 键值对<br></li></ol><p>   e.g. var star &#x3D; {</p><p>   ​name: xxx, <br></p><p>   ​age: 18,<br></p><p>   ​sayHi: function() {<br></p><p>   ​alert(‘Hi’)</p><p>   }}</p><p>   调用方式：star.name，star.sayHi()</p><ol start="2"><li><p>利用<span class="red">new Object</span>来创建：<br></p><p>var lxy &#x3D; new Object();<br></p><p>lxy.name &#x3D; ‘Noelle’;<br></p><p>lxy.sayHi &#x3D; function() {<br></p><p>​alert(‘Hi’)</p></li><li><p>利用<span class="red">构造函数</span>来创建：<br></p><p>[<u>好处</u>:  上述使用字面量和原生的Object构造函数一次只能创建一个对象。但是利用自定义构造函数封装公共的属性和方法，可以一次创建多个不同的对象！！！<i class="fa-solid fa-award"></i>]<br></p><p>function Person(name, age) {&#x2F;&#x2F;抽象公共部分，泛指一个类class<br></p><p>​this.name &#x3D; name;<br></p><p>​this.age &#x3D; age;<br></p><p>​this.sayHi &#x3D; function() {<br></p><p>​alert(‘Hi’)}</p><p>}</p><p>var lxy &#x3D; <span class="red">new </span> Person(‘Noelle’, 18);&#x2F;&#x2F;<span class="red">对象实例化</span></p></li><li><p><i class="fa-solid fa-trumpet"></i><span class="red"><strong>new关键字执行时做了什么？</strong></span></p><ul><li>首先，在内存中创建一个新的空对象；</li><li>其次，让<span class="red">this</span>指向这个新的空对象；</li><li>接着，执行构造函数里的代码，给新的空对象添加属性和方法；</li><li>最后，返回这个新对象（<i class="fa-solid fa-exclamation"></i>new就做了，不需要一般函数return了！）</li></ul></li><li><p>如何遍历一个对象里的所有属性？</p><p>for (var att in obj) {</p><p>xxx}</p></li><li><p>常用的的JavaScript中的内置对象和内置构造函数：Math, Date, Array, String<br></p><p>其中Math<strong>是内置对象，并不是构造函数</strong>，因为它不需要new进行调用，可以直接使用，不要被大写迷惑咯~</p><hr></hr><p>6.1 Math(内置对象)</p><ul><li>Math.floor()  向下取整</li><li>Math.ceil()向上取整</li><li>Math.round()四舍五入取整</li><li>Math.abs()绝对值</li></ul><hr></hr><p>6.2 Date（内置构造函数）</p><ul><li><p>new Date()  如果括号里有参数比如’2023&#x2F;5&#x2F;17’就返回括号里的时间；若没有参数就反正当前时间</p></li><li><p>日期格式化可用的方法：</p><p>a. getFullYear()</p><p>b. getMonth()  记得＋1！！！！！！！</p><p>c. getDate()</p><p>d. getDay()</p><p>e. getHours()</p><p>f. getMinutes()</p><p>g. getSeconds()</p></li></ul><hr></hr><p>6.3 Array (内置构造函数)</p><p>indexOf可以查找一个给定元素的第一个索引</p><hr></hr><p>6.4 String(内置构造函数)</p><p>注意!!!!字符串所有的方法都不会修改字符串本身，操作完成返回一个新的字符串而已，所以<strong>避免大量的字符串拼接</strong></p><ul><li>charAt()返回指定位置的字符</li><li>substr(start, length) 返回从start开始，长度为length的子字符串f</li><li>slice(start, end)返回[start,end)的子字符串</li><li><i class="fa-solid fa-exclamation"></i>split()将字符串切分为<strong>数组</strong>并返回</li></ul></li></ol></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js预解析</title>
    <link href="/2023/05/17/js%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/05/17/js%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2>Js预解析</h2><h4>1. 预解析的背景</h4><p>JavaScript代码是由浏览器中的javaScript解析器来执行的，但是分为两步：预解析 + 代码执行。</p><h4>2. 预解析做了什么？</h4><p>预解析阶段，js引擎会把js文件里所有的<span class="red">var变量声明</span>和<span class="red">function函数声明</span><u>提升到当前作用域的最前面</u>。</p><h4>3. 例子</h4><p>console.log(num);</p><p>var num &#x3D; 10;</p><hr></hr><p>上述代码的输出结果是undefined！！为什么不报错嘞！！就是预解析啦，相当于以下代码</p><hr></hr><p>var num; &#x2F;&#x2F; 变量提升！</p><p>console.log(num); &#x2F;&#x2F;打印一个声明但未赋值的变量就是undefined啦~</p><p>num &#x3D; 10；</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js初识</title>
    <link href="/2023/05/17/js%E5%88%9D%E8%AF%86/"/>
    <url>/2023/05/17/js%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2>JS基础</h2><ul><li><p>计算机语言：机器语言，汇编语言，高级语言</p><p>机器语言和汇编语言都是直接对硬件操作，但汇编语言采用英文缩写的标识符</p></li><li><p>编程语言：汇编语言 + 高级语言</p><p>编程语言 ( e.g. JavaScript) v.s. 标记语言( e.g. HTML):</p><ul><li>标记语言：不向计算机发出指令，是用来被读取的</li><li>编程语言：具有很强的逻辑和行为能力，是主动的。</li></ul></li><li><p>JavaScript是什么？</p><p>JavaScript是一种运行在客户端的脚本语言（<i class="fa-solid fa-pen-to-square"></i>脚本语言不需要编译，由js引擎逐行解释并执行）</p></li><li><p>浏览器如何执行我的js代码？</p><p>浏览器引擎 &#x3D; 渲染引擎( e.g. Chrome’s blink&#x2F;webkit) + js引擎( e.g. Chrome’s v8)</p></li><li><p>JavaScript的组成部分：ECMAScript + DOM + BOM</p><p><img src="/img/js.png" alt="js组成"></p><ul><li>ECMAScript: 由ECMA国际规定JS编程语法和基础核心，是所有浏览器厂商共同遵守的一套<span class="red">js语法准则</span>。</li><li>DOM: Document Object Model, 文档对象模型：通过DOM提供的接口对页面上的元素进行操作。</li><li>BOM: Browser Object Model, 浏览器对象模型：通过BOM提供的接口可以操作浏览器窗口。</li></ul></li></ul><p>​</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架1-Bootstrap</title>
    <link href="/2023/05/16/%E6%A1%86%E6%9E%B61-Bootstrap/"/>
    <url>/2023/05/16/%E6%A1%86%E6%9E%B61-Bootstrap/</url>
    
    <content type="html"><![CDATA[<h2>Bootstrap-v4使用随想</h2><p>中文文档网址：<a href="https://v4.bootcss.com/docs/getting-started/introduction/">https://v4.bootcss.com/docs/getting-started/introduction/</a></p><p>Bootstrap是由推特（Twitter）开源的一款HTML、CSS和JS框架，<strong>它主要用来开发响应式布局、移动设备优先的WEB项目</strong>。</p><ul><li><strong>step1：在所有的css样式之前引入bootstrap的css文件</strong></li></ul><ul><li><strong>step2:  在页面底部引入bootstrap的script标签</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Less</title>
    <link href="/2023/05/16/Less/"/>
    <url>/2023/05/16/Less/</url>
    
    <content type="html"><![CDATA[<h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><h4>CSS的弊端</h4><ul>    <li>CSS冗余度很高</li>    <li>不利于复用代码</li>    <li>CSS没有很好的计算能力</li></ul><h4>Less(Leaner Style Sheets)</h4><p>Less是一门<span class="red">CSS扩展语言</span>，也称为<span class="red">CSS</span>预处理器，在现有的CSS语法的基础上，加入<strong>程序式</strong>语言的特性。最大的特点就是引入了变量、函数等功能，用最少的代码做更多的事情。</p><h3>1. Less变量</h3><p>e.g. @color: pink; <br></p><p>​body {</p><p>​background-color: @color; }</p><h3>2. Less编译</h3><p><u>Easy LESS</u>插件可以使保存的less文件自动生成css文件</p><h3>3. Less嵌套</h3><p>在css选择器中的子代选择器be like: .header logo{}， 但是在less中，子元素的样式需要嵌套在父元素的样式中书写。e.g. .header{logo {}}</p><h3>4. Less实现伪类选择器</h3><p>在Less中，有<span class="red"><strong>&amp;</strong></span>符号，会被解析成<u>父元素本身</u>或者<u>父元素的伪类</u></p><p>e.g. 在css中，a:hover {}; 在Less中，a{&amp;hover{}}</p><h3>5. Less算数运算</h3><p><i class="fa-regular fa-face-smile-plus"></i>在Less中，任何数字、颜色或者变量都可以参与算数运算</p><p>[ 注：若两个不同单位的值进行算数运算， 运算结果取第一个值的单位。e.g. 10px + 5rem &#x3D; 15px;<br></p><p>若只有一个值有单位，则运算结果取该单位。e.g. 10px + 5 &#x3D; 15px]</p><head>    <style>    .red {        color: red;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Less</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端常见布局</title>
    <link href="/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/"/>
    <url>/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h4>1. 流式布局</h4><p>流式布局，也叫百分比布局，也叫非固定像素布局，是通过<strong>盒子的宽度百分比</strong>来进行伸缩，而不选用固定的像素作为大小的单位。</p><h4>2. flex布局<i class="fa-solid fa-star"></i></h4><p>原理：为<u>父盒子指定flex属性</u>后称为<span class="red">容器</span>，所有子元素会自动成为<span class="red">容器成员</span>，通过特定的规则进行排列</p><p>2.1 flex布局容器常见属性</p><ul>    <li>display: flex<br>               将父盒子指定flex属性</li>    <li>flex-direction: row(默认) / row-reverse / column / column-reverse<br>            设置<strong>主轴</strong>的方向</li>    <li>justify-content: flex-start(默认) / flex-end / center / space-around / space-between<br>            设置元素在主轴上的排列方式<br>            [<span class="red">注</span>：space-around是均分剩余空间；space-between是先两边贴边再平分]</li>    <li>flex-wrap: no-wrap(默认) / wrap<br>            是否换行</li>    <li>align-items: flex-start / flex-end/ center / stretch(默认)<br>            设置<strong>侧轴</strong>上元素排列方式</li></ul><p>2.2 flex布局容器成员常见属性</p><ul>         <li>flex: 数字(默认为0)<br>               指定子元素所占的份数</li>        <li>order:数字(默认为0)            定义子元素的排列顺序，数值越小越靠前</li>     </ul><h4>3. rem适配布局</h4><p>3.1 rem（root em）单位：是一个<span class="red">相对单位</span></p><p>​[<i class="fa-solid fa-book"></i>review:  em是指父元素字体大小]</p><p>​rem的基准是相对于<span class="red">html元素字体大小</span></p><p>3.2 <i class="fa-light fa-message-smile"></i>rem的优势： 父元素字体大小可能不一致，但html可以很好的控制页面元素大小。</p><p>3.3 rem布局常和<span class="pink">媒体查询</span>一起使用</p><p>​先通过媒体查询(media query)控制html文字大小， 再通过rem单位进行动态的变化，代码如下图。</p><p><img src="/img/remMediaquery.jpg" alt="Code of rem with media query"></p><head>    <style>        .red {            color: red;}        .pink {            color: pink;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline4-DeepConvLSTMimp</title>
    <link href="/2023/05/16/baseline4-DeepConvLSTMimp/"/>
    <url>/2023/05/16/baseline4-DeepConvLSTMimp/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTMimp"><a href="#DeepConvLSTMimp" class="headerlink" title="DeepConvLSTMimp"></a>DeepConvLSTMimp</h2><p>*模型出处：Improving Deep Learning for HAR with shallow LSTMs 2021</p><h3>模型结构</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i> Opportunity</i></p></li><li><p><i>Wetlab</i></p></li><li><p><i>RealWorld (HAR)</i></p></li><li><p><i>SBHAR</i></p></li><li><p><i>HHAR.</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvLSTM</p><p>在多个数据集上对比了DeepConvLSTM和作者提出的单隐层的DeepConvLSTMimp网络，并且在单隐层的情况下，横向对比了隐藏单元的个数(128，256，512，1024）对结果的影响。</p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: 1e-4</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>网络结构上一咪咪的改动只要足够多的对比工作也行啦~</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p>*不放了…就在把DeepConvLSTM中间的lstm2删了<i class="fa-solid fa-face-grin-squint-tears"></i></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTMimp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline2-EEGNet</title>
    <link href="/2023/05/16/baseline2-EEGNet/"/>
    <url>/2023/05/16/baseline2-EEGNet/</url>
    
    <content type="html"><![CDATA[<h2 id="EEGNet"><a href="#EEGNet" class="headerlink" title="EEGNet"></a>EEGNet</h2><p>*模型出处：EEGNet: A Compact Convolutional Network for EEG-based Brain-Computer Interfaces 2018</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="/img/EEGNet.png" alt="Model"></p><p><img src="/img/EEGNetspecific.png" alt="Details"></p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><img src="/img/EEGNetdataset.png" alt="Dataset"></p><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvNet, ShallowConvNet </p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: not mentioned</li>    <li>epochs: 500</li>    <li>dropout: 0.5forCS / 0.25forSI</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p>在被试独立和被试交叉的情况下，四种范式上均有提升。</p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>出发点: 想要提出一种适合各种BCI范式的通用的网络，并且希望这个通用网络十分紧凑（参数数量少）。</li>    <li>亮点1：将深度卷积和可分离卷积运用到脑电数据上<br>        (1)可分离卷积在这里是指将完整的卷积运算分解为深度卷积+逐点卷积        (2)逐点卷积的作用：学习如何将特征图做优化的结合</li>    <li>亮点2：对被试交叉和被试独立的数据划分情况都做了相应的讨论</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/EEGNetCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EEGNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline3-DeepConvLSTM</title>
    <link href="/2023/05/15/baseline3-DeepConvLSTM/"/>
    <url>/2023/05/15/baseline3-DeepConvLSTM/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTM"><a href="#DeepConvLSTM" class="headerlink" title="DeepConvLSTM"></a>DeepConvLSTM</h2><p>*模型出处：Deep Convolutional and LSTM Recurrent Neural Networks for Multimodal Wearable Activity Recognition 2016</p><h3>模型结构</h3><p><img src="/img/DeepConvLSTM.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>OPPORTUNITY</i></p></li><li><p><i>Skoda</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：不带lstm的CNN（<i class="fa-light fa-thumbs-down"></i>这不就是纯纯消融实验吗？？</p><p>实验控制baseline-CNN和DeepConvLSTM前面的卷积模块和最后的分类模块完全相同，基线CNN的两个dense层是非循环且全连接的；DeepConvLSTM的两个dense层的cell是LSTM cell。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: 10e-3</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMres1.png" alt="ResultinDataset1"></p><p><img src="/img/DeepConvLSTMres2.png" alt="ResultinDataset2"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是考虑到HAR问题的时序性，添加LSTM模</li>    <li>文中提到在他们的实验中使用RMSProp优化器效果更好</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvLSTMCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline1-DeepConv</title>
    <link href="/2023/05/15/baseline1-DeepConv/"/>
    <url>/2023/05/15/baseline1-DeepConv/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConv"><a href="#DeepConv" class="headerlink" title="DeepConv"></a>DeepConv</h2><p>*模型出处：Deep learning with convolutional neural networks for EEG decoding and visualization 2017</p><h3>模型结构</h3><p><img src="/img/DeepConv.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>BCI competition IV dataset 2a</i><span>（ 288 trials per subject）</span></p></li><li><p>自采数据集（880 trials per subject）</p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：FBCSP</p><p>设计了两层的shallowConvNet和五层的DeepConvNet甚至最高到31层的ResNet以及深浅结合的网络。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: not mentioned</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p><img src="/img/DeepConvRes.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是围绕着如何将在图像领域的深度卷积网络运用在脑电数据上。<br>        首先，作者提出了脑电和图像的区别：图像是二维静态的，而脑电数据是在<strong>三维的头皮上获取的时序数据        </strong><br>        接着，作者还提出了，脑电数据相比于图像数据数量太少，需要进行裁剪，也就是分段，作者用的2s一段。        </li>    <li>作者提出的DeepConv网络的Block1是专门为了提取脑电数据信息的：时间维度拼接空间维度</li>    <li>作者通过尝试对神经网络进行解释，得出结论：卷积网络学习了不同频段信息。<br>        <i class="fa-solid fa-hand-sparkles"></i>我可以试着把数据先进行小波包分解再送进网络进行学习</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvCode.png" alt="myCode"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精灵图</title>
    <link href="/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/"/>
    <url>/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h2><h3 id="精灵图的背景"><a href="#精灵图的背景" class="headerlink" title="精灵图的背景"></a>精灵图的背景</h3><p>一个网页中会需要很多小的背景图作为装饰，但是如果图像过多时，服务器频繁的接收和发送请求会使得服务器压力过大，降低加载速度。</p><p><i class="fa-sharp fa-light fa-truck-fast" style="color: #a4d5f4;"></i>为了<span class="red">有效减少服务器接收和发送请求的次数，提高网页的加载速度</span>， 出现了CSS精灵技术</p><h3 id="精灵图的核心原理"><a href="#精灵图的核心原理" class="headerlink" title="精灵图的核心原理"></a>精灵图的核心原理</h3><p>将一堆小的背景图像整合到一张大图 (精灵图sprites) 上，服务器只需要请求一次就可以了~</p><h3 id="精灵图的使用"><a href="#精灵图的使用" class="headerlink" title="精灵图的使用"></a>精灵图的使用</h3><p>移动背景图片的位置，调整<strong>background-position</strong>属性值</p><p>[注：属性值是调整x和y坐标的距离，但是网页的坐标是以左到右为x正方向，上到下为y正方向，所以一般我们都向上向左调整精灵图的位置，数值为<span class="red">负值</span>。]</p><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>sprites</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之三： 定位</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2>定位</h2><p>[Review: 浮动可以让多个块级盒子在一行没有缝隙的排列显示，常用于横向排列盒子。]</p><p>终于轮到定位啦！！</p><ol><li><p>定位的目的： 让盒子自由的在某个盒子内移动位置或者固定位置， 并且可以<span class="red">压住</span>其他盒子</p></li><li><p>定位模式： 也就是position属性可能的属性值： 静态定位static、相对定位relative、绝对定位absolute、固定定位fixed</p><p>2.1 静态定位static（position属性的默认值）：无定位，可以按照标准流来看待</p><p>2.2 相对定位relative：元素在移动位置的时候，相对<u>它本身原来的位置</u>来移动的。</p><p>[<i class="fa-solid fa-flag"></i>注意]原来位置还在，相对定位并<span class="red">没有脱离标准流</span>，后面的盒子仍然以标准流的方式看它。</p><p>2.3 绝对定位absolute：元素在移动的时候，是根据他的<u>祖先元素</u>来移动的</p><p>[<i class="fa-solid fa-flag"></i>注意] 绝对定位是<span class="red">脱标</span>的！</p><p>2.4 固定定位fixed：元素固定在浏览器<u>可视区</u>的某一位置。</p><p>[<i class="fa-solid fa-flag"></i>注意] 固定定位也是脱离标准流的，不占有原来的位置。</p></li><li><p><i class="fa-solid fa-stars"></i>一个非常经典的组合：<span class="red"><strong>子绝父相</strong></span>、子绝父绝</p><p>原因：子级绝对定位不会占有位置，可以放到父盒子里任一个位置，不影响其他兄弟。而父盒子相对定位并没有脱离标准流会限制子盒子。如果父盒子也不需要占位置的话，子绝父绝也是可以滴~</p></li><li><p>绝对定位或者固定定位水平居中：在标准流中，我们可以通过margin: 0 auto；来设置元素水平居中，但是脱离标准流的时候就要{left: 50%; margin-left: -（自身宽度的一半); }</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>position</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之二：浮动</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2>浮动</h2><p>这篇来复盘一下布局三大哥中的二哥： 浮动。</p><ol><li><p>传统页面布局的三种方式： 标准流、<span class="red">浮动</span>、定位。</p></li><li><p>浮动和标准流的差别：</p><ul>    <li>标准流：按照规定好的默认方式排列元素</li>    <li>浮动float：脱离标准流，按自己的规则排列</li></ul></li><li><p>浮动的特性：</p><ul>    <li>脱离标准流，以至于不再保留盒子原来的位置</li>    <li>任何元素都可以进行浮动，且浮动后会具有行内块元素相似的特性，建议如果一个元素浮动，其他的兄弟元素也一起浮动</li>    <li>浮动的元素常和标准流的父级搭配使用</li></ul></li><li><p><i class="fa-solid fa-car-on"></i>浮动可能会带来的问题： 如果父盒子在一些情况下不方便直接给高度，但是子盒子浮动是不占位置的，无法撑开盒子，父盒子的高度为0，会影响后面的标准流盒子。</p></li><li><p>清除浮动：clear: both 清除左右两侧浮动影响</p><p>清除浮动后，父级会根据子盒子自动调整高度，就可以解决上述问题了。</p></li><li><p>具体方法：</p><ol>    <li>额外标签法：在浮动的元素末尾添加一个空标签</li>    <li>父元素添加overflow: hidden属性</li>    <li>:after伪元素法：给父元素添加after伪元素并clear</li>    <li>双伪元素清除浮动：在3的基础上再添加一个:before</li></ol></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之一：盒子模型</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2>盒子模型</h2><p>最近准备找前端实习和工作啦，就在博客上总结一下布局的三大核心：盒子模型，浮动和定位。剩下两个也有单独的讲解~</p><ol><li><p>页面布局的<strong>本质</strong>：利用CSS设置好盒子样式，摆放到相应的位置。（听起来好像很简单，坑很多）</p></li><li><p>盒子模型的组成：把HTML布局元素看成一个矩形的盒子，封装周围的元素，包括：边框border、内边距padding、外边距margin和实际内容content</p><p>2.1 边框border注意:</p> <ul><p>​  <li>复合型写法  border: 1px solid black;</li></p><p>​  <li>细线边框属性：border-collapse: collapse;</li></p><p>​  <li>如果是<strong>border-box</strong>，边框会影响盒子的实际大小，需要减去对应的宽高</p>  </ul><p>2.2 内边距padding注意：</p><ul><p>​  <li>如果padding属性有一个值，代表上下左右的padding都一样；两个值代表上下，左右；三个值代表上，左右，下；四个值代表上，右，下，左</li></p><p>​  <li>如果是<strong>border-box</strong>，padding也会撑大盒子，同理，需要减去对应的宽高</p>  </ul><p>2.3 外边距margin注意：</p><ul><p>​  <li>前两条和padding一样，见2.2</li></p><p>​  <li><i class="fa-solid fa-seal-exclamation"></i><span class="red">外边距的合并</span>会有新的问题：</br></p><p>​(1). <i class="fa-regular fa-triangle-exclamation"></i><strong>相邻</strong>元素垂直外边距合并: 并非相加，而是取大的那个</br></p><p>​(2). <i class="fa-regular fa-star-exclamation"></i><strong>嵌套</strong>元素垂直外边距合并会引起塌陷问题：父元素会塌陷较大的外边距值</li></p>  </ul></li><li><p>圆角边框：border-radius</p><p>注意复合写法的时候顺序是top-left，top-right，bottom-right, bottom-left。</p></li><li><p>盒子阴影：box-shadow</p><p>box-shadow: h-shadow v-shadow blur spread color inset;</p><p>(注：盒子阴影并不占用空间，不会影响其他盒子的排列)</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>box-model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在md文档中引入icon</title>
    <link href="/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/"/>
    <url>/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/</url>
    
    <content type="html"><![CDATA[<h2 id="尝试如何在markdown文档中引入可爱的icon图标"><a href="#尝试如何在markdown文档中引入可爱的icon图标" class="headerlink" title="尝试如何在markdown文档中引入可爱的icon图标"></a>尝试如何在markdown文档中引入可爱的icon图标</h2><p>最近写自己的技术博客的时候，在一些地方很想插入一些可爱的图标，就想着用之前做项目的时候使用的Font Awesome图标库引入文档，由此插入其中的icon。下面是官方的地址：</p><p><i><a href="https://fontawesome.com/">https://fontawesome.com/</a></i></p><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><h5><i class="fa-solid fa-baby"></i>step1: 引入Font Awesome的js文件<img src="/img/Font-Awesome.png"/></h5><p>   （注：位置要放在head标签内）</li></p><h5><i class="fa-solid fa-person-rays"></i>step2: 在icon界面找到想要的图标，复制类名到自己的想加的地方</h5><p>   （注：拿i标签包裹一下）</li></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head><ul]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS层叠时的优先级问题</title>
    <link href="/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2>CSS层叠时的优先级问题</h2><p>今天在写样式的时候发现一个样式怎么也不显示，找了一圈发现是样式冲突了，css会优先执行优先级更高的样式。特意复习一下css中的优先级好啦~</p><h3>下面的选择器权重从小到大</h3><p>(ps: 也就是越往下越会优先执行）</p><ul>    <li>继承 或者通配符选择器*</li>    <li>元素选择器  e.g. p {}</li>    <li>类选择器，伪类选择器  e.g.  .para{}  .nav:hover{}</li>    <li>ID选择器  e.g.  #customid {}</li>    <li>行内样式 style=""</li>    <li>在属性值后面加!important</li></ul></ul><p><strong>在使用复合选择器的时候，要注意权重的叠加计算</strong></p>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css文字对齐</title>
    <link href="/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="css文字对齐包括水平对齐和垂直对齐"><a href="#css文字对齐包括水平对齐和垂直对齐" class="headerlink" title="css文字对齐包括水平对齐和垂直对齐"></a>css文字对齐包括水平对齐和垂直对齐</h2><ol><li><p>水平对齐  <strong>text-align</strong></p><p>text-align属性默认值是left，也就是靠左侧对齐文字，如果想水平方向居中显示，则需要对元素的样式设置text-align: center</p></li><li><p>垂直对齐  <strong>line-height &#x3D; height</strong></p><p>在css中没有相对应的属性可以设置文字垂直居中，但是一个小trick就是使这一行文字的line-height等于设置的盒子高度height。</p><p>解释：因为line-height行高除了内容本身的高度以外还有上间距和下间距，可以看下面的图配合食用~</p><p>配图说明：<img title="line-height组成" src="/img/lineheight.jpg"/></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2023/05/12/my-first-blog/"/>
    <url>/2023/05/12/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>##This is my first blog and try it here!!</p>]]></content>
    
    
    
    <tags>
      
      <tag>try</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
