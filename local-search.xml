<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>确定元素位置总结</title>
    <link href="/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2023/06/05/%E7%A1%AE%E5%AE%9A%E5%85%83%E7%B4%A0%E4%BD%8D%E7%BD%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h4>offsetX</h4><p>偏移量offsetX - 相对offsetParent偏移了多少？</p><p>注意offsetParent是指带有定位的父级节点</p><p>offsetWidth和offsetHeight指包含border，padding，content的宽高。</p><h4>scrollX</h4><p>滚动量scrollX - 文档相对于当前浏览器视口滚动了多少？</p><h4>clientX</h4><p>这个属性描述自身位置。</p><p>clientTop就是border-top的值，clientWidth不包含border</p><p>Reference: <a href="https://blog.csdn.net/lefex/article/details/104682178">(68条消息) 彻底搞懂 offsetX、scrollX、clientX 的区别_lefex的博客-CSDN博客</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC端网页特效</title>
    <link href="/2023/06/05/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/"/>
    <url>/2023/06/05/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/</url>
    
    <content type="html"><![CDATA[<h2>元素偏移量offset系列</h2><h4>1. offset偏移量概述</h4><p>使用offset系列相关属性可以<span class="red">动态的</span>得到该元素的位置（偏移）、大小等。</p><h4>2. offset系列常用属性</h4><ul><li>element.offsetParent: 返回作为该元素带有定位的父级元素</li><li>element.offsetTop: 返回元素相对带有定位的父元素上方的偏移</li><li>element.offsetLeft: 同上，但是左边框的偏移</li><li>element.offsetWidth: 返回自身包括padding，边框，内容区的宽度，且不带单位</li></ul><h4>3. offset v.s. style</h4><p><img src="/img/offsetvsstyle.jpg" alt="offset v.s. style"></p><hr><h2>元素可视区client系列</h2><h4>1. client概述</h4><p>client本身是客户端的意思，使用client系列相关属性可以获取<u>元素可视区</u>的相关信息, 动态的得到该元素边框大小，元素大小等。</p><h4>2. client系列属性</h4><ul><li>element.clientTop: 返回元素上边框的大小</li><li>element.clientLeft: 返回元素左边框的大小</li><li>element.clientWidth: 返回元素自身包括padding，内容区的宽度，但是不包含边框（这是和offset最大的区别)</li></ul><hr><h2>元素滚动scroll系列</h2><h4>1. scroll系列属性</h4><ul><li>element.scrollTop: 返回被卷上去的距离</li><li>element.scrollLeft: 返回被卷去的左侧距离</li><li>element.scrollWidth: 返回自身实际宽度，不包含边框，返回数值不带单位</li></ul><h4>2. onscroll事件</h4><p>当浏览器的高或者宽度不足以显示整个页面的时候，会自动出现滚动条。滚动条在滚动时会触发onscroll事件。</p><hr><p>【这里总结一下以上三种的异同！！】</p><p><a href="">sum</a></p><hr><h2>动画函数封装</h2><p>通过setInterval（）不断移动盒子的位置就可以达到动画的效果。</p><h2><span class="red">节流阀</span></h2><p>目的：为了防止轮播图按钮连续点击造成播放太快</p><p>本质：当上一个函数动画内容执行完毕，再去执行下一个函数动画，让事件无法连续触发。</p><p><span class="red">核心实现思路</span>: 利用回调函数， 添加一个变量来控制，锁住和解锁函数。</p><p>伪代码：</p><p>​var flag&#x3D;true;&#x2F;&#x2F;默认水龙头开着</p><p>​if(flag) {</p><p>​flag &#x3D; false;</p><p>​        do something} &#x2F;&#x2F;为了确保无法连续触发， 关闭水龙头</p><p>​    callback，flag&#x3D;true；&#x2F;&#x2F;利用回调函数执行动画完毕后，打开水龙头</p><p>代码参考：</p><p><img src="/img/%E8%8A%82%E6%B5%81%E9%98%80%E4%BB%A3%E7%A0%81.png" alt="code"></p><p>Reference: <a href="https://blog.csdn.net/qq_36958206/article/details/109049938">(68条消息) JS的节流阀_前端节流阀_鹿小风的博客-CSDN博客</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BOM对象</title>
    <link href="/2023/06/05/BOM%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/05/BOM%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>Location对象</h2><h4>1. location对象的定义</h4><p>window对象给我们提供了一个location属性，用于<span class="red">获取或设置窗体的URL</span>，并且可以用于解析URL。因为这个属性返回的是一个对象，也称这个属性为location对象。</p><h4>2. URL: Uniform Resource Locator 统一资源定位符</h4><p>互联网上每个文件都有一个唯一的URL， 包含文件的位置以及浏览器应该如何处理等信息。</p><p><u>URL一般语法</u>： protocol:&#x2F;&#x2F;host[:port]&#x2F;path&#x2F;[?query]#fragment</p><h4>3. location对象的属性</h4><p><img src="/img/location.jpg" alt="location对象的属性"></p><hr><h2>Navigator对象</h2><p>navigator对象包含有关浏览器的信息，它有很多属性，最常用的是<span class="red">userAgent</span>, 该属性可以返回由客户机发送服务器的user-agent头部的值，用来判断用户在哪个终端打开页面。</p><hr><h2>History对象</h2><p>windows对象给我们提供了一个history对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的URL。</p><h4>history对象方法</h4><ul><li>back(): 后退</li><li>forward(): 前进</li><li>go(argument): 参数为正则前进argument个页面，负则后退。</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js执行队列</title>
    <link href="/2023/06/05/js%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/"/>
    <url>/2023/06/05/js%E6%89%A7%E8%A1%8C%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2>JS执行队列</h2><h4>1. JS是单线程</h4><p>JavaScript语言的一大特点就是<span class="red">单线程</span>，也就是同一个时间只能做一件事。这也就意味着所有任务需要排队，这就导致如果js执行的时间过长，会造成页面渲染不连贯，导致<span class="red">页面渲染加载阻塞</span>的感觉。</p><hr><p><i class="fa-solid fa-arrows-down-to-line" style="margin: 0 auto;"></i></p><hr><p>为了解决这个问题，利用多核cpu的计算能力，<span class="red">HTML5</span>允许JavaScript脚本创建多个线程，所以JS中出现了<span class="red">同步</span>和<span class="red">异步</span>。</p><h4>2. 同步</h4><p>前一个任务结束后再执行下一个任务，程序的执行顺序与任务的排队顺序一致。</p><h4>3. 异步</h4><p>在做一件事的同时还可以去处理其他事情。</p><h4>4. JS执行机制</h4><p>JS为了防止任务有排队等待时间过长的问题，把所有的任务分为两类。</p><ul><li><p>同步任务：都在主线程上执行，形成一个<span class="red">执行栈</span>。</p></li><li><p>异步任务：JS的异步是通过回调函数实现的，添加到<span class="red">任务队列（消息队列）</span>中。</p></li></ul><p>[<strong>JS执行机制</strong>]：先执行执行栈中的同步任务，异步任务（回调函数）放到任务队列中，一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，进行执行栈开始执行。</p><h4>5. 事件循环Event Loop</h4><p>由于主线程不断的重复获取任务，执行任务，再获取和执行任务，这种机制被称为<span class="red">事件循环</span></p><p><img src="/img/EventLoop.jpg" alt="Event Loop"> </p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-BOM</title>
    <link href="/2023/06/05/js-BOM/"/>
    <url>/2023/06/05/js-BOM/</url>
    
    <content type="html"><![CDATA[<h2>BOM</h2><h4>1. BOM的定义</h4><p>BOM ：Browser Object Model 浏览器对象模型</p><p>提供了独立于内容而与浏览器窗口进行交互的对象。BOM则由一系列相关的对象构成，并且每个对象提供了很多方法和属性。</p><p><verticalLine></verticalLine></p><p><img src="/img/DOMvsBOM.jpg" alt="DOM v.s. BOM"></p><h4>2. BOM的构成</h4><p>BOM： document，location, navigation, screen, history</p><p>[所以！！BOM包含了DOM]</p><h4>3. window对象的常见事件</h4><p>3.1 <strong>窗口加载事件</strong>：文档内容完全加载就会触发该事件，调用处理函数</p><p>window.onload &#x3D; function() {}&#x2F;&#x2F;传统方式注册</p><p>window.addEventListener(‘load’, function(){})&#x2F;&#x2F;方法监听方式注册</p><p>[好处]：有了window.onload就可以把js代码写到页面元素的上方，但是本质上还是等内容全部加载完毕再执行处理函数。</p><p>[ie9以上才支持的]：document.addEventListener(‘DOMContentLoaded’, function(){})，仅当DOM加载完成，就会触发执行函数。如果图片过多，onload触发需要较长的事件，DOMContentLoaded事件会比较合适。</p><p>3.2 <strong>调整窗口大小事件</strong>：常利用本事件完成响应式布局</p><p>window.onresize &#x3D; function() {}</p><p>window.addEventListener(‘resize’, function() {})</p><p>3.3 <strong>定时器</strong>：</p><ul><li><p>window.setTimeout(调用函数， [延迟毫秒数])：这是一个callback回调函数</p><p>var timer1 &#x3D; setTimeout(fn, 2000);</p><p>var timer2 &#x3D; setTimeout(fn, 5000);</p><hr><p>清除定时器的方式：window.clearTimeout(timeoutID)</p><p>e.g. 清除上面的timer1定时器</p><p>clearTimeout(timer1);</p></li><li><p>window.setInterval(回调函数，[间隔毫秒数]): 每隔一段时间就会反复调用</p><hr><p>清除定时器的方式：window.clearInterval(intervalID)</p></li></ul><p>3.4 <strong>this指向</strong>:</p><p>this的指向在函数定义的时候是确定不了的，只有在函数执行的时候才能确定this到底指向谁。一般this最终的指向的是调用它的对象。</p><ul><li>全局作用域下：this指向全局对象window</li><li>方法调用中：this指向调用的对象</li><li>构造函数中：this指向构造函数的实例</li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>BOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-DOM事件流</title>
    <link href="/2023/06/05/js-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/"/>
    <url>/2023/06/05/js-DOM%E4%BA%8B%E4%BB%B6%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<h2>DOM事件流</h2><h4>1. 事件流</h4><p>描述从页面中接收事件的顺序。</p><h4>2. DOM事件流</h4><p>事件发生时会在节点元素之间按照特定的顺序传播。此传播过程即为DOM事件流。</p><h4> 3. DOM事件流三阶段</h4><p><span class="red">捕获阶段</span>：从windows对象依次向下传播，到达目标节点。捕获阶段不会相应任何事件。</p><p><span class="red">当前目标阶段</span>：目标节点触发事件。</p><p><span class="red">冒泡阶段</span>：从当前节点依次向上传播，直到windows对象。</p><p><a href="/img/EventFlow.jpg">DOM事件流三阶段</a></p><h4><span class="red">4. 注意<span></h4><p>a. JS代码中只能执行捕获或者是冒泡其中的一个阶段</p><p>b. onclick只能得到冒泡阶段</p><p>c. addEventListener(type, listener[,useCapture])如果第三个参数不写默认false就是在冒泡阶段调用事件处理程序；若设置为true，则是在事件捕获阶段调用事件处理程序。</p><p>d. 但是在开发中，关注事件冒泡会更多。</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件对象</title>
    <link href="/2023/06/05/js%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/06/05/js%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>事件对象</h2><h4>1. 事件对象的定义与理解</h4><p>事件对象的官方定义：event事件对象代表事件的状态，比如按键的状态，鼠标的位置等等。</p><p><span class="red">理解</span>：当DOM树中某一个元素事件被触发的时候，会同时自动产生一个用来描述事件的所有相关信息的对象，这就是event（事件对象）。</p><h4>2. 事件对象的使用语法</h4><p>2.1 可以直接通过event来获取</p><p>2.2 可以通过函数传参数的方式获取： eventTarget.onclick &#x3D; function(<span class="red">e</span>) {…}</p><h4>3. 事件对象常见的属性和方法</h4>[事件对象常见的方法和属性](/img/event.jpg)<h4>4. 阻止事件冒泡</h4><p>利用事件对象中的stopPropagation（）方法！！</p><p>var son &#x3D; document.querySelector(‘.son’);</p><p>son.addEventListener(‘click’, function(e) {</p><p>​alert(‘son’);</p><p>​<span class="red">e.stopPropagation();</span>&#x2F;&#x2F;阻止事件冒泡，这样就不会弹出下面的father！！！</p><p>})</p><p>var father &#x3D; document.querySelector(‘.father’);</p><p>father.addEventListener(‘click’, function() {</p><p>​alert(‘father’)})</p><h4>5. 事件委托（委派、代理）</h4><p>问题引出：如果想给ul的每个小li都注册事件，访问DOM次数过多会演唱整个页面的交互就绪时间。</p><p><strong>事件委托原理：</strong>不是给每个子节点单独设置事件监听器，而是设置在父节点上，利用冒泡影响每个子节点。</p><p>var ul &#x3D; document.querySelector(‘ul’); &#x2F;&#x2F;只需要获取一次</p><p>ul.addEventListener(‘click’, function(e) {</p><p>​alert(‘hhhhh’)})</p><h4>6. 常见的鼠标事件以及事件对象</h4><p><a href="/img/mouseEvent.jpg">常见的鼠标事件</a></p><p><a href="/img/%E9%BC%A0%E6%A0%87%E5%AF%B9%E8%B1%A1%E4%BA%8B%E4%BB%B6.jpg">常见的鼠标事件对象</a></p><h4>7. 常见的键盘事件以及事件对象</h4><p><a href="/img/keyEvent.jpg">常见的键盘事件</a></p><p><a href="/img/%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.jpg">常见的键盘事件对象</a></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件高级</title>
    <link href="/2023/06/05/js%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/"/>
    <url>/2023/06/05/js%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<h2>js事件高级</h2><h4>1. 注册事件（绑定事件）</h4><p>【传统的注册方式】：</p><p>​        var btn &#x3D; document.getElementById(‘btn’);&#x2F;&#x2F;获取事件源</p><p>​btn.onclick &#x3D; function() {alert(‘hhhhh’)}&#x2F;&#x2F;事件类型+事件处理程序</p><p><span class="red">特点</span>：注册事件的唯一性（同一个元素同一个事件只能设置一个处理函数，最后注册的会覆盖前面注册的处理函数</p><p>【<span class="red">方法监听注册方式</span>】：W3C标准推荐</p><p>​eventTarget.addEventListener(type, listener[, useCapture])</p><p><span class="red">特点</span>：同一个元素同一个事件只能注册多个监听器，按照注册顺序依次执行。</p><h4>2. 删除事件（解绑事件）</h4><p>注意：解绑事件需要写在function里的最后，这样才能保证先执行一次处理程序再解绑。</p><p>【传统的注册方式的解绑】：</p><p>​ var btn &#x3D; document.getElementById(‘btn’);</p><p>​ btn.onclick &#x3D; function() {</p><p>​alert(‘hhhhh’)；</p><p>​btn.onclick &#x3D; null;}</p><p>【<span class="red">方法监听注册方式的绑定与解绑</span>】：</p><p>​btn.addEventListener(‘click’, fn);</p><p>​function fn() {</p><p>​alert(‘hhhhh’);</p><p>​btn.removeEventListener(‘click’, fn)};</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js节点操作</title>
    <link href="/2023/05/23/js%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/05/23/js%E8%8A%82%E7%82%B9%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2>js节点操作</h2><p>利用DOM树可以把节点划分为不同的层级关系。</p><ol><li><p>父级节点</p><p>node.parentNode  这个属性返回node节点最近的一个父节点</p></li><li><p>子节点</p><p>node.childNode 返回指定节点的<span class="red">所有</span>子节点的集合</p><p>!注意：包括文本节点甚至空格等都会被一起返回， 若只想获得子元素节点就别用了</p></li></ol><p>​2.1  <i class="fa-sharp fa-light fa-sparkles"></i><span class="red">更推荐的方法</span></p><p>​<span class="red">node.children</span>只读属性，只返回所有子元素节点。</p><p>​2.2 返回某个特定的子节点</p><p>​node.firstChild（Child是包含所有节点，文字等）</p><p>​node.lastChild</p><p>​node.firstElementChild（真正的子节点）</p><p>​node.lastElementChild</p><ol start="3"><li><p>兄弟节点</p><p>node.nextSibling</p><p>node.previousSibling</p><p>node.nextElementSibling</p><p>node.previousElementSibling</p></li><li><p>节点的<span class="red">创建</span></p></li></ol><p>​document.createElement(‘tagName’)根据需求动态创建元素节点，但是创建了还不会显示，还需要<span class="red">添加</span></p><ol start="5"><li><p>节点的添加</p><p>node.appendChild(child)将一个节点添加到指定父节点的子节点列表末尾。<span class="blue">类似css中的after伪元素</span></p><p>node.insertChild(child)将一个节点添加到指定父节点的子节点前面。<span class="blue">类似css中的before伪元素</span></p></li><li><p>节点的删除</p><p>node.removeChild()返回删除节点</p></li><li><p>节点的赋值</p><p>node.cloneNode()返回节点的副本 - 若无参数就是浅拷贝，不克隆里面的子节点；若参数为true，则是深度拷贝，会复制节点本身以及里面所有的节点。</p></li></ol><head>    <style>        .red {            color: red;}        .blue {            color: blue;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js事件基础</title>
    <link href="/2023/05/23/js%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/05/23/js%E4%BA%8B%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2>js事件基础</h2><h4>1. 事件概述</h4><p>​js使我们有能力创造动态页面，其中，<span class="red">事件</span>是可以被js侦测到的行为。</p><h4>2. 事件三要素</h4><ul><li>事件源：谁被触发  e.g.按钮</li><li>事件类型： 怎么触发  e.g.点击触发</li><li>事件处理程序：通过函数赋值的方式  e.g.弹出对话框</li></ul><h4>3. 执行事件的步骤</h4><ol><li>获取事件源</li><li>注册（绑定事件）</li><li>添加事件处理程序（函数赋值）</li></ol><h4>4. 常见的鼠标事件</h4><p><img src="/img/mouseevent.jpg" alt="常见的鼠标事件"></p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js-DOM</title>
    <link href="/2023/05/17/js-DOM/"/>
    <url>/2023/05/17/js-DOM/</url>
    
    <content type="html"><![CDATA[<h2>DOM</h2><h4>1. DOM的定义</h4><p>DOM：document object model文档对象模型，是W3C组织推荐的处理可扩展标记语言的标准编程接口，通过这些接口可以改变网页的内容、结构和样式。</p><h4>2. DOM树</h4><p><img src="/img/DOMTree.jpg" alt="DOM树结构"></p><ul><li>文档：一个页面就是一个文档，DOM中用document表示</li><li>元素：页面中所有的标签都是元素，DOM中用element表示</li><li>节点：页面中所有的内容都是节点，DOM中用node表示</li></ul><p>DOM把以上所有看作为<span class="red">对象</span>，所以叫做文档对象模型</p><h4>3. DOM是如何获取元素的？</h4><ul><li><p>根据id获取：<strong>document.getElementById(‘id’)</strong></p><p>若匹配到则返回<span class="pink">Element对象</span>，没找到返回null</p></li><li><p>根据标签名获取：<strong>document.getElementByTagName(‘标签名’)</strong></p><p>获取来的（不管是多个还是一个还是没有）都以<span class="pink">伪数组</span>的形式进行存储。</p></li><li><p>通过类型获取:<strong>document.getElementByClassName(‘类名’)</strong></p></li><li><p>通过<span class="red">选择器</span>选择（单）：<strong>document.querySelector(‘选择器’)</strong></p></li></ul><p>​会根据指定选择器返回<span class="red">第一个</span>元素对象</p><ul><li><p>通过<span class="red">选择器</span>选择（复数）：<strong>document.querySelectorAll(‘选择器’)</strong></p></li><li><p>两个特殊的元素(body, html)的获取方式</p><p>document.body, document.documentElement</p></li></ul><head>    <style>        .red {            color: red;}        .pink {            color: pink;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js简单数据类型和复杂数据类型</title>
    <link href="/2023/05/17/js%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/05/17/js%E7%AE%80%E5%8D%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2>JS简单数据类型和复杂数据类型</h2><h4>简单数据类型 - </h4><p>简单数据类型，又称<span class="red">值类型</span>，因为在存储时变量中存储的是值本身。</p><p>存在<span class="pink">栈</span>中</p><p>e.g. string, number, boolean, undefined, null等</p><h4>复杂数据类型</h4><p>复杂数据类型，又称<span class="red">引用类型</span>，因为在存储时变量中存储的是<strong>地址</strong></p><p>存在<span class="pink">堆</span>中</p><p>e.g. Object, Array,Date等</p><head>    <style>        .red {            color: red;}        .pink {            color: pink;        }        </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js对象</title>
    <link href="/2023/05/17/js%E5%AF%B9%E8%B1%A1/"/>
    <url>/2023/05/17/js%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h2>js中的对象数据结构</h2><ul><li><p>为什么需要对象？</p><p>保存一个值，我可以选择用变量来存<br></p><p>保存多个值，我可以选择用数组来存<br></p><p>那么如果我想存储一个人的完整信息，那么我就需要<span class="red">对象</span>啦~</p></li><li><p>对象的组成：属性 + 方法</p></li><li><p>如何创建一个对象呢？</p><ol><li>利用<span class="red">字面量</span>来进行创建 : 键值对<br></li></ol><p>   e.g. var star &#x3D; {</p><p>   ​name: xxx, <br></p><p>   ​age: 18,<br></p><p>   ​sayHi: function() {<br></p><p>   ​alert(‘Hi’)</p><p>   }}</p><p>   调用方式：star.name，star.sayHi()</p><ol start="2"><li><p>利用<span class="red">new Object</span>来创建：<br></p><p>var lxy &#x3D; new Object();<br></p><p>lxy.name &#x3D; ‘Noelle’;<br></p><p>lxy.sayHi &#x3D; function() {<br></p><p>​alert(‘Hi’)</p></li><li><p>利用<span class="red">构造函数</span>来创建：<br></p><p>[<u>好处</u>:  上述使用字面量和原生的Object构造函数一次只能创建一个对象。但是利用自定义构造函数封装公共的属性和方法，可以一次创建多个不同的对象！！！<i class="fa-solid fa-award"></i>]<br></p><p>function Person(name, age) {&#x2F;&#x2F;抽象公共部分，泛指一个类class<br></p><p>​this.name &#x3D; name;<br></p><p>​this.age &#x3D; age;<br></p><p>​this.sayHi &#x3D; function() {<br></p><p>​alert(‘Hi’)}</p><p>}</p><p>var lxy &#x3D; <span class="red">new </span> Person(‘Noelle’, 18);&#x2F;&#x2F;<span class="red">对象实例化</span></p></li><li><p><i class="fa-solid fa-trumpet"></i><span class="red"><strong>new关键字执行时做了什么？</strong></span></p><ul><li>首先，在内存中创建一个新的空对象；</li><li>其次，让<span class="red">this</span>指向这个新的空对象；</li><li>接着，执行构造函数里的代码，给新的空对象添加属性和方法；</li><li>最后，返回这个新对象（<i class="fa-solid fa-exclamation"></i>new就做了，不需要一般函数return了！）</li></ul></li><li><p>如何遍历一个对象里的所有属性？</p><p>for (var att in obj) {</p><p>xxx}</p></li><li><p>常用的的JavaScript中的内置对象和内置构造函数：Math, Date, Array, String<br></p><p>其中Math<strong>是内置对象，并不是构造函数</strong>，因为它不需要new进行调用，可以直接使用，不要被大写迷惑咯~</p><hr></hr><p>6.1 Math(内置对象)</p><ul><li>Math.floor()  向下取整</li><li>Math.ceil()向上取整</li><li>Math.round()四舍五入取整</li><li>Math.abs()绝对值</li></ul><hr></hr><p>6.2 Date（内置构造函数）</p><ul><li><p>new Date()  如果括号里有参数比如’2023&#x2F;5&#x2F;17’就返回括号里的时间；若没有参数就反正当前时间</p></li><li><p>日期格式化可用的方法：</p><p>a. getFullYear()</p><p>b. getMonth()  记得＋1！！！！！！！</p><p>c. getDate()</p><p>d. getDay()</p><p>e. getHours()</p><p>f. getMinutes()</p><p>g. getSeconds()</p></li></ul><hr></hr><p>6.3 Array (内置构造函数)</p><p>indexOf可以查找一个给定元素的第一个索引</p><hr></hr><p>6.4 String(内置构造函数)</p><p>注意!!!!字符串所有的方法都不会修改字符串本身，操作完成返回一个新的字符串而已，所以<strong>避免大量的字符串拼接</strong></p><ul><li>charAt()返回指定位置的字符</li><li>substr(start, length) 返回从start开始，长度为length的子字符串f</li><li>slice(start, end)返回[start,end)的子字符串</li><li><i class="fa-solid fa-exclamation"></i>split()将字符串切分为<strong>数组</strong>并返回</li></ul></li></ol></li></ul><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js预解析</title>
    <link href="/2023/05/17/js%E9%A2%84%E8%A7%A3%E6%9E%90/"/>
    <url>/2023/05/17/js%E9%A2%84%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2>Js预解析</h2><h4>1. 预解析的背景</h4><p>JavaScript代码是由浏览器中的javaScript解析器来执行的，但是分为两步：预解析 + 代码执行。</p><h4>2. 预解析做了什么？</h4><p>预解析阶段，js引擎会把js文件里所有的<span class="red">var变量声明</span>和<span class="red">function函数声明</span><u>提升到当前作用域的最前面</u>。</p><h4>3. 例子</h4><p>console.log(num);</p><p>var num &#x3D; 10;</p><hr></hr><p>上述代码的输出结果是undefined！！为什么不报错嘞！！就是预解析啦，相当于以下代码</p><hr></hr><p>var num; &#x2F;&#x2F; 变量提升！</p><p>console.log(num); &#x2F;&#x2F;打印一个声明但未赋值的变量就是undefined啦~</p><p>num &#x3D; 10；</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js初识</title>
    <link href="/2023/05/17/js%E5%88%9D%E8%AF%86/"/>
    <url>/2023/05/17/js%E5%88%9D%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h2>JS基础</h2><ul><li><p>计算机语言：机器语言，汇编语言，高级语言</p><p>机器语言和汇编语言都是直接对硬件操作，但汇编语言采用英文缩写的标识符</p></li><li><p>编程语言：汇编语言 + 高级语言</p><p>编程语言 ( e.g. JavaScript) v.s. 标记语言( e.g. HTML):</p><ul><li>标记语言：不向计算机发出指令，是用来被读取的</li><li>编程语言：具有很强的逻辑和行为能力，是主动的。</li></ul></li><li><p>JavaScript是什么？</p><p>JavaScript是一种运行在客户端的脚本语言（<i class="fa-solid fa-pen-to-square"></i>脚本语言不需要编译，由js引擎逐行解释并执行）</p></li><li><p>浏览器如何执行我的js代码？</p><p>浏览器引擎 &#x3D; 渲染引擎( e.g. Chrome’s blink&#x2F;webkit) + js引擎( e.g. Chrome’s v8)</p></li><li><p>JavaScript的组成部分：ECMAScript + DOM + BOM</p><p><img src="/img/js.png" alt="js组成"></p><ul><li>ECMAScript: 由ECMA国际规定JS编程语法和基础核心，是所有浏览器厂商共同遵守的一套<span class="red">js语法准则</span>。</li><li>DOM: Document Object Model, 文档对象模型：通过DOM提供的接口对页面上的元素进行操作。</li><li>BOM: Browser Object Model, 浏览器对象模型：通过BOM提供的接口可以操作浏览器窗口。</li></ul></li></ul><p>​</p><head>    <style>        .red {            color: red;}    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架1-Bootstrap</title>
    <link href="/2023/05/16/%E6%A1%86%E6%9E%B61-Bootstrap/"/>
    <url>/2023/05/16/%E6%A1%86%E6%9E%B61-Bootstrap/</url>
    
    <content type="html"><![CDATA[<h2>Bootstrap-v4使用随想</h2><p>中文文档网址：<a href="https://v4.bootcss.com/docs/getting-started/introduction/">https://v4.bootcss.com/docs/getting-started/introduction/</a></p><p>Bootstrap是由推特（Twitter）开源的一款HTML、CSS和JS框架，<strong>它主要用来开发响应式布局、移动设备优先的WEB项目</strong>。</p><ul><li><strong>step1：在所有的css样式之前引入bootstrap的css文件</strong></li></ul><ul><li><strong>step2:  在页面底部引入bootstrap的script标签</strong></li></ul>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Less</title>
    <link href="/2023/05/16/Less/"/>
    <url>/2023/05/16/Less/</url>
    
    <content type="html"><![CDATA[<h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><h4>CSS的弊端</h4><ul>    <li>CSS冗余度很高</li>    <li>不利于复用代码</li>    <li>CSS没有很好的计算能力</li></ul><h4>Less(Leaner Style Sheets)</h4><p>Less是一门<span class="red">CSS扩展语言</span>，也称为<span class="red">CSS</span>预处理器，在现有的CSS语法的基础上，加入<strong>程序式</strong>语言的特性。最大的特点就是引入了变量、函数等功能，用最少的代码做更多的事情。</p><h3>1. Less变量</h3><p>e.g. @color: pink; <br></p><p>​body {</p><p>​background-color: @color; }</p><h3>2. Less编译</h3><p><u>Easy LESS</u>插件可以使保存的less文件自动生成css文件</p><h3>3. Less嵌套</h3><p>在css选择器中的子代选择器be like: .header logo{}， 但是在less中，子元素的样式需要嵌套在父元素的样式中书写。e.g. .header{logo {}}</p><h3>4. Less实现伪类选择器</h3><p>在Less中，有<span class="red"><strong>&amp;</strong></span>符号，会被解析成<u>父元素本身</u>或者<u>父元素的伪类</u></p><p>e.g. 在css中，a:hover {}; 在Less中，a{&amp;hover{}}</p><h3>5. Less算数运算</h3><p><i class="fa-regular fa-face-smile-plus"></i>在Less中，任何数字、颜色或者变量都可以参与算数运算</p><p>[ 注：若两个不同单位的值进行算数运算， 运算结果取第一个值的单位。e.g. 10px + 5rem &#x3D; 15px;<br></p><p>若只有一个值有单位，则运算结果取该单位。e.g. 10px + 5 &#x3D; 15px]</p><head>    <style>    .red {        color: red;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Less</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>移动端常见布局</title>
    <link href="/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/"/>
    <url>/2023/05/16/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="移动端常见布局"><a href="#移动端常见布局" class="headerlink" title="移动端常见布局"></a>移动端常见布局</h2><h4>1. 流式布局</h4><p>流式布局，也叫百分比布局，也叫非固定像素布局，是通过<strong>盒子的宽度百分比</strong>来进行伸缩，而不选用固定的像素作为大小的单位。</p><h4>2. flex布局<i class="fa-solid fa-star"></i></h4><p>原理：为<u>父盒子指定flex属性</u>后称为<span class="red">容器</span>，所有子元素会自动成为<span class="red">容器成员</span>，通过特定的规则进行排列</p><p>2.1 flex布局容器常见属性</p><ul>    <li>display: flex<br>               将父盒子指定flex属性</li>    <li>flex-direction: row(默认) / row-reverse / column / column-reverse<br>            设置<strong>主轴</strong>的方向</li>    <li>justify-content: flex-start(默认) / flex-end / center / space-around / space-between<br>            设置元素在主轴上的排列方式<br>            [<span class="red">注</span>：space-around是均分剩余空间；space-between是先两边贴边再平分]</li>    <li>flex-wrap: no-wrap(默认) / wrap<br>            是否换行</li>    <li>align-items: flex-start / flex-end/ center / stretch(默认)<br>            设置<strong>侧轴</strong>上元素排列方式</li></ul><p>2.2 flex布局容器成员常见属性</p><ul>         <li>flex: 数字(默认为0)<br>               指定子元素所占的份数</li>        <li>order:数字(默认为0)            定义子元素的排列顺序，数值越小越靠前</li>     </ul><h4>3. rem适配布局</h4><p>3.1 rem（root em）单位：是一个<span class="red">相对单位</span></p><p>​[<i class="fa-solid fa-book"></i>review:  em是指父元素字体大小]</p><p>​rem的基准是相对于<span class="red">html元素字体大小</span></p><p>3.2 <i class="fa-light fa-message-smile"></i>rem的优势： 父元素字体大小可能不一致，但html可以很好的控制页面元素大小。</p><p>3.3 rem布局常和<span class="pink">媒体查询</span>一起使用</p><p>​先通过媒体查询(media query)控制html文字大小， 再通过rem单位进行动态的变化，代码如下图。</p><p><img src="/img/remMediaquery.jpg" alt="Code of rem with media query"></p><head>    <style>        .red {            color: red;}        .pink {            color: pink;}</style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>layout</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline4-DeepConvLSTMimp</title>
    <link href="/2023/05/16/baseline4-DeepConvLSTMimp/"/>
    <url>/2023/05/16/baseline4-DeepConvLSTMimp/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTMimp"><a href="#DeepConvLSTMimp" class="headerlink" title="DeepConvLSTMimp"></a>DeepConvLSTMimp</h2><p>*模型出处：Improving Deep Learning for HAR with shallow LSTMs 2021</p><h3>模型结构</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i> Opportunity</i></p></li><li><p><i>Wetlab</i></p></li><li><p><i>RealWorld (HAR)</i></p></li><li><p><i>SBHAR</i></p></li><li><p><i>HHAR.</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvLSTM</p><p>在多个数据集上对比了DeepConvLSTM和作者提出的单隐层的DeepConvLSTMimp网络，并且在单隐层的情况下，横向对比了隐藏单元的个数(128，256，512，1024）对结果的影响。</p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: 1e-4</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMimp.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>网络结构上一咪咪的改动只要足够多的对比工作也行啦~</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p>*不放了…就在把DeepConvLSTM中间的lstm2删了<i class="fa-solid fa-face-grin-squint-tears"></i></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTMimp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline2-EEGNet</title>
    <link href="/2023/05/16/baseline2-EEGNet/"/>
    <url>/2023/05/16/baseline2-EEGNet/</url>
    
    <content type="html"><![CDATA[<h2 id="EEGNet"><a href="#EEGNet" class="headerlink" title="EEGNet"></a>EEGNet</h2><p>*模型出处：EEGNet: A Compact Convolutional Network for EEG-based Brain-Computer Interfaces 2018</p><h3 id="模型结构"><a href="#模型结构" class="headerlink" title="模型结构"></a>模型结构</h3><p><img src="/img/EEGNet.png" alt="Model"></p><p><img src="/img/EEGNetspecific.png" alt="Details"></p><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p><img src="/img/EEGNetdataset.png" alt="Dataset"></p><h3>对比实验</h3><p><strong>baseline</strong>：DeepConvNet, ShallowConvNet </p><h3>超参</h3><ul>    <li>batch_size: not mentioned</li>    <li>learning_rate: not mentioned</li>    <li>epochs: 500</li>    <li>dropout: 0.5forCS / 0.25forSI</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p>在被试独立和被试交叉的情况下，四种范式上均有提升。</p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>出发点: 想要提出一种适合各种BCI范式的通用的网络，并且希望这个通用网络十分紧凑（参数数量少）。</li>    <li>亮点1：将深度卷积和可分离卷积运用到脑电数据上<br>        (1)可分离卷积在这里是指将完整的卷积运算分解为深度卷积+逐点卷积        (2)逐点卷积的作用：学习如何将特征图做优化的结合</li>    <li>亮点2：对被试交叉和被试独立的数据划分情况都做了相应的讨论</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/EEGNetCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EEGNet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline3-DeepConvLSTM</title>
    <link href="/2023/05/15/baseline3-DeepConvLSTM/"/>
    <url>/2023/05/15/baseline3-DeepConvLSTM/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConvLSTM"><a href="#DeepConvLSTM" class="headerlink" title="DeepConvLSTM"></a>DeepConvLSTM</h2><p>*模型出处：Deep Convolutional and LSTM Recurrent Neural Networks for Multimodal Wearable Activity Recognition 2016</p><h3>模型结构</h3><p><img src="/img/DeepConvLSTM.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>OPPORTUNITY</i></p></li><li><p><i>Skoda</i></p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：不带lstm的CNN（<i class="fa-light fa-thumbs-down"></i>这不就是纯纯消融实验吗？？</p><p>实验控制baseline-CNN和DeepConvLSTM前面的卷积模块和最后的分类模块完全相同，基线CNN的两个dense层是非循环且全连接的；DeepConvLSTM的两个dense层的cell是LSTM cell。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: 10e-3</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: False</li></ul><h3>结果</h3><p><img src="/img/DeepConvLSTMres1.png" alt="ResultinDataset1"></p><p><img src="/img/DeepConvLSTMres2.png" alt="ResultinDataset2"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是考虑到HAR问题的时序性，添加LSTM模</li>    <li>文中提到在他们的实验中使用RMSProp优化器效果更好</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvLSTMCode.png" alt="Code"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConvLSTM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>baseline1-DeepConv</title>
    <link href="/2023/05/15/baseline1-DeepConv/"/>
    <url>/2023/05/15/baseline1-DeepConv/</url>
    
    <content type="html"><![CDATA[<h2 id="DeepConv"><a href="#DeepConv" class="headerlink" title="DeepConv"></a>DeepConv</h2><p>*模型出处：Deep learning with convolutional neural networks for EEG decoding and visualization 2017</p><h3>模型结构</h3><p><img src="/img/DeepConv.png" alt="Model"></p><h3>数据集</h3><ol><li><p><i>BCI competition IV dataset 2a</i><span>（ 288 trials per subject）</span></p></li><li><p>自采数据集（880 trials per subject）</p></li></ol><h3>对比实验</h3><p><strong>baseline</strong>：FBCSP</p><p>设计了两层的shallowConvNet和五层的DeepConvNet甚至最高到31层的ResNet以及深浅结合的网络。</p><h3>超参</h3><ul>    <li>batch_size: 100</li>    <li>learning_rate: not mentioned</li>    <li>epochs: not mentioned</li>    <li>dropout: 0.5</li>    <li>batch_normalization: True</li></ul><h3>结果</h3><p><img src="/img/DeepConvRes.png" alt="Result"></p><h3><i class="fa-sharp fa-solid fa-stars"></i>Highlights</h3><ul>    <li>这篇的出发点是围绕着如何将在图像领域的深度卷积网络运用在脑电数据上。<br>        首先，作者提出了脑电和图像的区别：图像是二维静态的，而脑电数据是在<strong>三维的头皮上获取的时序数据        </strong><br>        接着，作者还提出了，脑电数据相比于图像数据数量太少，需要进行裁剪，也就是分段，作者用的2s一段。        </li>    <li>作者提出的DeepConv网络的Block1是专门为了提取脑电数据信息的：时间维度拼接空间维度</li>    <li>作者通过尝试对神经网络进行解释，得出结论：卷积网络学习了不同频段信息。<br>        <i class="fa-solid fa-hand-sparkles"></i>我可以试着把数据先进行小波包分解再送进网络进行学习</li></ul><h3>我实现的DeepConv网络架构部分代码</h3><p><img src="/img/DeepConvCode.png" alt="myCode"></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>deep-learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DeepConv</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>精灵图</title>
    <link href="/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/"/>
    <url>/2023/05/15/%E7%B2%BE%E7%81%B5%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="精灵图"><a href="#精灵图" class="headerlink" title="精灵图"></a>精灵图</h2><h3 id="精灵图的背景"><a href="#精灵图的背景" class="headerlink" title="精灵图的背景"></a>精灵图的背景</h3><p>一个网页中会需要很多小的背景图作为装饰，但是如果图像过多时，服务器频繁的接收和发送请求会使得服务器压力过大，降低加载速度。</p><p><i class="fa-sharp fa-light fa-truck-fast" style="color: #a4d5f4;"></i>为了<span class="red">有效减少服务器接收和发送请求的次数，提高网页的加载速度</span>， 出现了CSS精灵技术</p><h3 id="精灵图的核心原理"><a href="#精灵图的核心原理" class="headerlink" title="精灵图的核心原理"></a>精灵图的核心原理</h3><p>将一堆小的背景图像整合到一张大图 (精灵图sprites) 上，服务器只需要请求一次就可以了~</p><h3 id="精灵图的使用"><a href="#精灵图的使用" class="headerlink" title="精灵图的使用"></a>精灵图的使用</h3><p>移动背景图片的位置，调整<strong>background-position</strong>属性值</p><p>[注：属性值是调整x和y坐标的距离，但是网页的坐标是以左到右为x正方向，上到下为y正方向，所以一般我们都向上向左调整精灵图的位置，数值为<span class="red">负值</span>。]</p><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>sprites</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之三： 定位</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h2>定位</h2><p>[Review: 浮动可以让多个块级盒子在一行没有缝隙的排列显示，常用于横向排列盒子。]</p><p>终于轮到定位啦！！</p><ol><li><p>定位的目的： 让盒子自由的在某个盒子内移动位置或者固定位置， 并且可以<span class="red">压住</span>其他盒子</p></li><li><p>定位模式： 也就是position属性可能的属性值： 静态定位static、相对定位relative、绝对定位absolute、固定定位fixed</p><p>2.1 静态定位static（position属性的默认值）：无定位，可以按照标准流来看待</p><p>2.2 相对定位relative：元素在移动位置的时候，相对<u>它本身原来的位置</u>来移动的。</p><p>[<i class="fa-solid fa-flag"></i>注意]原来位置还在，相对定位并<span class="red">没有脱离标准流</span>，后面的盒子仍然以标准流的方式看它。</p><p>2.3 绝对定位absolute：元素在移动的时候，是根据他的<u>祖先元素</u>来移动的</p><p>[<i class="fa-solid fa-flag"></i>注意] 绝对定位是<span class="red">脱标</span>的！</p><p>2.4 固定定位fixed：元素固定在浏览器<u>可视区</u>的某一位置。</p><p>[<i class="fa-solid fa-flag"></i>注意] 固定定位也是脱离标准流的，不占有原来的位置。</p></li><li><p><i class="fa-solid fa-stars"></i>一个非常经典的组合：<span class="red"><strong>子绝父相</strong></span>、子绝父绝</p><p>原因：子级绝对定位不会占有位置，可以放到父盒子里任一个位置，不影响其他兄弟。而父盒子相对定位并没有脱离标准流会限制子盒子。如果父盒子也不需要占位置的话，子绝父绝也是可以滴~</p></li><li><p>绝对定位或者固定定位水平居中：在标准流中，我们可以通过margin: 0 auto；来设置元素水平居中，但是脱离标准流的时候就要{left: 50%; margin-left: -（自身宽度的一半); }</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>position</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之二：浮动</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%BA%8C%EF%BC%9A%E6%B5%AE%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h2>浮动</h2><p>这篇来复盘一下布局三大哥中的二哥： 浮动。</p><ol><li><p>传统页面布局的三种方式： 标准流、<span class="red">浮动</span>、定位。</p></li><li><p>浮动和标准流的差别：</p><ul>    <li>标准流：按照规定好的默认方式排列元素</li>    <li>浮动float：脱离标准流，按自己的规则排列</li></ul></li><li><p>浮动的特性：</p><ul>    <li>脱离标准流，以至于不再保留盒子原来的位置</li>    <li>任何元素都可以进行浮动，且浮动后会具有行内块元素相似的特性，建议如果一个元素浮动，其他的兄弟元素也一起浮动</li>    <li>浮动的元素常和标准流的父级搭配使用</li></ul></li><li><p><i class="fa-solid fa-car-on"></i>浮动可能会带来的问题： 如果父盒子在一些情况下不方便直接给高度，但是子盒子浮动是不占位置的，无法撑开盒子，父盒子的高度为0，会影响后面的标准流盒子。</p></li><li><p>清除浮动：clear: both 清除左右两侧浮动影响</p><p>清除浮动后，父级会根据子盒子自动调整高度，就可以解决上述问题了。</p></li><li><p>具体方法：</p><ol>    <li>额外标签法：在浮动的元素末尾添加一个空标签</li>    <li>父元素添加overflow: hidden属性</li>    <li>:after伪元素法：给父元素添加after伪元素并clear</li>    <li>双伪元素清除浮动：在3的基础上再添加一个:before</li></ol></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>float</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>页面布局三大核心之一：盒子模型</title>
    <link href="/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/05/15/%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80%E4%B8%89%E5%A4%A7%E6%A0%B8%E5%BF%83%E4%B9%8B%E4%B8%80%EF%BC%9A%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h2>盒子模型</h2><p>最近准备找前端实习和工作啦，就在博客上总结一下布局的三大核心：盒子模型，浮动和定位。剩下两个也有单独的讲解~</p><ol><li><p>页面布局的<strong>本质</strong>：利用CSS设置好盒子样式，摆放到相应的位置。（听起来好像很简单，坑很多）</p></li><li><p>盒子模型的组成：把HTML布局元素看成一个矩形的盒子，封装周围的元素，包括：边框border、内边距padding、外边距margin和实际内容content</p><p>2.1 边框border注意:</p> <ul><p>​  <li>复合型写法  border: 1px solid black;</li></p><p>​  <li>细线边框属性：border-collapse: collapse;</li></p><p>​  <li>如果是<strong>border-box</strong>，边框会影响盒子的实际大小，需要减去对应的宽高</p>  </ul><p>2.2 内边距padding注意：</p><ul><p>​  <li>如果padding属性有一个值，代表上下左右的padding都一样；两个值代表上下，左右；三个值代表上，左右，下；四个值代表上，右，下，左</li></p><p>​  <li>如果是<strong>border-box</strong>，padding也会撑大盒子，同理，需要减去对应的宽高</p>  </ul><p>2.3 外边距margin注意：</p><ul><p>​  <li>前两条和padding一样，见2.2</li></p><p>​  <li><i class="fa-solid fa-seal-exclamation"></i><span class="red">外边距的合并</span>会有新的问题：</br></p><p>​(1). <i class="fa-regular fa-triangle-exclamation"></i><strong>相邻</strong>元素垂直外边距合并: 并非相加，而是取大的那个</br></p><p>​(2). <i class="fa-regular fa-star-exclamation"></i><strong>嵌套</strong>元素垂直外边距合并会引起塌陷问题：父元素会塌陷较大的外边距值</li></p>  </ul></li><li><p>圆角边框：border-radius</p><p>注意复合写法的时候顺序是top-left，top-right，bottom-right, bottom-left。</p></li><li><p>盒子阴影：box-shadow</p><p>box-shadow: h-shadow v-shadow blur spread color inset;</p><p>(注：盒子阴影并不占用空间，不会影响其他盒子的排列)</p></li></ol><head>    <style>        .red {            color: red;        }    </style>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
      <tag>box-model</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在md文档中引入icon</title>
    <link href="/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/"/>
    <url>/2023/05/15/%E5%9C%A8md%E6%96%87%E6%A1%A3%E4%B8%AD%E5%BC%95%E5%85%A5icon/</url>
    
    <content type="html"><![CDATA[<h2 id="尝试如何在markdown文档中引入可爱的icon图标"><a href="#尝试如何在markdown文档中引入可爱的icon图标" class="headerlink" title="尝试如何在markdown文档中引入可爱的icon图标"></a>尝试如何在markdown文档中引入可爱的icon图标</h2><p>最近写自己的技术博客的时候，在一些地方很想插入一些可爱的图标，就想着用之前做项目的时候使用的Font Awesome图标库引入文档，由此插入其中的icon。下面是官方的地址：</p><p><i><a href="https://fontawesome.com/">https://fontawesome.com/</a></i></p><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><h5><i class="fa-solid fa-baby"></i>step1: 引入Font Awesome的js文件<img src="/img/Font-Awesome.png"/></h5><p>   （注：位置要放在head标签内）</li></p><h5><i class="fa-solid fa-person-rays"></i>step2: 在icon界面找到想要的图标，复制类名到自己的想加的地方</h5><p>   （注：拿i标签包裹一下）</li></p><head>    <script src="https://kit.fontawesome.com/42565a6d69.js" crossorigin="anonymous"></script></head><ul]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>lib</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS层叠时的优先级问题</title>
    <link href="/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2023/05/15/CSS%E5%B1%82%E5%8F%A0%E6%97%B6%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2>CSS层叠时的优先级问题</h2><p>今天在写样式的时候发现一个样式怎么也不显示，找了一圈发现是样式冲突了，css会优先执行优先级更高的样式。特意复习一下css中的优先级好啦~</p><h3>下面的选择器权重从小到大</h3><p>(ps: 也就是越往下越会优先执行）</p><ul>    <li>继承 或者通配符选择器*</li>    <li>元素选择器  e.g. p {}</li>    <li>类选择器，伪类选择器  e.g.  .para{}  .nav:hover{}</li>    <li>ID选择器  e.g.  #customid {}</li>    <li>行内样式 style=""</li>    <li>在属性值后面加!important</li></ul></ul><p><strong>在使用复合选择器的时候，要注意权重的叠加计算</strong></p>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>css文字对齐</title>
    <link href="/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/"/>
    <url>/2023/05/15/CSS%E6%96%87%E5%AD%97%E5%AF%B9%E9%BD%90/</url>
    
    <content type="html"><![CDATA[<h2 id="css文字对齐包括水平对齐和垂直对齐"><a href="#css文字对齐包括水平对齐和垂直对齐" class="headerlink" title="css文字对齐包括水平对齐和垂直对齐"></a>css文字对齐包括水平对齐和垂直对齐</h2><ol><li><p>水平对齐  <strong>text-align</strong></p><p>text-align属性默认值是left，也就是靠左侧对齐文字，如果想水平方向居中显示，则需要对元素的样式设置text-align: center</p></li><li><p>垂直对齐  <strong>line-height &#x3D; height</strong></p><p>在css中没有相对应的属性可以设置文字垂直居中，但是一个小trick就是使这一行文字的line-height等于设置的盒子高度height。</p><p>解释：因为line-height行高除了内容本身的高度以外还有上间距和下间距，可以看下面的图配合食用~</p><p>配图说明：<img title="line-height组成" src="/img/lineheight.jpg"/></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>front-end</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2023/05/12/my-first-blog/"/>
    <url>/2023/05/12/my-first-blog/</url>
    
    <content type="html"><![CDATA[<p>##This is my first blog and try it here!!</p>]]></content>
    
    
    
    <tags>
      
      <tag>try</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
